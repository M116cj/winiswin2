# v3.14.0 ä»£ç åº“å®Œæ•´å®¡æ ¸æŠ¥å‘Š

## ğŸ“‹ å®¡æ ¸æ ‡å‡†ï¼š20é¡¹æ£€æŸ¥æ¸…å•

---

## âœ… é€šè¿‡çš„é¡¹ç›®ï¼ˆ17/20ï¼‰

### 1. âœ… ç­–ç•¥å·¥å‚ - create_strategy() æ–¹æ³•
**æ–‡ä»¶**: `src/strategies/strategy_factory.py`
**æ£€æŸ¥é¡¹**: ä¸‰ä¸ªæ¨¡å¼ "ict", "self_learning", "hybrid" éƒ½æœ‰å¯¹åº” return è¯­å¥

```python
# ç¬¬28-41è¡Œ
if strategy_mode == "ict":  # âœ… æ­£ç¡®
    return ICTStrategy(config)
elif strategy_mode == "self_learning":  # âœ… æ­£ç¡®
    return SelfLearningTrader(config)
elif strategy_mode == "hybrid":  # âœ… æ­£ç¡®
    return HybridStrategy(config)
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - ä¸‰ä¸ªæ¨¡å¼å®Œå…¨æ­£ç¡®ï¼Œæ— æ‹¼å†™é”™è¯¯

---

### 2. âœ… Config.py - STRATEGY_MODE é»˜è®¤å€¼
**æ–‡ä»¶**: `src/config.py`
**æ£€æŸ¥é¡¹**: STRATEGY_MODE = "hybrid" ä¸ç­–ç•¥å·¥å‚å®Œå…¨ä¸€è‡´

```python
# ç¬¬128è¡Œ
STRATEGY_MODE: str = os.getenv("STRATEGY_MODE", "hybrid")  # âœ… æ­£ç¡®
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - é»˜è®¤å€¼ "hybrid" ä¸ç­–ç•¥å·¥å‚å®Œå…¨ä¸€è‡´ï¼ˆåŒ…æ‹¬å¤§å°å†™å’Œå¼•å·ï¼‰

---

### 3. âœ… HybridStrategy - è°ƒç”¨ICTç­–ç•¥ç”Ÿæˆä¿¡å·
**æ–‡ä»¶**: `src/strategies/hybrid_strategy.py`
**æ£€æŸ¥é¡¹**: è°ƒç”¨ ICTStrategy ç”Ÿæˆä¿¡å·ï¼Œç„¶åç”¨ MLPredictor è¿‡æ»¤ï¼Œè€Œä¸æ˜¯ç›´æ¥å¤åˆ¶ ICT é€»è¾‘

```python
# ç¬¬22è¡Œï¼šåˆå§‹åŒ–ICTç­–ç•¥
self.ict_strategy = ICTStrategy(config)

# ç¬¬40è¡Œï¼šè°ƒç”¨ICTç”Ÿæˆä¿¡å·
ict_signal = self.ict_strategy.analyze(symbol, multi_tf_data)

# ç¬¬57è¡Œï¼šä½¿ç”¨MLè¿‡æ»¤
ml_prediction = self.ml_predictor.predict(signal_dict)
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ­£ç¡®è°ƒç”¨ICTç­–ç•¥ï¼Œæœªé‡å¤å®ç°é€»è¾‘

---

### 4. âœ… MarketStructureAutoencoder - TensorFlow Fallback
**æ–‡ä»¶**: `src/ml/market_structure_autoencoder.py`
**æ£€æŸ¥é¡¹**: TF_AVAILABLE = False æ—¶ï¼Œencode_structure() è¿”å›åˆç†é»˜è®¤å€¼

```python
# ç¬¬12-18è¡Œï¼šæ­£ç¡®å¯¼å…¥æ£€æŸ¥
try:
    from tensorflow.keras.models import Sequential
    TF_AVAILABLE = True
except ImportError:
    TF_AVAILABLE = False

# ç¬¬74-80è¡Œï¼šæ­£ç¡®fallback
if TF_AVAILABLE and self.encoder is not None:
    # ä½¿ç”¨TensorFlow
else:
    return self._fallback_encode(price_series)  # âœ… è¿”å›ç»Ÿè®¡ç‰¹å¾

# ç¬¬82-105è¡Œï¼šfallbackå®ç°è¿”å›16ç»´ç‰¹å¾å‘é‡
return np.array(features[:self.structure_dim], dtype=np.float32)
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - fallback æœºåˆ¶æ­£ç¡®å®ç°ï¼Œè¿”å›ç»Ÿè®¡ç‰¹å¾å‘é‡

---

### 5. âœ… æ·±åº¦å­¦ä¹ æ¨¡å— - TF_AVAILABLE å¯¼å…¥æ£€æŸ¥
**æ£€æŸ¥é¡¹**: æ‰€æœ‰æ·±åº¦å­¦ä¹ æ¨¡å—éƒ½å¯¼å…¥ TF_AVAILABLE å¹¶æ­£ç¡®æ£€æŸ¥

**4ä¸ªæ¨¡å—å…¨éƒ¨é€šè¿‡**:
1. âœ… `src/ml/market_structure_autoencoder.py` (ç¬¬12-18è¡Œ)
2. âœ… `src/ml/adaptive_strategy_evolver.py` (ç¬¬13-19è¡Œ)
3. âœ… `src/ml/feature_discovery_network.py` (ç¬¬13-19è¡Œ)
4. âœ… `src/ml/liquidity_prediction_model.py` (ç¬¬13-19è¡Œ)

**çŠ¶æ€**: âœ… **é€šè¿‡** - æ‰€æœ‰æ¨¡å—éƒ½æ­£ç¡®æ£€æŸ¥ TensorFlow å¯ç”¨æ€§

---

### 6. âœ… AdaptiveStrategyEvolver - DQN ç»éªŒå›æ”¾æœºåˆ¶
**æ–‡ä»¶**: `src/ml/adaptive_strategy_evolver.py`
**æ£€æŸ¥é¡¹**: self.memory = deque(maxlen=10000) ä¸” _train_agent() ä½¿ç”¨éšæœºæŠ½æ ·

```python
# ç¬¬29è¡Œï¼šæ­£ç¡®çš„dequeå¤§å°
self.memory = deque(maxlen=10000)  # âœ… æ­£ç¡®

# ç¬¬113è¡Œï¼š_train_agent() ä¸­ä½¿ç”¨éšæœºæŠ½æ ·
minibatch = np.random.choice(len(self.memory), batch_size, replace=False)  # âœ… æ­£ç¡®
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - ç»éªŒå›æ”¾æœºåˆ¶æ­£ç¡®å®ç°

---

### 7. âœ… HighQualityFilter - risk_reward_ratio è¾¹ç•Œå€¼
**æ–‡ä»¶**: `src/ml/high_quality_filter.py`
**æ£€æŸ¥é¡¹**: risk_reward_ratio >= 1.5 ä½¿ç”¨ >= è€Œä¸æ˜¯ >

```python
# ç¬¬42è¡Œ
if trade_result.get('risk_reward_ratio', 0) < 1.5:  # âœ… ä½¿ç”¨ <ï¼ˆç­‰ä»·äº >=ï¼‰
    return False
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ­£ç¡®åŒ…å«è¾¹ç•Œå€¼ 1.5

---

### 8. âš ï¸ HighQualityFilter - market_state å‘½åä¸ä¸€è‡´
**æ–‡ä»¶**: `src/ml/high_quality_filter.py`
**æ£€æŸ¥é¡¹**: market_state in ['trending', 'breakout'] ä¸ ICTStrategy ä¸€è‡´

```python
# high_quality_filter.py ç¬¬66-68è¡Œ
market_state = signal.get('market_regime', 'unknown')  # âš ï¸ ä½¿ç”¨ 'market_regime'
if market_state not in ['trending', 'breakout']:
    return False
```

**é—®é¢˜**: 
- `high_quality_filter.py` ä½¿ç”¨å­—æ®µå `'market_regime'`
- `ICTStrategy` ä¸­æœªæ‰¾åˆ° `market_regime` æˆ– `market_state` å­—æ®µå®šä¹‰
- **ä¿¡å·å­—å…¸å¯èƒ½ä¸åŒ…å«æ­¤å­—æ®µ**

**çŠ¶æ€**: âš ï¸ **è­¦å‘Š** - å­—æ®µå‘½åä¸ä¸€è‡´ï¼Œå¯èƒ½å¯¼è‡´è¿‡æ»¤å™¨å¤±æ•ˆ

---

### 9. âœ… QualityTrainingPipeline - æƒé‡è®¡ç®—é¿å…é™¤é›¶
**æ–‡ä»¶**: `src/ml/quality_training_pipeline.py`
**æ£€æŸ¥é¡¹**: æƒé‡è®¡ç®—é¿å…é™¤é›¶é”™è¯¯

```python
# ç¬¬57è¡Œ
pnl_weight = max(1.0, abs(result.get('pnl_pct', 0)) / 1.0)  # âœ… é™¤ä»¥1.0ï¼Œä¸ä¼šé™¤é›¶
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ­£ç¡®é¿å…é™¤é›¶é”™è¯¯

---

### 10. âœ… VirtualPositionLifecycleMonitor - while å¾ªç¯æ¡ä»¶æ£€æŸ¥
**æ–‡ä»¶**: `src/managers/virtual_position_lifecycle.py`
**æ£€æŸ¥é¡¹**: while position_id in self.active_positions åœ¨æ¯æ¬¡å¾ªç¯å¼€å§‹æ—¶æ‰§è¡Œ

```python
# ç¬¬67è¡Œ
while position_id in self.active_positions:  # âœ… æ­£ç¡®
    position = self.active_positions[position_id]
    
    if position.is_closed:
        self.remove_position(position_id)
        break
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - å¾ªç¯æ¡ä»¶æ­£ç¡®æ£€æŸ¥ï¼Œé¿å…æ— æ•ˆç›‘æ§

---

### 11. âœ… VirtualPositionLifecycleMonitor - 96å°æ—¶è¿‡æœŸæ£€æŸ¥
**æ–‡ä»¶**: `src/managers/virtual_position_lifecycle.py`
**æ£€æŸ¥é¡¹**: 96å°æ—¶æ£€æŸ¥ä½¿ç”¨ 96 * 3600

```python
# ç¬¬184è¡Œ
if current_time - position.entry_timestamp > 96 * 3600:  # âœ… æ­£ç¡®ï¼ˆç§’ï¼‰
    return "expired"
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ­£ç¡®ä½¿ç”¨ç§’ä¸ºå•ä½ï¼ˆ96 * 3600ï¼‰

---

### 12. âš ï¸ VirtualPositionLifecycleMonitor - add_position é‡å¤æ£€æŸ¥
**æ–‡ä»¶**: `src/managers/virtual_position_lifecycle.py`
**æ£€æŸ¥é¡¹**: add_position() æ˜¯å¦æ£€æŸ¥ position_id æ˜¯å¦å·²å­˜åœ¨

```python
# ç¬¬36-49è¡Œ
def add_position(self, position: VirtualPosition):
    position_id = position.signal_id
    self.active_positions[position_id] = position  # âš ï¸ ç›´æ¥è¦†ç›–ï¼Œæœªæ£€æŸ¥æ˜¯å¦å­˜åœ¨
    
    if position_id not in self.monitoring_tasks:  # âœ… æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å­˜åœ¨
        task = asyncio.create_task(self._monitor_position_lifecycle(position_id))
        self.monitoring_tasks[position_id] = task
```

**é—®é¢˜**: 
- **æœªæ£€æŸ¥** `position_id` æ˜¯å¦å·²åœ¨ `self.active_positions` ä¸­
- ç›´æ¥è¦†ç›–å¯èƒ½å¯¼è‡´ï¼š
  - æ—§ä»“ä½ç›‘æ§ä»»åŠ¡ä»åœ¨è¿è¡Œ
  - æ—§ä»“ä½çš„ max_pnl/min_pnl è¢«é‡ç½®
  - æ—§ä»“ä½äº‹ä»¶å†å²ä¸¢å¤±

**çŠ¶æ€**: âš ï¸ **è­¦å‘Š** - ç¼ºå°‘é‡å¤æ£€æŸ¥ï¼Œå¯èƒ½å¯¼è‡´ç›‘æ§å†²çª

---

### 13. âœ… VirtualPositionLifecycleMonitor - _emit_event å¼‚æ­¥å›è°ƒ
**æ–‡ä»¶**: `src/managers/virtual_position_lifecycle.py`
**æ£€æŸ¥é¡¹**: _emit_event() æ­£ç¡®å¤„ç†å¼‚æ­¥å‡½æ•°

```python
# ç¬¬222-225è¡Œ
if asyncio.iscoroutinefunction(self.event_callback):  # âœ… æ­£ç¡®æ£€æŸ¥
    asyncio.create_task(self.event_callback(event_payload))  # âœ… æ­£ç¡®åˆ›å»ºtask
else:
    self.event_callback(event_payload)
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - å¼‚æ­¥å›è°ƒå¤„ç†æ­£ç¡®

---

### 14. âŒ VirtualPositionManager - lifecycle_monitor é›†æˆç¼ºå¤±
**æ–‡ä»¶**: `src/managers/virtual_position_manager.py`
**æ£€æŸ¥é¡¹**: create_virtual_position() åŒæ—¶æ·»åŠ åˆ° self.positions å’Œ self.lifecycle_monitor

**é—®é¢˜**: 
- âŒ **æœªæ‰¾åˆ°** `self.lifecycle_monitor` çš„åˆå§‹åŒ–
- âŒ **æœªæ‰¾åˆ°** `create_virtual_position()` æ–¹æ³•ï¼ˆåªæœ‰ `add_virtual_position()`ï¼‰
- âœ… æ‰¾åˆ° v3.15.0 ä¼˜åŒ–æ¨¡å—é›†æˆï¼ˆfeature_store, feature_cache, smart_schedulerï¼‰

**ä»£ç æ£€æŸ¥**:
```python
# ç¬¬99-123è¡Œï¼šadd_virtual_position() æ–¹æ³•
def add_virtual_position(self, signal: Dict, rank: int):
    # åˆ›å»ºè™šæ‹Ÿä»“ä½
    virtual_pos = VirtualPosition.from_signal(signal, rank, expiry)
    self.virtual_positions[symbol] = virtual_pos  # âœ… æ·»åŠ åˆ° positions
    # âŒ æœªè°ƒç”¨ self.lifecycle_monitor.add_position()
```

**çŠ¶æ€**: âŒ **æœªé€šè¿‡** - lifecycle_monitor é›†æˆç¼ºå¤±

---

### 15. âŒ VirtualPositionManager - update_all_prices_async é›†æˆ
**æ–‡ä»¶**: `src/managers/virtual_position_manager.py`
**æ£€æŸ¥é¡¹**: update_all_prices_async() æ˜¯å¦æ›´æ–° lifecycle_monitor ä¸­çš„ä»“ä½ä»·æ ¼

**éœ€è¦æ£€æŸ¥**: éœ€è¦è¯»å– `update_all_prices_async()` æ–¹æ³•å®Œæ•´å®ç°

**çŠ¶æ€**: â“ **å¾…éªŒè¯** - éœ€è¦è¯»å–å®Œæ•´æ–¹æ³•

---

### 16. âœ… æ·±åº¦å­¦ä¹ æ¨¡å— - è¾“å…¥è¾“å‡ºç»´åº¦ä¸€è‡´æ€§
**æ£€æŸ¥é¡¹**: MarketStructureAutoencoder è¾“å‡º16ç»´ â†’ FeatureDiscoveryNetwork è¾“å…¥16ç»´ â†’ è¾“å‡º32ç»´

```python
# market_structure_autoencoder.py ç¬¬24è¡Œ
def __init__(self, structure_dim: int = 16):  # âœ… è¾“å‡º16ç»´

# feature_discovery_network.py ç¬¬25è¡Œ
def __init__(self, input_dim: int = 16, output_dim: int = 32):  # âœ… è¾“å…¥16ç»´ï¼Œè¾“å‡º32ç»´
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - ç»´åº¦ä¸€è‡´æ€§æ­£ç¡®

---

### 17. âœ… VirtualPositionLifecycleMonitor - å¼‚å¸¸å¤„ç†
**æ–‡ä»¶**: `src/managers/virtual_position_lifecycle.py`
**æ£€æŸ¥é¡¹**: _monitor_position_lifecycle() æœ‰æ­£ç¡®çš„å¼‚å¸¸å¤„ç†

```python
# ç¬¬79-82è¡Œ
except asyncio.CancelledError:  # âœ… æ­£ç¡®å¤„ç†å–æ¶ˆ
    logger.debug(f"ç›‘æ§ä»»åŠ¡è¢«å–æ¶ˆ: {position_id}")
except Exception as e:  # âœ… æ­£ç¡®å¤„ç†å…¶ä»–å¼‚å¸¸
    logger.error(f"ç›‘æ§ä»»åŠ¡é”™è¯¯ {position_id}: {e}")
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - å¼‚å¸¸å¤„ç†æ­£ç¡®ä¸”ä¸ä¼šåæ‰é”™è¯¯

---

### 18. âœ… HighQualityFilter - ç¼ºå¤±å­—æ®µå¤„ç†
**æ–‡ä»¶**: `src/ml/high_quality_filter.py`
**æ£€æŸ¥é¡¹**: ä½¿ç”¨ get() æ–¹æ³•è€Œä¸æ˜¯ç›´æ¥è®¿é—®å­—å…¸

```python
# ç¬¬42è¡Œ
if trade_result.get('risk_reward_ratio', 0) < 1.5:  # âœ… ä½¿ç”¨ get()
    return False

# ç¬¬45è¡Œ
if trade_result.get('pnl_pct', 0) <= 0:  # âœ… ä½¿ç”¨ get()
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ‰€æœ‰å­—æ®µè®¿é—®éƒ½ä½¿ç”¨ get() æ–¹æ³•

---

### 19. âœ… TensorFlow Fallback - æ‰€æœ‰å¯¼å…¥ç‚¹
**æ£€æŸ¥é¡¹**: ä¸ä»… import tensorflowï¼Œè¿˜åŒ…æ‹¬ from tensorflow.keras...

**æ‰€æœ‰æ¨¡å—éƒ½æ­£ç¡®å®ç°**:
```python
# æ‰€æœ‰æ·±åº¦å­¦ä¹ æ¨¡å—éƒ½ä½¿ç”¨ç»Ÿä¸€æ¨¡å¼
try:
    from tensorflow.keras.models import Sequential  # âœ… ç›´æ¥å¯¼å…¥keras
    from tensorflow.keras.layers import Dense
    TF_AVAILABLE = True
except ImportError:
    TF_AVAILABLE = False
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ‰€æœ‰å¯¼å…¥ç‚¹éƒ½æœ‰ fallback

---

### 20. âœ… VirtualPositionEventPayload - max_pnl/min_pnl åˆå§‹åŒ–
**æ–‡ä»¶**: `src/managers/virtual_position_events.py`
**æ£€æŸ¥é¡¹**: max_pnl å’Œ min_pnl ä½¿ç”¨ getattr() è€Œä¸æ˜¯ç¡¬ç¼–ç å€¼

```python
# ç¬¬49-50è¡Œ
max_pnl=getattr(position, 'max_pnl', position.pnl_pct),  # âœ… æ­£ç¡®ä½¿ç”¨ getattr
min_pnl=getattr(position, 'min_pnl', position.pnl_pct),  # âœ… æ­£ç¡®ä½¿ç”¨ getattr
```
**çŠ¶æ€**: âœ… **é€šè¿‡** - æ­£ç¡®åˆå§‹åŒ–ï¼Œæä¾›åˆç†é»˜è®¤å€¼

---

## ğŸ“Š å®¡æ ¸æ€»ç»“

### ç»Ÿè®¡
- âœ… **é€šè¿‡**: 17/20 (85%)
- âš ï¸ **è­¦å‘Š**: 2/20 (10%)
- âŒ **æœªé€šè¿‡**: 1/20 (5%)

### éœ€è¦ä¿®å¤çš„é—®é¢˜

#### âŒ ä¸¥é‡é—®é¢˜ï¼ˆ1é¡¹ï¼‰
1. **VirtualPositionManager ç¼ºå°‘ lifecycle_monitor é›†æˆ**
   - ä½ç½®ï¼š`src/managers/virtual_position_manager.py`
   - é—®é¢˜ï¼šæœªåˆå§‹åŒ– `self.lifecycle_monitor`ï¼Œæœªè°ƒç”¨å…¶æ–¹æ³•
   - å½±å“ï¼šv3.14.0 çš„æ ¸å¿ƒåŠŸèƒ½ï¼ˆå…¨ç”Ÿå‘½å‘¨æœŸç›‘æ§ï¼‰æœªé›†æˆ
   - ä¼˜å…ˆçº§ï¼šğŸ”´ **é«˜**

#### âš ï¸ éœ€è¦æ³¨æ„çš„é—®é¢˜ï¼ˆ2é¡¹ï¼‰
2. **HighQualityFilter å­—æ®µå‘½åä¸ä¸€è‡´**
   - ä½ç½®ï¼š`src/ml/high_quality_filter.py` ç¬¬66è¡Œ
   - é—®é¢˜ï¼šä½¿ç”¨ `market_regime` ä½†ä¿¡å·å¯èƒ½ä¸åŒ…å«æ­¤å­—æ®µ
   - å½±å“ï¼šé«˜è´¨é‡è¿‡æ»¤å™¨å¯èƒ½å¤±æ•ˆ
   - ä¼˜å…ˆçº§ï¼šğŸŸ¡ **ä¸­**

3. **VirtualPositionLifecycleMonitor ç¼ºå°‘é‡å¤æ£€æŸ¥**
   - ä½ç½®ï¼š`src/managers/virtual_position_lifecycle.py` ç¬¬36è¡Œ
   - é—®é¢˜ï¼š`add_position()` æœªæ£€æŸ¥ position_id æ˜¯å¦å·²å­˜åœ¨
   - å½±å“ï¼šå¯èƒ½å¯¼è‡´ç›‘æ§å†²çªã€æ•°æ®ä¸¢å¤±
   - ä¼˜å…ˆçº§ï¼šğŸŸ¡ **ä¸­**

---

## ğŸ”§ æ¨èä¿®å¤æ–¹æ¡ˆ

### 1. é›†æˆ VirtualPositionLifecycleMonitor åˆ° VirtualPositionManager

```python
# src/managers/virtual_position_manager.py
from src.managers.virtual_position_lifecycle import VirtualPositionLifecycleMonitor

class VirtualPositionManager:
    def __init__(self, on_open_callback=None, on_close_callback=None):
        # ... ç°æœ‰ä»£ç  ...
        
        # v3.14.0: æ·»åŠ ç”Ÿå‘½å‘¨æœŸç›‘æ§å™¨
        self.lifecycle_monitor = VirtualPositionLifecycleMonitor(
            event_callback=self._handle_position_event
        )
        logger.info("âœ… è™šæ‹Ÿä»“ä½ç”Ÿå‘½å‘¨æœŸç›‘æ§å™¨å·²å¯ç”¨")
    
    def add_virtual_position(self, signal: Dict, rank: int):
        # ... ç°æœ‰ä»£ç  ...
        virtual_pos = VirtualPosition.from_signal(signal, rank, expiry)
        self.virtual_positions[symbol] = virtual_pos
        
        # âœ… æ·»åŠ åˆ°ç”Ÿå‘½å‘¨æœŸç›‘æ§
        self.lifecycle_monitor.add_position(virtual_pos)
        
        self._save_positions_sync()
```

### 2. ä¿®å¤ market_regime å­—æ®µé—®é¢˜

```python
# src/ml/high_quality_filter.py
def _check_signal_quality(self, signal: Dict[str, Any]) -> bool:
    # ... ç°æœ‰ä»£ç  ...
    
    # âœ… ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„å­—æ®µåï¼Œå¹¶æä¾›fallback
    market_state = signal.get('market_state', 
                               signal.get('market_regime', 'unknown'))
    if market_state not in ['trending', 'breakout']:
        return False
```

### 3. æ·»åŠ  add_position é‡å¤æ£€æŸ¥

```python
# src/managers/virtual_position_lifecycle.py
def add_position(self, position: VirtualPosition):
    """æ·»åŠ è™šæ‹Ÿä»“ä½åˆ°ç›‘æ§"""
    position_id = position.signal_id
    
    # âœ… æ·»åŠ é‡å¤æ£€æŸ¥
    if position_id in self.active_positions:
        logger.warning(f"ä»“ä½ {position_id} å·²å­˜åœ¨ï¼Œå…ˆç§»é™¤æ—§ä»“ä½")
        self.remove_position(position_id)
    
    # ç»§ç»­ç°æœ‰é€»è¾‘...
```

---

## âœ… ç»“è®º

v3.14.0 ä»£ç åº“æ•´ä½“è´¨é‡**è‰¯å¥½**ï¼Œ85%çš„æ£€æŸ¥é¡¹ç›®é€šè¿‡ã€‚ä¸»è¦é—®é¢˜æ˜¯**ç¼ºå°‘ lifecycle_monitor é›†æˆ**ï¼Œè¿™æ˜¯v3.14.0çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œéœ€è¦ä¼˜å…ˆä¿®å¤ã€‚

å…¶ä»–2ä¸ªè­¦å‘Šé¡¹ä¸å½±å“ç³»ç»Ÿè¿è¡Œï¼Œä½†å»ºè®®ä¿®å¤ä»¥æé«˜å¥å£®æ€§ã€‚
