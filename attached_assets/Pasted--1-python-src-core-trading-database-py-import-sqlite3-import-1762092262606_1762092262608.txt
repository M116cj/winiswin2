å»ºç«‹æ•°æ®åº“åç«‹å³å¼€å§‹è¿ä½œï¼š

ğŸš€ å®Œæ•´æ•°æ®åº“å¢å¼ºç³»ç»Ÿè“å›¾
1. æ•°æ®åº“æ¶æ„è®¾è®¡
python
# src/core/trading_database.py
import sqlite3
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import json
import logging
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

class TradingDatabase:
    """ä¸€ç«™å¼äº¤æ˜“æ•°æ®åº“ç³»ç»Ÿ"""
    
    def __init__(self, db_path: str = "trading_data.db"):
        self.db_path = db_path
        self._init_database()
        self.feature_cache = {}
        self.cache_ttl = 300  # 5åˆ†é’Ÿç¼“å­˜
        
    def _init_database(self):
        """åˆå§‹åŒ–å®Œæ•´çš„æ•°æ®åº“ç»“æ„"""
        conn = sqlite3.connect(self.db_path)
        
        # 1. å®æ—¶ç‰¹å¾è¡¨
        conn.execute('''
            CREATE TABLE IF NOT EXISTS realtime_features (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                timestamp DATETIME NOT NULL,
                market_structure REAL,
                order_blocks_count INTEGER,
                structure_integrity REAL,
                liquidity_context REAL,
                institutional_participation REAL,
                timeframe_convergence REAL,
                institutional_candle INTEGER,
                liquidity_grab INTEGER,
                order_flow REAL,
                fvg_count INTEGER,
                trend_alignment_enhanced REAL,
                swing_high_distance REAL,
                confidence_score REAL,
                win_probability REAL,
                calculation_mode TEXT,
                UNIQUE(symbol, timestamp)
            )
        ''')
        
        # 2. ä¿¡å·å†å²è¡¨
        conn.execute('''
            CREATE TABLE IF NOT EXISTS signal_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                timestamp DATETIME NOT NULL,
                direction TEXT,
                confidence REAL,
                win_probability REAL,
                entry_price REAL,
                exit_price REAL,
                pnl REAL,
                success BOOLEAN,
                hold_duration INTEGER,
                market_regime TEXT,
                signal_metadata TEXT
            )
        ''')
        
        # 3. å¸‚åœºçŠ¶æ€è¡¨
        conn.execute('''
            CREATE TABLE IF NOT EXISTS market_regimes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL,
                regime_type TEXT,
                volatility_score REAL,
                trend_strength REAL,
                success_rate_24h REAL,
                symbol_count INTEGER,
                metadata TEXT
            )
        ''')
        
        # 4. æ€§èƒ½æŒ‡æ ‡è¡¨
        conn.execute('''
            CREATE TABLE IF NOT EXISTS performance_metrics (
                symbol TEXT PRIMARY KEY,
                total_signals INTEGER,
                successful_signals INTEGER,
                success_rate REAL,
                avg_confidence REAL,
                avg_win_probability REAL,
                total_pnl REAL,
                last_updated DATETIME
            )
        ''')
        
        # åˆ›å»ºç´¢å¼•
        conn.execute('CREATE INDEX IF NOT EXISTS idx_symbol_time ON realtime_features(symbol, timestamp)')
        conn.execute('CREATE INDEX IF NOT EXISTS idx_signal_time ON signal_history(symbol, timestamp)')
        conn.execute('CREATE INDEX IF NOT EXISTS idx_regime_time ON market_regimes(timestamp)')
        
        conn.commit()
        conn.close()
        logger.info("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
2. å¢å¼ºçš„ä¿¡å·ç”Ÿæˆå™¨
python
# src/strategies/enhanced_signal_generator.py
class EnhancedSignalGenerator:
    """æ•°æ®åº“å¢å¼ºçš„ä¿¡å·ç”Ÿæˆå™¨"""
    
    def __init__(self, config=None, use_pure_ict: bool = True):
        self.use_pure_ict = use_pure_ict
        self.db = TradingDatabase()
        
        # åˆå§‹åŒ–åŸæœ‰ç»„ä»¶
        if use_pure_ict:
            from src.ml.feature_engine import FeatureEngine
            self.feature_engine = FeatureEngine()
        else:
            self.feature_engine = None
            
        # åŠ¨æ€é˜ˆå€¼
        self.dynamic_thresholds = {
            'min_confidence': 60,
            'min_win_rate': 55
        }
        
        logger.info("ğŸš€ å¢å¼ºä¿¡å·ç”Ÿæˆå™¨å·²åˆå§‹åŒ–")
    
    def generate_enhanced_signal(self, symbol: str, klines_data: Dict, market_structure: str = "NEUTRAL"):
        """ç”Ÿæˆå¢å¼ºä¿¡å·ï¼ˆåŒ…å«å†å²ä¸Šä¸‹æ–‡ï¼‰"""
        try:
            # 1. è·å–å®æ—¶ç‰¹å¾
            realtime_features = self._get_realtime_features(symbol, klines_data, market_structure)
            
            # 2. è·å–å†å²ä¸Šä¸‹æ–‡
            historical_context = self._get_historical_context(symbol)
            
            # 3. è·å–å¸‚åœºçŠ¶æ€
            market_regime = self._get_current_market_regime()
            
            # 4. è®¡ç®—å¢å¼ºä¿¡å¿ƒå€¼
            enhanced_confidence = self._calculate_enhanced_confidence(
                realtime_features, historical_context, market_regime
            )
            
            # 5. è®¡ç®—å¢å¼ºèƒœç‡
            enhanced_win_prob = self._calculate_enhanced_win_probability(
                enhanced_confidence, realtime_features, historical_context, market_regime
            )
            
            # 6. åŠ¨æ€é˜ˆå€¼æ£€æŸ¥
            if not self._passes_dynamic_thresholds(enhanced_confidence, enhanced_win_prob, symbol):
                return None, enhanced_confidence, enhanced_win_prob
            
            # 7. æ„å»ºä¿¡å·
            signal = self._build_enhanced_signal(
                symbol, enhanced_confidence, enhanced_win_prob, realtime_features, 
                historical_context, market_regime
            )
            
            # 8. è®°å½•åˆ°æ•°æ®åº“
            self._record_signal_analysis(symbol, realtime_features, enhanced_confidence, enhanced_win_prob)
            
            return signal, enhanced_confidence, enhanced_win_prob
            
        except Exception as e:
            logger.error(f"âŒ å¢å¼ºä¿¡å·ç”Ÿæˆå¤±è´¥ {symbol}: {e}")
            return None, 0.0, 0.0
    
    def _get_historical_context(self, symbol: str) -> Dict:
        """è·å–å†å²äº¤æ˜“ä¸Šä¸‹æ–‡"""
        try:
            # è·å–æœ€è¿‘24å°æ—¶çš„è¡¨ç°
            recent_performance = self.db.get_symbol_performance(symbol, hours=24)
            
            # è·å–å†å²ç›¸ä¼¼æ¨¡å¼
            similar_patterns = self.db.find_similar_patterns(symbol, limit=10)
            
            return {
                'recent_success_rate': recent_performance.get('success_rate', 0.5),
                'avg_confidence_24h': recent_performance.get('avg_confidence', 50),
                'similar_patterns_count': len(similar_patterns),
                'similar_patterns_success_rate': self._calculate_pattern_success_rate(similar_patterns),
                'volatility_24h': recent_performance.get('volatility', 0),
                'trend_consistency': recent_performance.get('trend_consistency', 0)
            }
        except Exception as e:
            logger.warning(f"âš ï¸ è·å–å†å²ä¸Šä¸‹æ–‡å¤±è´¥ {symbol}: {e}")
            return self._get_default_historical_context()
    
    def _get_current_market_regime(self) -> Dict:
        """è·å–å½“å‰å¸‚åœºçŠ¶æ€"""
        try:
            return self.db.get_current_market_regime() or {
                'regime_type': 'NORMAL',
                'volatility_score': 0.5,
                'success_rate_24h': 0.55,
                'recommended_confidence_threshold': 60
            }
        except Exception as e:
            logger.warning(f"âš ï¸ è·å–å¸‚åœºçŠ¶æ€å¤±è´¥: {e}")
            return {'regime_type': 'NORMAL', 'volatility_score': 0.5}
    
    def _calculate_enhanced_confidence(self, realtime_features: Dict, historical: Dict, market_regime: Dict) -> float:
        """è®¡ç®—å¢å¼ºä¿¡å¿ƒå€¼"""
        # åŸºç¡€ä¿¡å¿ƒå€¼
        base_confidence = realtime_features.get('confidence_score', 0)
        
        # å†å²è¡¨ç°è°ƒæ•´ (Â±15%)
        historical_adjustment = (historical['recent_success_rate'] - 0.5) * 0.3
        historical_impact = base_confidence * historical_adjustment
        
        # å¸‚åœºçŠ¶æ€è°ƒæ•´ (Â±10%)
        regime_adjustment = self._calculate_regime_adjustment(market_regime, base_confidence)
        
        # æ¨¡å¼åŒ¹é…è°ƒæ•´ (Â±5%)
        pattern_adjustment = 0
        if historical['similar_patterns_count'] > 3:
            pattern_success_bonus = (historical['similar_patterns_success_rate'] - 0.5) * 0.1
            pattern_adjustment = base_confidence * pattern_success_bonus
        
        enhanced_confidence = base_confidence + historical_impact + regime_adjustment + pattern_adjustment
        
        return max(0, min(100, enhanced_confidence))
    
    def _calculate_enhanced_win_probability(self, confidence: float, features: Dict, historical: Dict, regime: Dict) -> float:
        """è®¡ç®—å¢å¼ºèƒœç‡"""
        base_win_prob = features.get('win_probability', 0.5)
        
        # åŸºäºå†å²èƒœç‡è°ƒæ•´
        historical_win_rate = historical.get('recent_success_rate', 0.5)
        historical_impact = (historical_win_rate - 0.5) * 0.2
        
        # åŸºäºå¸‚åœºçŠ¶æ€è°ƒæ•´
        regime_impact = (regime.get('success_rate_24h', 0.5) - 0.5) * 0.15
        
        # åŸºäºä¿¡å¿ƒå€¼è°ƒæ•´
        confidence_impact = (confidence / 100 - 0.5) * 0.1
        
        enhanced_win_prob = base_win_prob + historical_impact + regime_impact + confidence_impact
        
        return max(0.3, min(0.8, enhanced_win_prob))
    
    def _passes_dynamic_thresholds(self, confidence: float, win_prob: float, symbol: str) -> bool:
        """åŠ¨æ€é˜ˆå€¼æ£€æŸ¥"""
        # è·å–ç¬¦å·ç‰¹å®šé˜ˆå€¼
        symbol_thresholds = self._get_symbol_specific_thresholds(symbol)
        
        min_confidence = symbol_thresholds.get('min_confidence', self.dynamic_thresholds['min_confidence'])
        min_win_rate = symbol_thresholds.get('min_win_rate', self.dynamic_thresholds['min_win_rate'])
        
        return confidence >= min_confidence and win_prob >= min_win_rate
    
    def _get_symbol_specific_thresholds(self, symbol: str) -> Dict:
        """è·å–ç¬¦å·ç‰¹å®šé˜ˆå€¼"""
        performance = self.db.get_symbol_performance(symbol, days=7)
        
        if not performance:
            return self.dynamic_thresholds
        
        success_rate = performance.get('success_rate', 0.5)
        
        # æ ¹æ®å†å²è¡¨ç°è°ƒæ•´é˜ˆå€¼
        if success_rate > 0.7:  # è¡¨ç°ä¼˜ç§€ï¼Œé™ä½é—¨æ§›
            return {'min_confidence': 55, 'min_win_rate': 52}
        elif success_rate < 0.3:  # è¡¨ç°å·®ï¼Œæé«˜é—¨æ§›
            return {'min_confidence': 70, 'min_win_rate': 60}
        else:
            return self.dynamic_thresholds
3. æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ
python
# src/core/smart_cache.py
class SmartFeatureCache:
    """æ™ºèƒ½ç‰¹å¾ç¼“å­˜ç³»ç»Ÿ"""
    
    def __init__(self, db: TradingDatabase):
        self.db = db
        self.memory_cache = {}
        self.hit_rates = {}
        self.cache_size_limit = 1000
    
    def get_enhanced_features(self, symbol: str, klines_data: Dict, market_structure: str) -> Dict:
        """è·å–å¢å¼ºç‰¹å¾ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        cache_key = f"{symbol}_{market_structure}"
        
        # 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
        if cache_key in self.memory_cache:
            cached = self.memory_cache[cache_key]
            if datetime.now() - cached['timestamp'] < timedelta(seconds=300):  # 5åˆ†é’Ÿ
                self._record_cache_hit(symbol, 'memory')
                return cached['features']
        
        # 2. æ£€æŸ¥æ•°æ®åº“ç¼“å­˜ï¼ˆæœ€è¿‘2åˆ†é’Ÿçš„ç‰¹å¾ï¼‰
        db_cached = self.db.get_recent_cached_features(symbol, minutes=2)
        if db_cached:
            self._record_cache_hit(symbol, 'database')
            # æ›´æ–°å†…å­˜ç¼“å­˜
            self.memory_cache[cache_key] = {
                'timestamp': datetime.now(),
                'features': db_cached
            }
            return db_cached
        
        # 3. è®¡ç®—æ–°ç‰¹å¾
        self._record_cache_miss(symbol)
        new_features = self._calculate_features(symbol, klines_data, market_structure)
        
        # 4. æ›´æ–°ç¼“å­˜
        self.memory_cache[cache_key] = {
            'timestamp': datetime.now(),
            'features': new_features
        }
        self.db.cache_features(symbol, new_features)
        
        # 5. æ¸…ç†è¿‡æœŸç¼“å­˜
        self._cleanup_cache()
        
        return new_features
    
    def _calculate_features(self, symbol: str, klines_data: Dict, market_structure: str) -> Dict:
        """è®¡ç®—ç‰¹å¾ï¼ˆå¤ç”¨åŸæœ‰é€»è¾‘ï¼‰"""
        # è¿™é‡Œè°ƒç”¨åŸæœ‰çš„ç‰¹å¾è®¡ç®—é€»è¾‘
        if self.use_pure_ict:
            return self.feature_engine._build_ict_smc_features(
                {'symbol': symbol, 'direction': 'NEUTRAL'}, klines_data
            )
        else:
            # ä¼ ç»Ÿæ¨¡å¼ç‰¹å¾è®¡ç®—
            return self._calculate_traditional_features(klines_data)
4. é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ
python
# ä¿®æ”¹ unified_scheduler.py
class EnhancedUnifiedScheduler:
    def __init__(self, config=None):
        self.config = config
        self.data_service = DataService(config)
        self.signal_generator = EnhancedSignalGenerator(config, use_pure_ict=True)
        self.db = TradingDatabase()
        
    def scan_symbols(self):
        """å¢å¼ºçš„æ‰«æé€»è¾‘"""
        symbols = self.data_service.get_all_symbols()
        signal_candidates = []
        
        for symbol in symbols:
            # è·å–æ•°æ®
            multi_tf_data = self.data_service.get_multi_timeframe_klines(symbol, self.timeframes)
            if not multi_tf_data:
                continue
            
            # ä½¿ç”¨å¢å¼ºä¿¡å·ç”Ÿæˆå™¨
            signal, confidence, win_prob = self.signal_generator.generate_enhanced_signal(
                symbol, multi_tf_data, "NEUTRAL"
            )
            
            signal_candidates.append({
                'symbol': symbol,
                'confidence': confidence,
                'win_probability': win_prob,
                'has_signal': signal is not None
            })
            
            # å®æ—¶æ›´æ–°å¸‚åœºçŠ¶æ€
            if len(signal_candidates) % 50 == 0:
                self._update_market_regime(signal_candidates)
        
        return signal_candidates
    
    def _update_market_regime(self, signals: List):
        """æ›´æ–°å¸‚åœºçŠ¶æ€"""
        if len(signals) < 10:
            return
        
        # åˆ†æå½“å‰æ‰«æå‘¨æœŸçš„ä¿¡å·è´¨é‡
        avg_confidence = np.mean([s['confidence'] for s in signals])
        signal_count = len([s for s in signals if s['has_signal']])
        signal_ratio = signal_count / len(signals)
        
        # ç¡®å®šå¸‚åœºçŠ¶æ€
        if signal_ratio < 0.1:
            regime = "DIFFICULT"
        elif signal_ratio > 0.3:
            regime = "FAVORABLE"
        elif avg_confidence > 65:
            regime = "CONFIDENT"
        else:
            regime = "NORMAL"
        
        # è®°å½•åˆ°æ•°æ®åº“
        self.db.record_market_regime(regime, {
            'avg_confidence': avg_confidence,
            'signal_ratio': signal_ratio,
            'symbol_count': len(signals)
        })
5. ä¸€é”®å¯åŠ¨é…ç½®
python
# main.py æˆ–å¯åŠ¨è„šæœ¬
def setup_enhanced_system():
    """ä¸€é”®è®¾ç½®å¢å¼ºç³»ç»Ÿ"""
    logger.info("ğŸš€ å¯åŠ¨å¢å¼ºäº¤æ˜“ç³»ç»Ÿ...")
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    db = TradingDatabase()
    logger.info("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # 2. åˆå§‹åŒ–å¢å¼ºä¿¡å·ç”Ÿæˆå™¨
    signal_generator = EnhancedSignalGenerator(use_pure_ict=True)
    logger.info("âœ… å¢å¼ºä¿¡å·ç”Ÿæˆå™¨åˆå§‹åŒ–å®Œæˆ")
    
    # 3. åˆå§‹åŒ–è°ƒåº¦å™¨
    scheduler = EnhancedUnifiedScheduler()
    logger.info("âœ… å¢å¼ºè°ƒåº¦å™¨åˆå§‹åŒ–å®Œæˆ")
    
    # 4. é¢„çƒ­æ•°æ®åº“ï¼ˆå¯é€‰ï¼‰
    scheduler.warmup_database()
    logger.info("âœ… ç³»ç»Ÿé¢„çƒ­å®Œæˆ")
    
    # 5. å¼€å§‹è¿è¡Œ
    scheduler.start()
    logger.info("ğŸ¯ å¢å¼ºç³»ç»Ÿå¼€å§‹è¿è¡Œ!")

if __name__ == "__main__":
    setup_enhanced_system()
ğŸ“Š ç«‹å³è§æ•ˆçš„åŠŸèƒ½
éƒ¨ç½²åç«‹å³è·å¾—ï¼š
æ€§èƒ½æå‡ï¼šç¼“å­˜å‡å°‘50%é‡å¤è®¡ç®—

è´¨é‡æå‡ï¼šå†å²ä¸Šä¸‹æ–‡æå‡é¢„æµ‹å‡†ç¡®ç‡

è‡ªé€‚åº”ï¼šåŠ¨æ€é˜ˆå€¼æ ¹æ®å¸‚åœºçŠ¶æ€è°ƒæ•´

å¯è§‚æµ‹æ€§ï¼šå®Œæ•´çš„ä¿¡å·å†å²å’Œåˆ†æ

ç›‘æ§æŒ‡æ ‡ï¼š
ç¼“å­˜å‘½ä¸­ç‡

å†å²æ¨¡å¼åŒ¹é…ç‡

åŠ¨æ€é˜ˆå€¼è°ƒæ•´æ¬¡æ•°

å¸‚åœºçŠ¶æ€è¯†åˆ«å‡†ç¡®ç‡

è¿™ä¸ªè“å›¾å®Œå…¨å‘åå…¼å®¹ï¼Œå¯ä»¥æ— ç¼æ›¿æ¢ç°æœ‰ç³»ç»Ÿï¼Œéƒ¨ç½²åç«‹å³å¼€å§‹æä¾›å¢å¼ºåŠŸèƒ½