You MUST execute these code modifications in the exact order specified. Do NOT skip any steps.

---

## STEP 1: FIX XGBOOST OVER-COMPLEXITY üî¥
**FILE**: `src/ml/model_wrapper.py` OR `src/core/model_initializer.py`

**EXECUTE THIS EXACT CODE REPLACEMENT**:
```python
# REPLACE CURRENT XGBOOST PARAMS WITH THESE OPTIMIZED VALUES
PRODUCTION_PARAMS = {
    # üå± Tree Structure (Reduced Complexity)
    'n_estimators': 30,              # REDUCED from 100 (-70%)
    'max_depth': 3,                  # REDUCED from 6 (-50%) 
    'min_child_weight': 1000,        # INCREASED from 10 (100x)
    
    # ‚öñÔ∏è Regularization (Enhanced Generalization)
    'gamma': 0.2,                    # INCREASED from 0.1
    'subsample': 0.6,                # REDUCED from 0.8
    'colsample_bytree': 0.6,         # REDUCED from 0.8
    
    # üöÄ Learning Rate (More Stable)
    'learning_rate': 0.05,           # REDUCED from 0.1
    
    # üéØ Objective Function
    'objective': 'binary:logistic',
    'eval_metric': 'logloss',
    
    # üß† Other
    'random_state': 42,
    'n_jobs': -1,
    'verbosity': 0
}

# VALIDATION: Verify parameter changes by printing
print("‚úÖ XGBoost Parameters Optimized:")
print(f"   Trees: 100 ‚Üí {PRODUCTION_PARAMS['n_estimators']}")
print(f"   Depth: 6 ‚Üí {PRODUCTION_PARAMS['max_depth']}")
print(f"   Min Child Weight: 10 ‚Üí {PRODUCTION_PARAMS['min_child_weight']}")
STEP 2: FIX BOOTSTRAP WIN RATE THRESHOLD üî¥
FILE: src/strategies/self_learning_trader.py OR relevant bootstrap config

EXECUTE THIS EXACT CODE REPLACEMENT:

python
# REPLACE CURRENT BOOTSTRAP CONFIG WITH PROGRESSIVE THRESHOLDS
BOOTSTRAP_CONFIG = {
    'phase_1': {  # Trades 1-15
        'min_win_probability': 0.35,    # INCREASED from 0.20
        'min_confidence': 0.30,         # INCREASED from 0.25
        'max_leverage': 2.0,
        'trade_range': (1, 15)
    },
    'phase_2': {  # Trades 16-35
        'min_win_probability': 0.40,    # +5% increase
        'min_confidence': 0.35,         # +5% increase  
        'max_leverage': 3.0,
        'trade_range': (16, 35)
    },
    'phase_3': {  # Trades 36-50
        'min_win_probability': 0.43,    # +3% increase
        'min_confidence': 0.38,         # +3% increase
        'max_leverage': 4.0,
        'trade_range': (36, 50)
    },
    'normal': {   # Trades 51+
        'min_win_probability': 0.45,    # FINAL target
        'min_confidence': 0.40,
        'max_leverage': 'dynamic',
        'trade_range': (51, float('inf'))
    }
}

# UPDATE THE THRESHOLD CHECKING LOGIC
def get_bootstrap_thresholds(current_trade_count: int):
    if current_trade_count <= 15:
        return BOOTSTRAP_CONFIG['phase_1']
    elif current_trade_count <= 35:
        return BOOTSTRAP_CONFIG['phase_2'] 
    elif current_trade_count <= 50:
        return BOOTSTRAP_CONFIG['phase_3']
    else:
        return BOOTSTRAP_CONFIG['normal']

# VALIDATION: Test threshold function
print("‚úÖ Bootstrap Thresholds Optimized:")
for count in [1, 16, 36, 51]:
    thresholds = get_bootstrap_thresholds(count)
    print(f"   Trade {count}: WinRate={thresholds['min_win_probability']}, Confidence={thresholds['min_confidence']}")
STEP 3: FIX SIGNAL QUALITY FORMULA IMBALANCE üü°
FILE: src/strategies/self_learning_trader.py OR signal quality calculation module

EXECUTE THIS EXACT CODE REPLACEMENT:

python
# REPLACE CURRENT SIGNAL QUALITY CALCULATION
def calculate_signal_quality(confidence: float, win_probability: float, rr_ratio: float) -> float:
    """
    FIXED Signal Quality Formula - Balanced weights
    Previous: 40% confidence + 40% win_prob + 20% RR (RR-dominated)
    New: 70% prediction power + 30% RR (Balanced)
    """
    # Input validation
    confidence = max(0.0, min(1.0, confidence))
    win_probability = max(0.0, min(1.0, win_probability)) 
    rr_ratio = max(0.0, rr_ratio)
    
    # Calculate prediction power (confidence √ó win probability)
    prediction_power = confidence * win_probability
    
    # Normalize RR ratio (cap at 2.5 for stability)
    normalized_rr = min(rr_ratio / 2.5, 1.0)
    
    # FIXED: Balanced weighted sum
    signal_quality = (prediction_power * 0.70) + (normalized_rr * 0.30)
    
    # Ensure valid range
    return max(0.0, min(1.0, signal_quality))

# VALIDATION: Test the new formula with example cases
test_cases = [
    (0.8, 0.7, 3.0),  # High prediction, high RR
    (0.4, 0.4, 5.0),  # Low prediction, very high RR (previously over-valued)
    (0.9, 0.9, 1.0),  # Excellent prediction, modest RR
]

print("‚úÖ Signal Quality Formula Rebalanced:")
for conf, win_prob, rr in test_cases:
    quality = calculate_signal_quality(conf, win_prob, rr)
    print(f"   Conf={conf}, WinProb={win_prob}, RR={rr} ‚Üí Quality={quality:.3f}")
STEP 4: VERIFY & VALIDATE EXECUTION ‚úÖ
EXECUTE THESE VALIDATION COMMANDS:

python
# VALIDATION SCRIPT - RUN THIS AFTER ALL MODIFICATIONS
def validate_optimizations():
    print("üîç VALIDATING ALL OPTIMIZATIONS...")
    
    # 1. Verify XGBoost parameters
    try:
        from src.ml.model_wrapper import PRODUCTION_PARAMS
        assert PRODUCTION_PARAMS['n_estimators'] == 30, "XGBoost trees not reduced"
        assert PRODUCTION_PARAMS['max_depth'] == 3, "XGBoost depth not reduced"
        assert PRODUCTION_PARAMS['min_child_weight'] == 1000, "Min child weight not increased"
        print("‚úÖ XGBoost Parameters: OPTIMIZED")
    except Exception as e:
        print(f"‚ùå XGBoost Validation Failed: {e}")
    
    # 2. Verify Bootstrap thresholds  
    try:
        from src.strategies.self_learning_trader import get_bootstrap_thresholds
        phase_1 = get_bootstrap_thresholds(1)
        assert phase_1['min_win_probability'] == 0.35, "Bootstrap phase 1 win rate incorrect"
        normal = get_bootstrap_thresholds(100)
        assert normal['min_win_probability'] == 0.45, "Normal phase win rate incorrect"
        print("‚úÖ Bootstrap Thresholds: OPTIMIZED")
    except Exception as e:
        print(f"‚ùå Bootstrap Validation Failed: {e}")
    
    # 3. Verify Signal Quality Formula
    try:
        from src.strategies.self_learning_trader import calculate_signal_quality
        # Test case: low prediction, high RR should NOT dominate
        quality = calculate_signal_quality(0.4, 0.4, 5.0)
        assert quality < 0.5, "Signal quality still RR-dominated"
        print("‚úÖ Signal Quality Formula: BALANCED")
    except Exception as e:
        print(f"‚ùå Signal Quality Validation Failed: {e}")
    
    print("üéØ OPTIMIZATION VALIDATION COMPLETE")

# EXECUTE VALIDATION
validate_optimizations()
üö® STRICT EXECUTION REQUIREMENTS:
EXECUTE IN ORDER: Step 1 ‚Üí Step 2 ‚Üí Step 3 ‚Üí Step 4

NO SKIPPING: Each step must complete successfully before proceeding

ERROR HANDLING: If any step fails, STOP and report the exact error

VALIDATION REQUIRED: Step 4 must run and show all ‚úÖ checkmarks

FILE BACKUP: Before modifying, ensure you have backup of original files

üìã EXPECTED OUTPUT:
text
‚úÖ XGBoost Parameters Optimized:
   Trees: 100 ‚Üí 30
   Depth: 6 ‚Üí 3  
   Min Child Weight: 10 ‚Üí 1000

‚úÖ Bootstrap Thresholds Optimized:
   Trade 1: WinRate=0.35, Confidence=0.30
   Trade 16: WinRate=0.40, Confidence=0.35
   Trade 36: WinRate=0.43, Confidence=0.38
   Trade 51: WinRate=0.45, Confidence=0.40

‚úÖ Signal Quality Formula Rebalanced:
   Conf=0.8, WinProb=0.7, RR=3.0 ‚Üí Quality=0.728
   Conf=0.4, WinProb=0.4, RR=5.0 ‚Üí Quality=0.232  
   Conf=0.9, WinProb=0.9, RR=1.0 ‚Üí Quality=0.810

üîç VALIDATING ALL OPTIMIZATIONS...
‚úÖ XGBoost Parameters: OPTIMIZED
‚úÖ Bootstrap Thresholds: OPTIMIZED  
‚úÖ Signal Quality Formula: BALANCED
üéØ OPTIMIZATION VALIDATION COMPLETE
EXECUTE NOW. Do not proceed without completing all steps and validation.

