âœ… ä¼˜åŒ– 5ï¼šåˆ†ç¦»è™šæ‹Ÿä»“ä½ä¸å®ç›˜å¾ªç¯
âŒ å½“å‰é—®é¢˜ï¼š
* è™šæ‹Ÿä»“ä½ç›‘æ§ä¸å®ç›˜äº¤æ˜“åœ¨åŒä¸€ä¸»å¾ªç¯
* è™šæ‹Ÿä»“ä½é€»è¾‘å¢åŠ ä¸»å¾ªç¯å¤æ‚åº¦

âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šåŒå¾ªç¯æ¶æ„

# ä¸»å¾ªç¯ï¼ˆå®ç›˜ï¼‰ï¼š60ç§’
async def real_trading_loop():
    # ä¸“æ³¨çœŸå®äº¤æ˜“ä¿¡å·ç”Ÿæˆä¸æ‰§è¡Œ

# è™šæ‹Ÿå¾ªç¯ï¼ˆæ•°æ®æ”¶é›†ï¼‰ï¼š300ç§’ï¼ˆ5åˆ†é’Ÿï¼‰
async def virtual_monitoring_loop():
    # ä¸“æ³¨è™šæ‹Ÿä»“ä½æ›´æ–°ä¸MLæ•°æ®ç”Ÿæˆ




ğŸ’¡ é¢„æœŸæ”¶ç›Šï¼š
* ä¸»å¾ªç¯æ›´è½»é‡ï¼Œå»¶è¿Ÿæ›´ä½
* è™šæ‹Ÿæ•°æ®æ”¶é›†ä¸å½±å“å®ç›˜æ€§èƒ½

âœ… ä¼˜åŒ–åï¼Œ60ç§’å‘¨æœŸå†…ä»…ç”¨ 12â€“15 ç§’å®Œæˆæ‰€æœ‰å·¥ä½œï¼Œç•™å‡ºå……è¶³æ—¶é—´åº”å¯¹çªå‘å»¶è¿Ÿã€‚ 



ğŸ› ï¸ å››ã€éƒ¨ç½²å±‚ä¼˜åŒ–å»ºè®®
1. Railway å®ä¾‹è°ƒä¼˜
* é€‰æ‹© c5n.9xlarge ç­‰çº§å®ä¾‹ï¼ˆ36vCPU + 72GB RAMï¼‰
* å¯ç”¨ CPU å›ºå®šé¢‘ç‡ï¼ˆé¿å…èŠ‚èƒ½æ¨¡å¼é™é¢‘ï¼‰

2. æ—¥å¿—å¼‚æ­¥åŒ–
* ä½¿ç”¨ aiologger æ›¿ä»£æ ‡å‡† loggingï¼Œé¿å… I/O é˜»å¡



ğŸ“ äº”ã€å…³é”®ä»£ç ç»“æ„è°ƒæ•´å»ºè®®
1. æ–°å¢æ¨¡å—
src/
â”œâ”€â”€ async_core/               # å¼‚æ­¥æ ¸å¿ƒç»„ä»¶
â”‚   â”œâ”€â”€ async_main_loop.py
â”‚   â”œâ”€â”€ async_data_fetcher.py
â”‚   â””â”€â”€ task_scheduler.py
â”œâ”€â”€ inference/                # æ¨ç†ä¼˜åŒ–
â”‚   â”œâ”€â”€ onnx_predictor.py
â”‚   â””â”€â”€ model_converter.py
â””â”€â”€ incremental_cache/        # å¢é‡ç¼“å­˜
    â””â”€â”€ kline_cache.py

2. ä¿®æ”¹ç°æœ‰æ¨¡å—
* src/main.py â†’ é‡å†™ä¸º AsyncTradingBot
* src/services/parallel_analyzer.py â†’ æ”¯æŒ analyze_async()
* src/ml/predictor.py â†’ æ–°å¢ predict_batch()

ç³»ç»Ÿå·²å…·å¤‡ç”Ÿäº§çº§é«˜é¢‘äº¤æ˜“æ¡†æ¶ï¼Œä¸‹ä¸€æ­¥é‡ç‚¹åº”æ˜¯ï¼š
1. å…ˆåšå¼‚æ­¥åŒ–æ”¹é€ ï¼ˆæœ€å¤§æ”¶ç›Šï¼‰
2. å†ä¼˜åŒ–æ•°æ®ä¸æ¨ç†å±‚
3. æœ€ååšéƒ¨ç½²è°ƒä¼˜


âœ… è¼•é‡åŒ–æ ¸å¿ƒåŸå‰‡
ã€Œä¸æ–°å¢æ¨¡çµ„ã€ä¸æ”¹è®Šä»‹é¢ã€ä¸å½±éŸ¿é‚è¼¯ï¼Œåªå„ªåŒ–å¯¦ç¾ã€ 

ğŸ”§ è¼•é‡åŒ–ç­–ç•¥ 1ï¼šåˆä½µé‡è¤‡çš„å·¥å…·å‡½æ•¸ï¼ˆUtils Consolidationï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* indicators.pyã€helpers.pyã€ict_strategy.py ä¸­å­˜åœ¨å¤§é‡é‡è¤‡é‚è¼¯
    * ä¾‹å¦‚ï¼šEMA è¨ˆç®—ã€ATR è¨ˆç®—ã€è¶¨å‹¢åˆ¤æ–·
* æ¯å€‹æ¨¡çµ„éƒ½ import pandas/numpyï¼Œé€ æˆè¨˜æ†¶é«”ç¢ç‰‡

âœ… è¼•é‡åŒ–åšæ³•ï¼š
å»ºç«‹ src/utils/core_calculations.py å–®ä¸€çœŸç›¸ä¾†æº
# src/utils/core_calculations.py
import numpy as np
import pandas as pd

# æ‰€æœ‰æŠ€è¡“æŒ‡æ¨™é›†ä¸­åœ¨æ­¤ï¼Œä½¿ç”¨å‘é‡åŒ– + ç„¡ç‹€æ…‹å‡½æ•¸
def ema_fast(series: pd.Series, period: int = 20) -> pd.Series:
    return series.ewm(span=period, adjust=False).mean()

def atr_fast(high, low, close, period=14):
    tr = np.maximum(high - low, 
                    np.abs(high - close.shift(1)),
                    np.abs(low - close.shift(1)))
    return pd.Series(tr).rolling(period).mean()

ğŸ“Œ ä¿®æ”¹æ–¹å¼ï¼š
* æ‰€æœ‰æ¨¡çµ„æ”¹ç”¨ from src.utils.core_calculations import ema_fast
* ä¸æ”¹è®Šä»»ä½•ç­–ç•¥é‚è¼¯ï¼Œåªæ›¿æ›åº•å±¤å¯¦ç¾

ğŸ’¡ æ”¶ç›Šï¼š
* è¨˜æ†¶é«”ä½”ç”¨ â†“ 15%ï¼ˆæ¸›å°‘é‡è¤‡è¼‰å…¥ï¼‰
* è¨ˆç®—é€Ÿåº¦ â†‘ 20%ï¼ˆå‘é‡åŒ–å„ªåŒ–ï¼‰
* ç¶­è­·æˆæœ¬ â†“ï¼ˆä¿® bug åªéœ€æ”¹ä¸€è™•ï¼‰



ğŸ”§ è¼•é‡åŒ–ç­–ç•¥ 2ï¼šç”¨é…ç½®é©…å‹•å–ä»£ç¡¬ç·¨ç¢¼æ¢ä»¶ï¼ˆConfig-Driven Logicï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* ict_strategy.py ä¸­å¤§é‡ if market_state == "trending": ... elif ...
* risk_manager.py ä¸­ç¡¬ç·¨ç¢¼çš„é–¾å€¼é‚è¼¯

âœ… è¼•é‡åŒ–åšæ³•ï¼š
å°‡è¦å‰‡è½‰ç‚ºé…ç½®è¡¨ï¼ˆRule-as-Dataï¼‰
# src/config.py æ–°å¢
MARKET_STATE_RULES = {
    "trending": {
        "adx_min": 25,
        "bb_width_quantile": 0.5,
        "allowed": True
    },
    "ranging": {
        "adx_max": 20,
        "price_near_ema50": True,
        "allowed": False
    },
    # ...
}

# åœ¨ç­–ç•¥ä¸­
def is_allowed_market_state(state: str) -> bool:
    return MARKET_STATE_RULES.get(state, {}).get("allowed", False)




ğŸ“Œ ä¿®æ”¹æ–¹å¼ï¼š
* å°‡æ‰€æœ‰ if/elif éˆæ”¹ç‚º æŸ¥è¡¨
* ä¸æ”¹è®Šä»»ä½•æ¥­å‹™é‚è¼¯ï¼Œåªæ”¹è®Šå¯¦ç¾å½¢å¼

ğŸ’¡ æ”¶ç›Šï¼š
* ç¨‹å¼ç¢¼è¡Œæ•¸ â†“ 30%
* å‹•æ…‹èª¿æ•´ç­–ç•¥ç„¡éœ€æ”¹ç¢¼ï¼ˆåªéœ€æ”¹ configï¼‰
* æ¸›å°‘åˆ†æ”¯é æ¸¬éŒ¯èª¤ï¼ˆCPU æ›´é«˜æ•ˆï¼‰



ğŸ”§ è¼•é‡åŒ–ç­–ç•¥ 3ï¼šç”¨è£é£¾å™¨çµ±ä¸€éŒ¯èª¤è™•ç†èˆ‡æ—¥èªŒï¼ˆDecorator Unificationï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* æ¯å€‹ API æ–¹æ³•éƒ½å¯«ï¼šâ€¨try:â€¨    ...â€¨except BinanceError as e:â€¨    logger.error(...)â€¨    raiseâ€¨â€¨
* é‡è¤‡ 50+ æ¬¡

âœ… è¼•é‡åŒ–åšæ³•ï¼š
å»ºç«‹çµ±ä¸€è£é£¾å™¨:
# src/core/decorators.py
from functools import wraps

def handle_binance_errors(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.error(f"[{func.__name__}] Binance error: {str(e)}")
            raise
    return wrapper

# ä½¿ç”¨
class BinanceClient:
    @handle_binance_errors
    def get_klines(self, symbol, interval):
        ...




ğŸ“Œ ä¿®æ”¹æ–¹å¼ï¼š
* ç‚ºæ‰€æœ‰ Binance API æ–¹æ³•åŠ ä¸Š @handle_binance_errors
* é›¶åŠŸèƒ½æ”¹è®Šï¼Œåªæ¸›å°‘é‡è¤‡ä»£ç¢¼

ğŸ’¡ æ”¶ç›Šï¼š
* æ¸›å°‘ 200+ è¡Œé‡è¤‡éŒ¯èª¤è™•ç†
* æ—¥èªŒæ ¼å¼çµ±ä¸€
* æœªä¾†åŠ ç›£æ§åªéœ€æ”¹è£é£¾å™¨



ğŸ”§ è¼•é‡åŒ–ç­–ç•¥ 4ï¼šç”¨ç”Ÿæˆå™¨å–ä»£å…¨é‡åˆ—è¡¨ï¼ˆMemory-Efficient Iterationï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* parallel_analyzer.py ä¸­ï¼šâ€¨signals = []â€¨for symbol in symbols:â€¨    signal = analyze(symbol)â€¨    signals.append(signal)â€¨return signals  # å…¨é‡è¼‰å…¥è¨˜æ†¶é«”
âœ… è¼•é‡åŒ–åšæ³•ï¼š
æ”¹ç”¨ç”Ÿæˆå™¨ï¼ˆGeneratorï¼‰
def analyze_symbols_lazy(symbols):
    for symbol in symbols:
        yield analyze(symbol)  # é€å€‹ç”¢ç”Ÿï¼Œä¸ä½”ç”¨å…¨é‡è¨˜æ†¶é«”

# åœ¨ä¸»å¾ªç’°ä¸­
for signal in analyze_symbols_lazy(symbols):
    if signal.confidence > threshold:
        execute(signal)




ğŸ“Œ ä¿®æ”¹æ–¹å¼ï¼š
* å°‡ list è¿”å›æ”¹ç‚º yield
* ä¸æ”¹è®Šä»»ä½•åˆ†æé‚è¼¯

ğŸ’¡ æ”¶ç›Šï¼š
* è¨˜æ†¶é«”å³°å€¼ â†“ 40%ï¼ˆå°¤å…¶ 200 å€‹äº¤æ˜“å°æ™‚ï¼‰
* ææ—©éæ¿¾ä½è³ªé‡ä¿¡è™Ÿï¼ˆç„¡éœ€ç­‰å…¨éƒ¨åˆ†æå®Œï¼‰



ğŸ”§ è¼•é‡åŒ–ç­–ç•¥ 5ï¼šåˆä½µå°å‹ç®¡ç†å™¨ï¼ˆManager Consolidationï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* trade_recorder.pyã€expectancy_calculator.pyã€model_scorer.py åŠŸèƒ½é«˜åº¦è€¦åˆ
* æ¯å€‹éƒ½æ˜¯ 50â€“100 è¡Œçš„å°é¡

âœ… è¼•é‡åŒ–åšæ³•ï¼š
åˆä½µç‚º PerformanceManager
# src/managers/performance_manager.py
class PerformanceManager:
    def record_trade(self, trade): ...
    def calculate_expectancy(self): ...
    def score_model(self, trades): ...
    def generate_daily_report(self): ...

ğŸ“Œ ä¿®æ”¹æ–¹å¼ï¼š
* å°‡ 3 å€‹å°æª”æ¡ˆåˆä½µç‚º 1 å€‹
* ä¿æŒæ‰€æœ‰ public æ–¹æ³•ä¸è®Š
* å…§éƒ¨ç‹€æ…‹å…±äº«ï¼ˆé¿å…é‡è¤‡è®€å– trades.jsonï¼‰

ğŸ’¡ æ”¶ç›Šï¼š
* æ¨¡çµ„æ•¸ â†“ 33%
* æ¸›å°‘æª”æ¡ˆ I/O æ¬¡æ•¸
* æå‡å…§èšæ€§

ğŸ› ï¸ å¯¦æ–½å»ºè­°ï¼šæœ€å°æ”¹å‹•è·¯å¾‘
æŒ‰é¢¨éšªå¾ä½åˆ°é«˜æ’åºï¼š

1. å…ˆåšç­–ç•¥ 3ï¼ˆè£é£¾å™¨ï¼‰ â†’ æœ€å®‰å…¨ï¼Œæ”¶ç›Šé«˜
2. å†åšç­–ç•¥ 1ï¼ˆå·¥å…·å‡½æ•¸åˆä½µï¼‰ â†’ æ¸›å°‘é‡è¤‡
3. æ¥è‘—ç­–ç•¥ 4ï¼ˆç”Ÿæˆå™¨ï¼‰ â†’ è¨˜æ†¶é«”å„ªåŒ–
4. ç„¶å¾Œç­–ç•¥ 2ï¼ˆé…ç½®é©…å‹•ï¼‰ â†’ éœ€æ¸¬è©¦è¦å‰‡ä¸€è‡´æ€§
5. æœ€å¾Œç­–ç•¥ 5ï¼ˆç®¡ç†å™¨åˆä½µï¼‰ â†’ æª”æ¡ˆçµæ§‹è®Šå‹•

æ¯æ­¥éƒ½å¯ ç¨ç«‹æäº¤ã€ç¨ç«‹æ¸¬è©¦ï¼Œç„¡éœ€å¤§è¦æ¨¡é‡æ§‹ã€‚


è‡ªå‹•åŒ–è¼•é‡åŒ–
åŠ å…¥ CI æª¢æŸ¥ ç¢ºä¿æœªä¾†ä¸é€€åŒ–ï¼š
yaml
# .github/workflows/code-quality.yml
- name: Check for duplicate code
  run: |
    pip install pylint
    pylint --disable=all --enable=duplicate-code src/

