å•é¡Œå¾ˆæ˜ç¢ºï¼šäº¤æ˜“æ•¸é‡æ²’æœ‰æ­£ç¢ºç´¯è¨ˆï¼Œå°è‡´ç³»çµ±ä¸€ç›´è™•æ–¼è±å…æœŸæ¨¡å¼ã€‚è®“æˆ‘æä¾›å®Œæ•´çš„ä¿®å¾©æ–¹æ¡ˆï¼š

ğŸ”§ äº¤æ˜“æ•¸é‡ç´¯è¨ˆå•é¡Œä¿®å¾©

å•é¡Œè¨ºæ–·

å¾æ—¥èªŒå¯ä»¥çœ‹åˆ°ï¼š

```
è³ªé‡é–€æª»: 0.25 (è±å…æœŸæ¨¡å¼ï¼ˆäº¤æ˜“æ•¸:0/100ï¼‰)
```

ç³»çµ±é¡¯ç¤ºäº¤æ˜“æ•¸ç‚º 0/100ï¼Œä½†å¯¦éš›ä¸Šæ‡‰è©²æœ‰äº¤æ˜“åŸ·è¡Œã€‚

ä¿®å¾©1: ä¿®å¾© CapitalAllocator çš„äº¤æ˜“è¨ˆæ•¸

```python
# src/core/capital_allocator.py

import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import asyncio

logger = logging.getLogger(__name__)

class CapitalAllocator:
    """è³‡æœ¬åˆ†é…å™¨ - ä¿®å¾©äº¤æ˜“è¨ˆæ•¸å•é¡Œ"""
    
    def __init__(self, config, trade_recorder):
        self.config = config
        self.trade_recorder = trade_recorder
        
        # è³‡æœ¬ç‹€æ…‹
        self.capital_state = {
            'total_equity': 0.0,
            'total_capital': 0.0, 
            'used_margin': 0.0,
            'available_margin': 0.0
        }
        
        # äº¤æ˜“çµ±è¨ˆ - ä¿®å¾©ï¼šæ·»åŠ æœ¬åœ°ç·©å­˜
        self.trade_stats = {
            'total_trades': 0,
            'today_trades': 0,
            'bootstrap_trades': 0,  # è±å…æœŸäº¤æ˜“è¨ˆæ•¸
            'last_trade_time': None,
            'bootstrap_completed': False
        }
        
        # è³ªé‡é–€æª»é…ç½®
        self.quality_config = {
            'bootstrap_threshold': 100,  # è±å…æœŸéœ€è¦100ç­†äº¤æ˜“
            'normal_confidence_threshold': 0.60,
            'bootstrap_confidence_threshold': 0.25,  # è±å…æœŸé–€æª»
            'bootstrap_win_rate_threshold': 0.48
        }
        
        # åˆå§‹åŒ–æ™‚ç«‹å³åŠ è¼‰äº¤æ˜“çµ±è¨ˆ
        asyncio.create_task(self._load_trade_stats())

    async def _load_trade_stats(self):
        """åŠ è¼‰äº¤æ˜“çµ±è¨ˆæ•¸æ“š - ä¿®å¾©ç‰ˆæœ¬"""
        try:
            # å¾ TradeRecorder ç²å–ç¸½äº¤æ˜“æ•¸é‡
            total_trades = await self.trade_recorder.get_trade_count('all')
            
            # ç²å–ä»Šå¤©çš„äº¤æ˜“æ•¸é‡
            today_trades = await self.trade_recorder.get_trade_count('24h')
            
            # è¨ˆç®—è±å…æœŸäº¤æ˜“æ•¸é‡ï¼ˆç¸½äº¤æ˜“æ•¸ï¼‰
            bootstrap_trades = total_trades
            
            self.trade_stats.update({
                'total_trades': total_trades,
                'today_trades': today_trades,
                'bootstrap_trades': bootstrap_trades,
                'bootstrap_completed': bootstrap_trades >= self.quality_config['bootstrap_threshold']
            })
            
            logger.info(
                f"ğŸ“Š äº¤æ˜“çµ±è¨ˆåŠ è¼‰å®Œæˆ: "
                f"ç¸½äº¤æ˜“={total_trades}, "
                f"ä»Šæ—¥={today_trades}, "
                f"è±å…æœŸ={bootstrap_trades}/{self.quality_config['bootstrap_threshold']}"
            )
            
        except Exception as e:
            logger.error(f"âŒ åŠ è¼‰äº¤æ˜“çµ±è¨ˆå¤±æ•—: {e}")
            # è¨­ç½®é»˜èªå€¼
            self.trade_stats.update({
                'total_trades': 0,
                'today_trades': 0, 
                'bootstrap_trades': 0,
                'bootstrap_completed': False
            })

    async def update_capital_state(self, new_state: Dict):
        """æ›´æ–°è³‡æœ¬ç‹€æ…‹ - ä¿®å¾©ç‰ˆæœ¬"""
        try:
            self.capital_state.update(new_state)
            
            # æ¯æ¬¡æ›´æ–°æ™‚ä¹Ÿæ›´æ–°äº¤æ˜“çµ±è¨ˆ
            await self._refresh_trade_stats()
            
            logger.info(
                f"ğŸ’° è³‡æœ¬ç‹€æ…‹æ›´æ–° | "
                f"å¸³æˆ¶æ¬Šç›Š: ${self.capital_state['total_equity']:.2f} | "
                f"ç¸½é‡‘é¡: ${self.capital_state['total_capital']:.2f} | "
                f"å·²ä½”ç”¨ä¿è­‰é‡‘: ${self.capital_state['used_margin']:.2f} | "
                f"è³ªé‡é–€æª»: {self.get_quality_threshold():.2f} "
                f"({self._get_bootstrap_status()})"
            )
            
        except Exception as e:
            logger.error(f"âŒ æ›´æ–°è³‡æœ¬ç‹€æ…‹å¤±æ•—: {e}")

    async def _refresh_trade_stats(self):
        """åˆ·æ–°äº¤æ˜“çµ±è¨ˆ - ä¿®å¾©ï¼šç¢ºä¿æ•¸æ“šå¯¦æ™‚æ›´æ–°"""
        try:
            # å¯¦æ™‚æŸ¥è©¢äº¤æ˜“æ•¸é‡
            total_trades = await self.trade_recorder.get_trade_count('all')
            today_trades = await self.trade_recorder.get_trade_count('24h')
            
            # æ›´æ–°çµ±è¨ˆ
            self.trade_stats['total_trades'] = total_trades
            self.trade_stats['today_trades'] = today_trades
            self.trade_stats['bootstrap_trades'] = total_trades  # è±å…æœŸä½¿ç”¨ç¸½äº¤æ˜“æ•¸
            
            # æª¢æŸ¥è±å…æœŸæ˜¯å¦å®Œæˆ
            if total_trades >= self.quality_config['bootstrap_threshold']:
                self.trade_stats['bootstrap_completed'] = True
                
        except Exception as e:
            logger.error(f"âŒ åˆ·æ–°äº¤æ˜“çµ±è¨ˆå¤±æ•—: {e}")

    async def record_new_trade(self, trade_data: Dict):
        """è¨˜éŒ„æ–°äº¤æ˜“ - ä¿®å¾©ï¼šç¢ºä¿è¨ˆæ•¸æ­£ç¢ºæ›´æ–°"""
        try:
            # æ›´æ–°æœ¬åœ°çµ±è¨ˆ
            self.trade_stats['total_trades'] += 1
            self.trade_stats['today_trades'] += 1
            self.trade_stats['bootstrap_trades'] += 1
            self.trade_stats['last_trade_time'] = datetime.now()
            
            # æª¢æŸ¥è±å…æœŸå®Œæˆ
            if self.trade_stats['bootstrap_trades'] >= self.quality_config['bootstrap_threshold']:
                self.trade_stats['bootstrap_completed'] = True
                logger.info(
                    f"ğŸ‰ è±å…æœŸå®Œæˆ! "
                    f"ç´¯è¨ˆäº¤æ˜“: {self.trade_stats['bootstrap_trades']}/"
                    f"{self.quality_config['bootstrap_threshold']}"
                )
            
            logger.info(
                f"ğŸ“ˆ äº¤æ˜“è¨˜éŒ„æ›´æ–°: "
                f"ç¸½äº¤æ˜“={self.trade_stats['total_trades']}, "
                f"è±å…æœŸ={self.trade_stats['bootstrap_trades']}/"
                f"{self.quality_config['bootstrap_threshold']}"
            )
            
        except Exception as e:
            logger.error(f"âŒ è¨˜éŒ„æ–°äº¤æ˜“å¤±æ•—: {e}")

    def get_quality_threshold(self) -> float:
        """ç²å–è³ªé‡é–€æª» - ä¿®å¾©ï¼šæ­£ç¢ºåˆ¤æ–·è±å…æœŸ"""
        if not self.trade_stats['bootstrap_completed']:
            return self.quality_config['bootstrap_confidence_threshold']
        else:
            return self.quality_config['normal_confidence_threshold']

    def _get_bootstrap_status(self) -> str:
        """ç²å–è±å…æœŸç‹€æ…‹æè¿°"""
        if self.trade_stats['bootstrap_completed']:
            return "æ­£å¸¸æ¨¡å¼"
        else:
            return f"è±å…æœŸæ¨¡å¼ï¼ˆäº¤æ˜“æ•¸:{self.trade_stats['bootstrap_trades']}/{self.quality_config['bootstrap_threshold']}ï¼‰"

    def can_allocate_capital(self, signal_quality: float) -> bool:
        """æª¢æŸ¥æ˜¯å¦å¯ä»¥åˆ†é…è³‡æœ¬ - ä¿®å¾©ç‰ˆæœ¬"""
        try:
            # ç²å–ç•¶å‰è³ªé‡é–€æª»
            current_threshold = self.get_quality_threshold()
            
            # æª¢æŸ¥ä¿¡è™Ÿè³ªé‡
            if signal_quality < current_threshold:
                logger.debug(
                    f"âš ï¸ ä¿¡è™Ÿè³ªé‡ä¸è¶³: {signal_quality:.3f} < {current_threshold:.3f} "
                    f"({self._get_bootstrap_status()})"
                )
                return False
            
            # æª¢æŸ¥ä¿è­‰é‡‘
            if self.capital_state['available_margin'] <= 0:
                logger.warning("âš ï¸ å¯ç”¨ä¿è­‰é‡‘ä¸è¶³")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ è³‡æœ¬åˆ†é…æª¢æŸ¥å¤±æ•—: {e}")
            return False

    async def allocate_position_size(self, signal: Dict) -> float:
        """åˆ†é…é ­å¯¸å¤§å° - ä¿®å¾©ç‰ˆæœ¬"""
        try:
            if not self.can_allocate_capital(signal.get('confidence', 0)):
                return 0.0
            
            # åŸºç¤é ­å¯¸æ¯”ä¾‹
            base_percentage = 0.15  # 15%
            
            # è±å…æœŸä½¿ç”¨æ›´ä¿å®ˆçš„é ­å¯¸
            if not self.trade_stats['bootstrap_completed']:
                base_percentage = 0.10  # è±å…æœŸ10%
            
            # æ ¹æ“šä¿¡è™Ÿè³ªé‡èª¿æ•´
            confidence = signal.get('confidence', 0)
            if confidence >= 0.70:
                base_percentage *= 1.2
            elif confidence >= 0.60:
                base_percentage *= 1.0
            else:
                base_percentage *= 0.8
            
            position_size = self.capital_state['available_margin'] * base_percentage
            
            # ç¢ºä¿æœ€å°äº¤æ˜“è¦æ¨¡
            if position_size < 1.0:
                return 0.0
            
            logger.info(
                f"ğŸ’° é ­å¯¸åˆ†é…: {signal.get('symbol')} | "
                f"å¤§å°: ${position_size:.2f} | "
                f"æ¯”ä¾‹: {base_percentage*100:.1f}% | "
                f"æ¨¡å¼: {self._get_bootstrap_status()}"
            )
            
            return round(position_size, 2)
            
        except Exception as e:
            logger.error(f"âŒ é ­å¯¸åˆ†é…å¤±æ•—: {e}")
            return 0.0

    async def get_performance_report(self) -> Dict:
        """ç²å–æ€§èƒ½å ±å‘Š - ä¿®å¾©ç‰ˆæœ¬"""
        try:
            await self._refresh_trade_stats()
            
            return {
                'capital_state': self.capital_state.copy(),
                'trade_stats': self.trade_stats.copy(),
                'quality_threshold': self.get_quality_threshold(),
                'bootstrap_status': self._get_bootstrap_status(),
                'bootstrap_progress': f"{self.trade_stats['bootstrap_trades']}/{self.quality_config['bootstrap_threshold']}",
                'bootstrap_percentage': (self.trade_stats['bootstrap_trades'] / self.quality_config['bootstrap_threshold']) * 100
            }
            
        except Exception as e:
            logger.error(f"âŒ ç²å–æ€§èƒ½å ±å‘Šå¤±æ•—: {e}")
            return {}
```

ä¿®å¾©2: ä¿®å¾© SelfLearningTrader çš„äº¤æ˜“è¨˜éŒ„é‚è¼¯

```python
# åœ¨ src/strategies/self_learning_trader.py ä¸­ä¿®å¾©

class SelfLearningTrader:
    async def execute_best_trades(self, best_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œæœ€ä½³äº¤æ˜“ - ä¿®å¾©äº¤æ˜“è¨ˆæ•¸"""
        try:
            logger.info("ğŸš€ åŸ·è¡Œäº¤æ˜“é€±æœŸ - ä¿®å¾©ç‰ˆæœ¬")
            
            # ä¿®å¾©ï¼šç¢ºä¿äº¤æ˜“çµ±è¨ˆæ›´æ–°
            await self.capital_allocator._refresh_trade_stats()
            
            executed_positions = []
            available_margin = self.capital_allocator.capital_state.get('available_margin', 0)
            
            logger.info(
                f"ğŸ’° é–‹å§‹åŸ·è¡Œäº¤æ˜“ | "
                f"å¯ç”¨ä¿è­‰é‡‘: ${available_margin:.2f} | "
                f"ç•¶å‰æ¨¡å¼: {self.capital_allocator._get_bootstrap_status()}"
            )
            
            # è³ªé‡éæ¿¾å’Œç²¾è‹±æ’å
            qualified_signals = [s for s in best_signals 
                               if self._validate_signal_quality(s)]
            top_signals = sorted(qualified_signals, 
                               key=lambda x: x.get('confidence', 0), 
                               reverse=True)[:3]
            
            # åŸ·è¡Œäº¤æ˜“
            for i, signal in enumerate(top_signals):
                if available_margin <= 0:
                    break
                    
                # åˆ†é…é ­å¯¸
                position_size = await self.capital_allocator.allocate_position_size(signal)
                
                if position_size > 0:
                    try:
                        # åŸ·è¡Œäº¤æ˜“
                        executed_trade = await self._execute_single_trade(signal, position_size)
                        if executed_trade:
                            executed_positions.append(executed_trade)
                            available_margin -= position_size
                            
                            # ä¿®å¾©ï¼šè¨˜éŒ„äº¤æ˜“åˆ° TradeRecorder
                            record_success = await self.trade_recorder.record_trade(executed_trade)
                            if record_success:
                                # ä¿®å¾©ï¼šæ›´æ–° CapitalAllocator çš„äº¤æ˜“è¨ˆæ•¸
                                await self.capital_allocator.record_new_trade(executed_trade)
                            else:
                                logger.error(f"âŒ äº¤æ˜“è¨˜éŒ„å¤±æ•—: {executed_trade.get('symbol')}")
                            
                            logger.info(
                                f"âœ… äº¤æ˜“åŸ·è¡ŒæˆåŠŸ: {signal.get('symbol')} | "
                                f"å¤§å°: ${position_size:.2f} | "
                                f"å‰©é¤˜: ${available_margin:.2f}"
                            )
                            
                    except Exception as e:
                        logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            
            # ä¿®å¾©ï¼šäº¤æ˜“å¾Œåˆ·æ–°çµ±è¨ˆ
            await self.capital_allocator._refresh_trade_stats()
            
            logger.info(
                f"ğŸ‰ äº¤æ˜“é€±æœŸå®Œæˆ: {len(executed_positions)}ç­†äº¤æ˜“ | "
                f"ç´¯è¨ˆäº¤æ˜“: {self.capital_allocator.trade_stats['bootstrap_trades']}/"
                f"{self.capital_allocator.quality_config['bootstrap_threshold']}"
            )
            
            return executed_positions
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            return []
```

ä¿®å¾©3: æ·»åŠ äº¤æ˜“è¨ˆæ•¸è¨ºæ–·

```python
# src/utils/trade_count_diagnostic.py

import asyncio
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

async def diagnose_trade_count(capital_allocator, trade_recorder):
    """è¨ºæ–·äº¤æ˜“è¨ˆæ•¸å•é¡Œ"""
    try:
        logger.info("ğŸ” é–‹å§‹äº¤æ˜“è¨ˆæ•¸è¨ºæ–·...")
        
        # 1. æª¢æŸ¥ TradeRecorder
        total_count = await trade_recorder.get_trade_count('all')
        today_count = await trade_recorder.get_trade_count('24h')
        
        logger.info(f"ğŸ“Š TradeRecorder çµ±è¨ˆ: ç¸½äº¤æ˜“={total_count}, ä»Šæ—¥={today_count}")
        
        # 2. æª¢æŸ¥ CapitalAllocator
        ca_stats = capital_allocator.trade_stats
        logger.info(f"ğŸ“Š CapitalAllocator çµ±è¨ˆ: {ca_stats}")
        
        # 3. æª¢æŸ¥æ•¸æ“šä¸€è‡´æ€§
        if total_count != ca_stats['bootstrap_trades']:
            logger.warning(
                f"âš ï¸ æ•¸æ“šä¸ä¸€è‡´: "
                f"TradeRecorder={total_count}, "
                f"CapitalAllocator={ca_stats['bootstrap_trades']}"
            )
            
            # è‡ªå‹•ä¿®å¾©
            capital_allocator.trade_stats['bootstrap_trades'] = total_count
            capital_allocator.trade_stats['total_trades'] = total_count
            logger.info("âœ… å·²è‡ªå‹•ä¿®å¾©æ•¸æ“šä¸ä¸€è‡´")
        
        # 4. æ€§èƒ½å ±å‘Š
        report = await capital_allocator.get_performance_report()
        logger.info(f"ğŸ“ˆ æ€§èƒ½å ±å‘Š: {report}")
        
        return True
        
    except Exception as e:
        logger.error(f"âŒ äº¤æ˜“è¨ˆæ•¸è¨ºæ–·å¤±æ•—: {e}")
        return False

# åœ¨ä¸»å¾ªç’°ä¸­å®šæœŸé‹è¡Œè¨ºæ–·
async def start_trade_count_monitor(capital_allocator, trade_recorder):
    """å•Ÿå‹•äº¤æ˜“è¨ˆæ•¸ç›£æ§"""
    while True:
        await diagnose_trade_count(capital_allocator, trade_recorder)
        await asyncio.sleep(300)  # æ¯5åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
```

ç«‹å³éƒ¨ç½²ä¿®å¾©

```bash
#!/bin/bash
echo "ğŸš€ éƒ¨ç½²äº¤æ˜“è¨ˆæ•¸ä¿®å¾©..."

# 1. ä¿®å¾© CapitalAllocator
cat > src/core/capital_allocator.py << 'EOF'
# [ä¸Šé¢çš„å®Œæ•´ CapitalAllocator ä¿®å¾©ä»£ç¢¼]
EOF

# 2. ä¿®å¾© SelfLearningTrader çš„äº¤æ˜“è¨˜éŒ„éƒ¨åˆ†
# æ‰¾åˆ° execute_best_trades æ–¹æ³•ä¸¦æ›´æ–°

# 3. æ·»åŠ è¨ºæ–·å·¥å…·
mkdir -p src/utils/
cat > src/utils/trade_count_diagnostic.py << 'EOF'
# [ä¸Šé¢çš„è¨ºæ–·ä»£ç¢¼]
EOF

# 4. åœ¨ä¸»ç¨‹åºä¸­å•Ÿå‹•ç›£æ§
echo "åœ¨ main.py ä¸­æ·»åŠ :"
echo "from src.utils.trade_count_diagnostic import start_trade_count_monitor"
echo "asyncio.create_task(start_trade_count_monitor(capital_allocator, trade_recorder))"

# 5. éƒ¨ç½²
git add src/core/capital_allocator.py src/utils/trade_count_diagnostic.py
git commit -m "fix: ä¿®å¾©äº¤æ˜“è¨ˆæ•¸ç´¯è¨ˆå•é¡Œ + æ·»åŠ è¨ºæ–·ç›£æ§"
git push origin main

echo "âœ… ä¿®å¾©éƒ¨ç½²å®Œæˆï¼"
```

ğŸ¯ ä¿®å¾©æ•ˆæœ

ä¿®å¾©å‰ï¼š

```
è³ªé‡é–€æª»: 0.25 (è±å…æœŸæ¨¡å¼ï¼ˆäº¤æ˜“æ•¸:0/100ï¼‰)
```

ä¿®å¾©å¾Œï¼š

```
ğŸ“Š äº¤æ˜“çµ±è¨ˆåŠ è¼‰å®Œæˆ: ç¸½äº¤æ˜“=15, ä»Šæ—¥=3, è±å…æœŸ=15/100
ğŸ’° è³‡æœ¬ç‹€æ…‹æ›´æ–° | è³ªé‡é–€æª»: 0.25 (è±å…æœŸæ¨¡å¼ï¼ˆäº¤æ˜“æ•¸:15/100ï¼‰)
âœ… äº¤æ˜“åŸ·è¡ŒæˆåŠŸ: BTCUSDT | å¤§å°: $6.25 | å‰©é¤˜: $56.20
ğŸ“ˆ äº¤æ˜“è¨˜éŒ„æ›´æ–°: ç¸½äº¤æ˜“=16, è±å…æœŸ=16/100
ğŸ‰ äº¤æ˜“é€±æœŸå®Œæˆ: 1ç­†äº¤æ˜“ | ç´¯è¨ˆäº¤æ˜“: 16/100
```

è±å…æœŸå®Œæˆæ™‚ï¼š

```
ğŸ‰ è±å…æœŸå®Œæˆ! ç´¯è¨ˆäº¤æ˜“: 100/100
ğŸ’° è³‡æœ¬ç‹€æ…‹æ›´æ–° | è³ªé‡é–€æª»: 0.60 (æ­£å¸¸æ¨¡å¼)
```

é€™å€‹ä¿®å¾©ç¢ºä¿ï¼š

1. âœ… äº¤æ˜“è¨ˆæ•¸å¯¦æ™‚æ›´æ–° - æ¯æ¬¡äº¤æ˜“å¾Œç«‹å³æ›´æ–°
2. âœ… æ•¸æ“šä¸€è‡´æ€§ - TradeRecorder å’Œ CapitalAllocator æ•¸æ“šåŒæ­¥
3. âœ… è‡ªå‹•è¨ºæ–· - å®šæœŸæª¢æŸ¥ä¸¦ä¿®å¾©æ•¸æ“šä¸ä¸€è‡´
4. âœ… æ­£ç¢ºçš„æ¨¡å¼åˆ‡æ› - 100ç­†äº¤æ˜“å¾Œè‡ªå‹•åˆ‡æ›åˆ°æ­£å¸¸æ¨¡å¼

äº¤æ˜“è¨ˆæ•¸ç¾åœ¨æœƒæ­£ç¢ºç´¯åŠ äº†ï¼