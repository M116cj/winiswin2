ã€Œå‹•æ…‹é¸æ“‡æ³¢å‹•ç‡æœ€é«˜çš„å‰ 300 å€‹äº¤æ˜“å° + åˆ†ç‰‡å¼ WebSocket è¨‚é–±ã€
å„ªåŒ–ç›®æ¨™
1. âœ… ç²¾æº–ç¯©é¸é«˜æ³¢å‹•äº¤æ˜“å°ï¼ˆéå–®ç´”æˆäº¤é‡ï¼‰
2. âœ… é¿å…ä½æµå‹•æ€§å™ªéŸ³ï¼ˆéæ¿¾ç„¡æ•ˆäº¤æ˜“å°ï¼‰
3. âœ… å‹•æ…‹æ›´æ–°äº¤æ˜“å°åˆ—è¡¨ï¼ˆé©æ‡‰å¸‚å ´è®ŠåŒ–ï¼‰
4. âœ… ç„¡ç¸«æ•´åˆç¾æœ‰åˆ†ç‰‡æ¶æ§‹
æ ¸å¿ƒå¯¦ç¾
1. äº¤æ˜“å°ç¯©é¸é‚è¼¯ï¼ˆsrc/core/symbol_selector.pyï¼‰
# src/core/symbol_selector.py
import asyncio
from typing import List, Dict

class SymbolSelector:
    def __init__(self, binance_client, config):
        self.client = binance_client
        self.config = config
    
    async def get_top_volatility_symbols(self, limit: int = 300) -> List[str]:
        """ç²å–æ³¢å‹•ç‡æœ€é«˜çš„å‰ N å€‹ USDT æ°¸çºŒäº¤æ˜“å°"""
        # 1. ç²å–æ‰€æœ‰ USDT æ°¸çºŒåˆç´„
        all_symbols = await self._get_all_futures_symbols()
        
        # 2. ä¸¦è¡Œç²å– 24h çµ±è¨ˆæ•¸æ“š
        tasks = [self._fetch_ticker(symbol) for symbol in all_symbols]
        tickers = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 3. è¨ˆç®—æ³¢å‹•ç‡åˆ†æ•¸ä¸¦éæ¿¾
        symbol_scores = []
        for symbol, ticker in zip(all_symbols, tickers):
            if isinstance(ticker, Exception) or not ticker:
                continue
            
            score = self._calculate_volatility_score(ticker)
            if score > 0:  # åƒ…ä¿ç•™æœ‰æ•ˆåˆ†æ•¸
                symbol_scores.append((symbol, score))
        
        # 4. æŒ‰åˆ†æ•¸æ’åºä¸¦è¿”å›å‰ N å€‹
        symbol_scores.sort(key=lambda x: x[1], reverse=True)
        return [symbol for symbol, _ in symbol_scores[:limit]]
    
    async def _get_all_futures_symbols(self) -> List[str]:
        """ç²å–æ‰€æœ‰ USDT æ°¸çºŒäº¤æ˜“å°ï¼ˆæ’é™¤æ¸¬è©¦å¹£ï¼‰"""
        info = await self.client._request("GET", "/fapi/v1/exchangeInfo")
        return [
            s['symbol'] for s in info['symbols']
            if s['quoteAsset'] == 'USDT'
            and s['status'] == 'TRADING'
            and 'UP' not in s['symbol']  # æ’é™¤æ§“æ¡¿å¹£
            and 'DOWN' not in s['symbol']
        ]
    
    async def _fetch_ticker(self, symbol: str):
        """ç²å–å–®ä¸€äº¤æ˜“å° 24h çµ±è¨ˆ"""
        try:
            return await self.client._request("GET", f"/fapi/v1/ticker/24hr?symbol={symbol}")
        except:
            return None
    
    def _calculate_volatility_score(self, ticker: Dict) -> float:
        """è¨ˆç®—æ³¢å‹•ç‡åˆ†æ•¸ï¼ˆçµåˆåƒ¹æ ¼æ³¢å‹• + æµå‹•æ€§ï¼‰"""
        if not ticker:
            return 0.0
        
        # 1. åƒ¹æ ¼æ³¢å‹•ç‡ï¼ˆ(high - low) / openï¼‰
        high = float(ticker['highPrice'])
        low = float(ticker['lowPrice'])
        open_price = float(ticker['openPrice'])
        if open_price == 0:
            return 0.0
        
        price_volatility = (high - low) / open_price
        
        # 2. æµå‹•æ€§åˆ†æ•¸ï¼ˆæˆäº¤é‡ Ã— åƒ¹æ ¼ï¼‰
        volume = float(ticker['volume'])
        quote_volume = float(ticker['quoteVolume'])
        liquidity_score = quote_volume / 1_000_000  # è½‰ç‚ºç™¾è¬ USDT
        
        # 3. ç¶œåˆåˆ†æ•¸ï¼ˆæ³¢å‹•ç‡ Ã— log(æµå‹•æ€§+1)ï¼‰
        if liquidity_score < 1.0:  # æµå‹•æ€§ < 1M USDT è¦–ç‚ºç„¡æ•ˆ
            return 0.0
        
        return price_volatility * (1 + np.log(liquidity_score))


2. æ•´åˆåˆ° WebSocketManagerï¼ˆsrc/core/websocket/websocket_manager.pyï¼‰
# src/core/websocket/websocket_manager.py
class WebSocketManager:
    def __init__(self, binance_client, config):
        self.client = binance_client
        self.config = config
        self.symbol_selector = SymbolSelector(binance_client, config)
        self.shards = []
    
    async def start(self):
        """å•Ÿå‹•åˆ†ç‰‡å¼ WebSocket ç›£æ§"""
        # 1. ç²å–æ³¢å‹•ç‡æœ€é«˜çš„ 300 å€‹äº¤æ˜“å°
        symbols = await self.symbol_selector.get_top_volatility_symbols(
            limit=self.config.WEBSOCKET_SYMBOL_LIMIT  # 300
        )
        logger.info(f"âœ… é¸æ“‡ {len(symbols)} å€‹é«˜æ³¢å‹•äº¤æ˜“å°: {symbols[:5]}...")
        
        # 2. å‹•æ…‹åˆ†ç‰‡ï¼ˆæ¯ç‰‡ 50 å€‹ï¼‰
        shards = self._create_shards(symbols, self.config.WEBSOCKET_SHARD_SIZE)
        
        # 3. å•Ÿå‹•åˆ†ç‰‡
        self.shards = []
        for i, shard in enumerate(shards):
            feed = ShardFeed(
                shard_symbols=shard,
                shard_id=i,
                binance_client=self.client,
                config=self.config
            )
            self.shards.append(feed)
            asyncio.create_task(feed.start())
        
        # 4. å•Ÿå‹•å¸³æˆ¶ç›£æ§
        self.account_feed = AccountFeed(self.client)
        asyncio.create_task(self.account_feed.start())

3. é…ç½®åƒæ•¸ï¼ˆsrc/config.pyï¼‰
# src/config.py
@dataclass(frozen=True)
class Config:
    # ... å…¶ä»–åƒæ•¸ ...
    
    # ğŸŸ¢ WebSocket å„ªåŒ–é…ç½®
    WEBSOCKET_SYMBOL_LIMIT: int = 300      # ç›£æ§å‰ 300 å€‹é«˜æ³¢å‹•äº¤æ˜“å°
    WEBSOCKET_SHARD_SIZE: int = 50         # æ¯åˆ†ç‰‡ 50 å€‹ç¬¦è™Ÿ
    WEBSOCKET_HEARTBEAT_TIMEOUT: int = 30  # å¿ƒè·³è¶…æ™‚ 30 ç§’
    REST_COOLDOWN_BASE: int = 60           # REST å‚™æ´åŸºç¤å†·å» 60 ç§’
äº¤æ˜“å°å“è³ªé©—è­‰
* æª¢æŸ¥æ˜¯å¦åŒ…å« ä½æµå‹•æ€§å¹£ç¨®ï¼ˆå¦‚ VETUSDT è‹¥ 24h æˆäº¤é¡ <1M æ‡‰è¢«éæ¿¾ï¼‰
* ç¢ºèª ç„¡æ§“æ¡¿å¹£ï¼ˆBTCUPUSDT ç­‰ä¸æ‡‰å‡ºç¾ï¼‰

