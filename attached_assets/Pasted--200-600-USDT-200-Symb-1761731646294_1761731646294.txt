流動性與波動性綜合評分最高的前 200 個」 的完整優化方案
目標
* 輸入：~600 個 USDT 永續合約
* 輸出：流動性 × 波動性 綜合分數最高的 前 200 個交易對
* 整合點：SymbolSelector 模塊（取代原「前 300 個波動率」邏輯）



🔧 核心修改
1. 更新 SymbolSelector 邏輯（src/core/symbol_selector.py）
# src/core/symbol_selector.py
class SymbolSelector:
    async def get_top_liquidity_volatility_symbols(self, limit: int = 200) -> List[str]:
        """獲取流動性×波動性綜合分數最高的前 N 個交易對"""
        all_symbols = await self._get_all_futures_symbols()
        
        # 並行獲取 24h 數據
        tasks = [self._fetch_ticker(symbol) for symbol in all_symbols]
        tickers = await asyncio.gather(*tasks, return_exceptions=True)
        
        symbol_scores = []
        for symbol, ticker in zip(all_symbols, tickers):
            if isinstance(ticker, Exception) or not ticker:
                continue
            
            # 計算綜合分數
            score = self._calculate_liquidity_volatility_score(ticker)
            if score > 0:
                symbol_scores.append((symbol, score))
        
        # 按分數排序並返回前 200
        symbol_scores.sort(key=lambda x: x[1], reverse=True)
        return [symbol for symbol, _ in symbol_scores[:limit]]

    def _calculate_liquidity_volatility_score(self, ticker: Dict) -> float:
        """綜合分數 = 流動性 × 波動率"""
        # 1. 流動性（24h 成交額，單位：百萬 USDT）
        quote_volume = float(ticker['quoteVolume'])
        liquidity = quote_volume / 1_000_000
        
        # 2. 波動率（(high - low) / open）
        high = float(ticker['highPrice'])
        low = float(ticker['lowPrice'])
        open_price = float(ticker['openPrice'])
        if open_price == 0:
            return 0.0
        volatility = (high - low) / open_price
        
        # 3. 綜合分數（流動性 × 波動率）
        score = liquidity * volatility
        
        # 4. 門檻過濾（流動性 < 1M 或 波動率 < 0.5% 視為無效）
        if liquidity < 1.0 or volatility < 0.005:
            return 0.0
        
        return score

2. 更新 WebSocketManager 調用（src/core/websocket/websocket_manager.py）

# src/core/websocket/websocket_manager.py
class WebSocketManager:
    async def start(self):
        # 修改：調用新方法（前 200 個）
        symbols = await self.symbol_selector.get_top_liquidity_volatility_symbols(
            limit=self.config.WEBSOCKET_SYMBOL_LIMIT  # 200
        )
        logger.info(f"✅ 選擇 {len(symbols)} 個高流動性+高波動交易對: {symbols[:5]}...")
        
        # ... [後續分片邏輯不變] ...

3. 更新配置參數（src/config.py）

# src/config.py
@dataclass(frozen=True)
class Config:
    # ... 其他參數 ...
    
    # 🟢 調整為前 200 個
    WEBSOCKET_SYMBOL_LIMIT: int = 200      # 前 200 個（非 300）
    WEBSOCKET_SHARD_SIZE: int = 50         # 每片 50 個 → 4 個分片

關鍵公式：
綜合分數 = (24h 成交額) × ((最高價 - 最低價) / 開盤價)
→ 同時捕捉 市場活躍度 與 價格波動機會

🚀 最終架構流程


BinanceClient → ✅ 正常連接
    ↓
DataService.load_all_symbols() → all_symbols = [~600個USDT永續合約]
    ↓
DataService.scan_market() → [可選：初步流動性過濾]
    ↓
SymbolSelector → **流動性×波動率綜合分數前200個**
    ↓
WebSocketManager → 訂閱200個高品質交易對（4分片×50）
    ↓
系統正常運行 ✅
