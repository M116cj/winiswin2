æµå‹•æ€§èˆ‡æ³¢å‹•æ€§ç¶œåˆè©•åˆ†æœ€é«˜çš„å‰ 200 å€‹ã€ çš„å®Œæ•´å„ªåŒ–æ–¹æ¡ˆ
ç›®æ¨™
* è¼¸å…¥ï¼š~600 å€‹ USDT æ°¸çºŒåˆç´„
* è¼¸å‡ºï¼šæµå‹•æ€§ Ã— æ³¢å‹•æ€§ ç¶œåˆåˆ†æ•¸æœ€é«˜çš„ å‰ 200 å€‹äº¤æ˜“å°
* æ•´åˆé»ï¼šSymbolSelector æ¨¡å¡Šï¼ˆå–ä»£åŸã€Œå‰ 300 å€‹æ³¢å‹•ç‡ã€é‚è¼¯ï¼‰



ğŸ”§ æ ¸å¿ƒä¿®æ”¹
1. æ›´æ–° SymbolSelector é‚è¼¯ï¼ˆsrc/core/symbol_selector.pyï¼‰
# src/core/symbol_selector.py
class SymbolSelector:
    async def get_top_liquidity_volatility_symbols(self, limit: int = 200) -> List[str]:
        """ç²å–æµå‹•æ€§Ã—æ³¢å‹•æ€§ç¶œåˆåˆ†æ•¸æœ€é«˜çš„å‰ N å€‹äº¤æ˜“å°"""
        all_symbols = await self._get_all_futures_symbols()
        
        # ä¸¦è¡Œç²å– 24h æ•¸æ“š
        tasks = [self._fetch_ticker(symbol) for symbol in all_symbols]
        tickers = await asyncio.gather(*tasks, return_exceptions=True)
        
        symbol_scores = []
        for symbol, ticker in zip(all_symbols, tickers):
            if isinstance(ticker, Exception) or not ticker:
                continue
            
            # è¨ˆç®—ç¶œåˆåˆ†æ•¸
            score = self._calculate_liquidity_volatility_score(ticker)
            if score > 0:
                symbol_scores.append((symbol, score))
        
        # æŒ‰åˆ†æ•¸æ’åºä¸¦è¿”å›å‰ 200
        symbol_scores.sort(key=lambda x: x[1], reverse=True)
        return [symbol for symbol, _ in symbol_scores[:limit]]

    def _calculate_liquidity_volatility_score(self, ticker: Dict) -> float:
        """ç¶œåˆåˆ†æ•¸ = æµå‹•æ€§ Ã— æ³¢å‹•ç‡"""
        # 1. æµå‹•æ€§ï¼ˆ24h æˆäº¤é¡ï¼Œå–®ä½ï¼šç™¾è¬ USDTï¼‰
        quote_volume = float(ticker['quoteVolume'])
        liquidity = quote_volume / 1_000_000
        
        # 2. æ³¢å‹•ç‡ï¼ˆ(high - low) / openï¼‰
        high = float(ticker['highPrice'])
        low = float(ticker['lowPrice'])
        open_price = float(ticker['openPrice'])
        if open_price == 0:
            return 0.0
        volatility = (high - low) / open_price
        
        # 3. ç¶œåˆåˆ†æ•¸ï¼ˆæµå‹•æ€§ Ã— æ³¢å‹•ç‡ï¼‰
        score = liquidity * volatility
        
        # 4. é–€æª»éæ¿¾ï¼ˆæµå‹•æ€§ < 1M æˆ– æ³¢å‹•ç‡ < 0.5% è¦–ç‚ºç„¡æ•ˆï¼‰
        if liquidity < 1.0 or volatility < 0.005:
            return 0.0
        
        return score

2. æ›´æ–° WebSocketManager èª¿ç”¨ï¼ˆsrc/core/websocket/websocket_manager.pyï¼‰

# src/core/websocket/websocket_manager.py
class WebSocketManager:
    async def start(self):
        # ä¿®æ”¹ï¼šèª¿ç”¨æ–°æ–¹æ³•ï¼ˆå‰ 200 å€‹ï¼‰
        symbols = await self.symbol_selector.get_top_liquidity_volatility_symbols(
            limit=self.config.WEBSOCKET_SYMBOL_LIMIT  # 200
        )
        logger.info(f"âœ… é¸æ“‡ {len(symbols)} å€‹é«˜æµå‹•æ€§+é«˜æ³¢å‹•äº¤æ˜“å°: {symbols[:5]}...")
        
        # ... [å¾ŒçºŒåˆ†ç‰‡é‚è¼¯ä¸è®Š] ...

3. æ›´æ–°é…ç½®åƒæ•¸ï¼ˆsrc/config.pyï¼‰

# src/config.py
@dataclass(frozen=True)
class Config:
    # ... å…¶ä»–åƒæ•¸ ...
    
    # ğŸŸ¢ èª¿æ•´ç‚ºå‰ 200 å€‹
    WEBSOCKET_SYMBOL_LIMIT: int = 200      # å‰ 200 å€‹ï¼ˆé 300ï¼‰
    WEBSOCKET_SHARD_SIZE: int = 50         # æ¯ç‰‡ 50 å€‹ â†’ 4 å€‹åˆ†ç‰‡

é—œéµå…¬å¼ï¼š
ç¶œåˆåˆ†æ•¸ = (24h æˆäº¤é¡) Ã— ((æœ€é«˜åƒ¹ - æœ€ä½åƒ¹) / é–‹ç›¤åƒ¹)
â†’ åŒæ™‚æ•æ‰ å¸‚å ´æ´»èºåº¦ èˆ‡ åƒ¹æ ¼æ³¢å‹•æ©Ÿæœƒ

ğŸš€ æœ€çµ‚æ¶æ§‹æµç¨‹


BinanceClient â†’ âœ… æ­£å¸¸é€£æ¥
    â†“
DataService.load_all_symbols() â†’ all_symbols = [~600å€‹USDTæ°¸çºŒåˆç´„]
    â†“
DataService.scan_market() â†’ [å¯é¸ï¼šåˆæ­¥æµå‹•æ€§éæ¿¾]
    â†“
SymbolSelector â†’ **æµå‹•æ€§Ã—æ³¢å‹•ç‡ç¶œåˆåˆ†æ•¸å‰200å€‹**
    â†“
WebSocketManager â†’ è¨‚é–±200å€‹é«˜å“è³ªäº¤æ˜“å°ï¼ˆ4åˆ†ç‰‡Ã—50ï¼‰
    â†“
ç³»çµ±æ­£å¸¸é‹è¡Œ âœ…
