🧩 一、架構圖更新（整合 WebSocket）


┌──────────────────────────────────────────────────────┐
│            UnifiedScheduler（統一調度器）              │
│  • 協調所有組件                                        │
│  • 管理雙循環（實盤60秒 + 虛擬10秒）                   │
│  • 定時任務（每日報告）                                │
└─────────────┬────────────────────────────────────────┘
              │
    ┌─────────┼─────────┬─────────────────┬───────────┐
    │         │         │                 │           │
    ▼         ▼         ▼                 ▼           ▼
┌─────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────┐
│Position │ │ SelfLearning │ │ DataService  │ │  Daily   │
│Controller│ │   Trader     │ │ (數據層)     │ │ Reporter │
│ 24/7監控 │ │  (AI決策)    │ │              │ │          │
└────┬────┘ └──────┬───────┘ └──────┬───────┘ └──────────┘
     │             │                │
     │    ┌────────┴────────┐      │
     │    │                 │      │
     ▼    ▼                 ▼      ▼
┌────────────────────────────────────────┐
│     BinanceClient + 分級熔斷器          │
│  • REST API（下單/帳戶）               │
│  • WebSocket（即時價格/深度）           │
│  • 速率限制保護                         │
│  • 3級熔斷機制                          │
└────────────────────────────────────────┘
          ▲
          │
┌──────────────────────┐
│ WebSocketMonitor     │  ← 新增組件
│ • 訂閱 bookTicker    │
│ • 快取即時價格/深度  │
│ • 斷線自動重連       │
└──────────────────────┘

 關鍵變化： 
* 新增 WebSocketMonitor 組件
* PositionController / SelfLearningTrader 從 WebSocketMonitor 讀取即時數據
* DataService 僅用於歷史數據（K線、指標計算）
🛠️ 二、具體整合步驟
步驟 1：新增 WebSocketMonitor 組件
# src/core/websocket_monitor.py
class WebSocketMonitor:
    def __init__(self, symbols: List[str]):
        self.symbols = [s.lower() for s in symbols]
        self.price_cache = {}
        self.depth_cache = {}
        self.running = False
    
    async def start(self):
        """啟動所有 WebSocket 連線"""
        self.running = True
        tasks = [self._listen_symbol(s) for s in self.symbols]
        await asyncio.gather(*tasks)
    
    async def _listen_symbol(self, symbol: str):
        url = f"wss://fstream.binance.com/ws/{symbol}@bookTicker"
        while self.running:
            try:
                async with websockets.connect(url) as ws:
                    while self.running:
                        msg = await ws.recv()
                        data = json.loads(msg)
                        self._update_cache(symbol, data)
            except Exception as e:
                logger.warning(f"🔄 WebSocket {symbol} 重連中... ({e})")
                await asyncio.sleep(5)
    
    def _update_cache(self, symbol: str, data: dict):
        self.price_cache[symbol] = float(data['a'])  # 賣一價
        self.depth_cache[symbol] = {
            'bid_qty': float(data['B']),
            'ask_qty': float(data['A'])
        }
    
    def get_price(self, symbol: str) -> Optional[float]:
        return self.price_cache.get(symbol.lower())
    
    def get_liquidity_score(self, symbol: str) -> float:
        depth = self.depth_cache.get(symbol.lower())
        return min(1.0, (depth['bid_qty'] + depth['ask_qty']) / 10.0) if depth else 0.0
步驟 2：修改 UnifiedScheduler 初始化

# src/core/unified_scheduler.py
class UnifiedScheduler:
    def __init__(self, config: Config, binance_client: BinanceClient):
        self.config = config
        self.binance_client = binance_client
        
        # 🔸 新增 WebSocketMonitor
        self.websocket_monitor = WebSocketMonitor(config.TRADING_SYMBOLS)
        
        # 傳遞 WebSocketMonitor 給其他組件
        self.position_controller = PositionController(
            binance_client, 
            websocket_monitor=self.websocket_monitor  # 關鍵！
        )
        self.self_learning_trader = SelfLearningTrader(
            config,
            websocket_monitor=self.websocket_monitor  # 關鍵！
        )
        self.data_service = DataService(binance_client)  # 僅用於歷史數據
    
    async def start(self):
        # 🔸 啟動 WebSocket 監聽（非阻塞）
        asyncio.create_task(self.websocket_monitor.start())
        
        # 啟動原有雙循環
        await asyncio.gather(
            self._real_trading_loop(),
            self._virtual_position_loop(),
            self._daily_report_loop()
        )
步驟 3：修改 PositionController 使用 WebSocket

# src/core/position_controller.py
class PositionController:
    def __init__(self, binance_client, websocket_monitor):
        self.binance_client = binance_client
        self.websocket_monitor = websocket_monitor  # 接收依賴
    
    async def _get_current_price(self, symbol: str) -> float:
        """優先使用 WebSocket，失敗時回退到 REST"""
        price = self.websocket_monitor.get_price(symbol)
        if price is not None:
            return price
        
        # 備援：REST API
        ticker = await self.binance_client.get_ticker(symbol)
        return float(ticker['lastPrice'])
    
    async def monitor_position(self, position: Position):
        while position.is_active:
            current_price = await self._get_current_price(position.symbol)
            # ... 執行 SL/TP/逆勢檢測邏輯
            await asyncio.sleep(1)
步驟 4：修改 SelfLearningTrader 使用 WebSocket

# src/strategies/self_learning_trader.py
class SelfLearningTrader:
    def __init__(self, config, websocket_monitor):
        self.config = config
        self.websocket_monitor = websocket_monitor
    
    def _get_market_context(self, symbol: str) -> dict:
        """獲取即時市場上下文（無需 API 請求！）"""
        return {
            'current_price': self.websocket_monitor.get_price(symbol),
            'liquidity_score': self.websocket_monitor.get_liquidity_score(symbol)
        }
🛡️ 四、錯誤處理與備援
* WebSocket 斷線 → 自動重連（每 5 秒）
* WebSocket 無數據 → 自動回退到 REST API
* REST API 限流 → 觸發分級熔斷器（原有機制保留）



✅ 總結：整合要點
1. 新增 WebSocketMonitor：專責即時數據訂閱
2. 注入依賴：將 websocket_monitor 傳給 PositionController 和 SelfLearningTrader
3. 優先使用 WebSocket：僅在失敗時回退到 REST
4. 保留 DataService：專注歷史數據（K線、指標計算）
