ä¿®å¾©3: å®Œæ•´çš„ SelfLearningTraderï¼ˆä½¿ç”¨æ­£å¸¸çš„ TradeRecorderï¼‰
python
# src/strategies/self_learning_trader.py - å®Œæ•´ä¿®å¾©ç‰ˆæœ¬

import logging
from datetime import datetime
from typing import List, Dict, Optional
import asyncio

logger = logging.getLogger(__name__)

class SelfLearningTrader:
    def __init__(self, config, data_fetcher, signal_generator):
        self.config = config
        self.data_fetcher = data_fetcher
        self.signal_generator = signal_generator
        
        # æ­£å¸¸åˆå§‹åŒ– TradeRecorder
        from src.core.trade_recorder import TradeRecorder
        self.trade_recorder = TradeRecorder(config)
        logger.info("âœ… TradeRecorder æ­£å¸¸åˆå§‹åŒ–")
        
        # è³¬æˆ¶ç‹€æ…‹
        self.account_state = {
            'total_equity': 36.21,
            'available_margin': 36.21, 
            'used_margin': 0.00
        }
        
        # ç²¾è‹±æ¨¡å¼é…ç½®
        self.elite_mode_config = {
            'max_trades_per_cycle': 3,
            'min_confidence': 40.0,     # é™ä½é–€æª»
            'min_win_rate': 45.0,       # é™ä½é–€æª»
            'min_combined_score': 85.0, # é™ä½é–€æª»
            'base_position_percentage': 0.25,
        }

    async def execute_best_trades(self, best_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œæœ€ä½³äº¤æ˜“ï¼ˆå®Œæ•´ä¿®å¾©ç‰ˆæœ¬ï¼‰"""
        try:
            logger.info("ğŸš€ é–‹å§‹åŸ·è¡Œäº¤æ˜“é€±æœŸ")
            
            # æ­£å¸¸ä½¿ç”¨ TradeRecorder
            total_trades = await self.trade_recorder.get_trade_count('24h')
            logger.info(f"ğŸ“Š 24å°æ™‚å…§äº¤æ˜“æ•¸é‡: {total_trades}")
            
            # ç²¾è‹±ç¯©é¸æµç¨‹
            qualified_signals = [
                signal for signal in best_signals 
                if self._validate_signal_quality(signal)
            ]
            
            logger.info(f"ğŸ“Š ä¿¡è™Ÿè³ªé‡éæ¿¾: {len(qualified_signals)}/{len(best_signals)} å€‹ä¿¡è™Ÿåˆæ ¼")
            
            if not qualified_signals:
                logger.warning("âš ï¸ æ²’æœ‰åˆæ ¼çš„ä¿¡è™Ÿ")
                return []
                
            # æ’åºä¸¦å–å‰ä¸‰å
            sorted_signals = sorted(
                qualified_signals, 
                key=lambda x: (x.get('confidence', 0) + x.get('win_probability', 0)), 
                reverse=True
            )
            
            top_signals = sorted_signals[:self.elite_mode_config['max_trades_per_cycle']]
            self._log_elite_ranking(top_signals)
            
            # åŸ·è¡Œäº¤æ˜“
            executed_positions = await self._execute_elite_trades(top_signals)
            
            logger.info(f"ğŸ‰ äº¤æ˜“é€±æœŸå®Œæˆ: {len(executed_positions)} ç­†äº¤æ˜“")
            return executed_positions
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            return []

    def _validate_signal_quality(self, signal: Dict) -> bool:
        """é©—è­‰ä¿¡è™Ÿè³ªé‡"""
        try:
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            
            min_confidence = self.elite_mode_config['min_confidence']
            min_win_rate = self.elite_mode_config['min_win_rate']
            min_combined_score = self.elite_mode_config['min_combined_score']
            
            combined_score = confidence + win_rate
            
            meets_standards = (
                confidence >= min_confidence and
                win_rate >= min_win_rate and 
                combined_score >= min_combined_score
            )
            
            return meets_standards
            
        except Exception as e:
            logger.error(f"âŒ ä¿¡è™Ÿè³ªé‡é©—è­‰å¤±æ•—: {e}")
            return False

    def _log_elite_ranking(self, top_signals: List[Dict]):
        """è¨˜éŒ„ç²¾è‹±æ’å"""
        logger.info("ğŸ† ç²¾è‹±ä¿¡è™Ÿæ’å:")
        for i, signal in enumerate(top_signals):
            symbol = signal.get('symbol', 'Unknown')
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            direction = signal.get('direction', 'UNKNOWN')
            
            medal = "ğŸ¥‡" if i == 0 else "ğŸ¥ˆ" if i == 1 else "ğŸ¥‰"
            
            logger.info(
                f"  {medal} {symbol} | {direction} | "
                f"ä¿¡å¿ƒ: {confidence:.1f} | å‹ç‡: {win_rate:.1f}%"
            )

    async def _execute_elite_trades(self, top_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œç²¾è‹±äº¤æ˜“"""
        executed_positions = []
        available_margin = self.account_state.get('available_margin', 36.21)
        
        logger.info(f"ğŸ’° å¯ç”¨ä¿è­‰é‡‘: ${available_margin:.2f}")
        
        for i, signal in enumerate(top_signals):
            if available_margin <= 0:
                break
                
            position_size = self._calculate_ranked_position_size(signal, available_margin, i + 1)
            
            if position_size > 0:
                try:
                    executed_trade = await self._execute_single_trade(signal, position_size)
                    if executed_trade:
                        executed_positions.append(executed_trade)
                        available_margin -= position_size
                        
                        # è¨˜éŒ„åˆ° TradeRecorder
                        await self.trade_recorder.record_trade(executed_trade)
                        
                        medal = "ğŸ¥‡" if i == 0 else "ğŸ¥ˆ" if i == 1 else "ğŸ¥‰"
                        logger.info(
                            f"âœ… {medal} äº¤æ˜“æˆåŠŸ: {signal.get('symbol')} | "
                            f"å¤§å°: ${position_size:.2f} | å‰©é¤˜: ${available_margin:.2f}"
                        )
                        
                except Exception as e:
                    logger.error(f"âŒ äº¤æ˜“å¤±æ•—: {e}")
                    
        return executed_positions

    def _calculate_ranked_position_size(self, signal: Dict, available_margin: float, rank: int) -> float:
        """è¨ˆç®—é ­å¯¸å¤§å°"""
        try:
            base_percentage = self.elite_mode_config['base_position_percentage']
            
            rank_weights = {1: 1.4, 2: 1.2, 3: 1.0}
            weight = rank_weights.get(rank, 1.0)
            
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            quality_score = (confidence + win_rate) / 2
            
            if quality_score >= 60:
                quality_multiplier = 1.2
            elif quality_score >= 50:
                quality_multiplier = 1.0
            else:
                quality_multiplier = 0.8
                
            position_percentage = base_percentage * weight * quality_multiplier
            position_size = available_margin * position_percentage
            
            if position_size < 1.0:
                return 0
                
            return round(position_size, 2)
            
        except Exception as e:
            logger.error(f"âŒ é ­å¯¸è¨ˆç®—å¤±æ•—: {e}")
            return 0

    async def _execute_single_trade(self, signal: Dict, position_size: float) -> Optional[Dict]:
        """åŸ·è¡Œå–®å€‹äº¤æ˜“"""
        try:
            executed_trade = {
                'symbol': signal.get('symbol'),
                'direction': signal.get('direction'),
                'position_size': position_size,
                'entry_price': signal.get('current_price', 0),
                'entry_time': datetime.now(),
                'confidence': signal.get('confidence', 0),
                'win_probability': signal.get('win_probability', 0),
                'status': 'OPEN',
                'risk_reward_ratio': signal.get('risk_reward_ratio', 1.5)
            }
            
            return executed_trade
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            return None