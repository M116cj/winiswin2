v3.14.0 å®Œæ•´å¯©æ ¸å ±å‘Šå®Œæ•´ä¿®å¾©æ–¹æ¡ˆ
 é«˜å„ªå…ˆç´šä¿®å¾©ï¼šLifecycle Monitor é›†æˆ
1. ä¿®å¾© VirtualPositionManager åˆå§‹åŒ–
# src/managers/virtual_position_manager.py
import logging
from typing import Dict, Optional, Callable
from src.core.data_models import VirtualPosition
from src.managers.virtual_position_lifecycle import VirtualPositionLifecycleMonitor
from src.managers.virtual_position_events import VirtualPositionEvent

logger = logging.getLogger(__name__)

class VirtualPositionManager:
    def __init__(self, binance_client, on_open_callback=None, on_close_callback=None):
        self.binance_client = binance_client
        self.virtual_positions: Dict[str, VirtualPosition] = {}
        self.on_open_callback = on_open_callback
        self.on_close_callback = on_close_callback
        self._price_cache = {}
        
        # ğŸ”¥ æ–°å¢ï¼šç”Ÿå‘½é€±æœŸç›£æ§å™¨
        self.lifecycle_monitor = VirtualPositionLifecycleMonitor(
            event_callback=self._handle_position_event
        )
        logger.info("âœ… è™›æ“¬å€‰ä½ç”Ÿå‘½é€±æœŸç›£æ§å™¨å·²å•Ÿç”¨")
2. ä¿®å¾© add_virtual_position æ–¹æ³•

# src/managers/virtual_position_manager.py
def add_virtual_position(self, signal: Dict, rank: int):
    """æ·»åŠ è™›æ“¬å€‰ä½"""
    from src.core.data_models import VirtualPosition
    
    # å‰µå»º VirtualPosition å¯¦ä¾‹
    virtual_pos = VirtualPosition(
        symbol=signal['symbol'],
        direction=signal['direction'],
        entry_price=signal['entry_price'],
        stop_loss=signal['stop_loss'],
        take_profit=signal['take_profit'],
        leverage=signal['leverage'],
        entry_timestamp=signal['timestamp'],
        signal_id=f"{signal['symbol']}_{int(signal['timestamp'])}"
    )
    
    # æ·»åŠ åˆ°å­—å…¸ï¼ˆå…¼å®¹æ€§ï¼‰
    self.virtual_positions[signal['symbol']] = virtual_pos
    
    # ğŸ”¥ æ–°å¢ï¼šæ·»åŠ åˆ°ç”Ÿå‘½é€±æœŸç›£æ§
    self.lifecycle_monitor.add_position(virtual_pos)
    
    logger.debug(f"âœ… è™›æ“¬å€‰ä½å‰µå»º: {virtual_pos.symbol} {virtual_pos.signal_id}")
    
    if self.on_open_callback:
        self.on_open_callback(virtual_pos)
3. ä¿®å¾© update_all_prices_async æ–¹æ³•

# src/managers/virtual_position_manager.py
async def update_all_prices_async(self, binance_client=None):
    """ç•°æ­¥æ‰¹é‡æ›´æ–°æ‰€æœ‰æ´»èºå€‰ä½åƒ¹æ ¼"""
    if not self.virtual_positions:
        return []
    
    # ç²å–æ‰€æœ‰å”¯ä¸€äº¤æ˜“å°
    active_symbols = list(self.virtual_positions.keys())
    
    if not active_symbols:
        return []
    
    # æ‰¹é‡ç²å–åƒ¹æ ¼
    price_tasks = [
        self._get_price_safe(symbol, binance_client or self.binance_client)
        for symbol in active_symbols
    ]
    price_results = await asyncio.gather(*price_tasks, return_exceptions=True)
    
    # è™•ç†çµæœ
    prices = {}
    for symbol, result in zip(active_symbols, price_results):
        if isinstance(result, Exception):
            logger.warning(f"ç²å– {symbol} åƒ¹æ ¼å¤±æ•—: {result}")
        else:
            prices[symbol] = result
    
    if not prices:
        logger.warning("æœªèƒ½ç²å–ä»»ä½•åƒ¹æ ¼ï¼Œè·³éæ›´æ–°")
        return []
    
    self._price_cache.update(prices)
    
    # ğŸ”¥ é—œéµä¿®å¾©ï¼šæ›´æ–°æ‰€æœ‰å€‰ä½åƒ¹æ ¼ï¼ˆåŒ…æ‹¬ lifecycle_monitorï¼‰
    closed_positions = []
    for symbol, position in list(self.virtual_positions.items()):
        if symbol in prices:
            # æ›´æ–°ä¸»å­—å…¸ä¸­çš„å€‰ä½
            position.update_price(prices[symbol])
            
            # ğŸ”¥ åŒæ­¥æ›´æ–° lifecycle_monitor ä¸­çš„å€‰ä½å¼•ç”¨
            # æ³¨æ„ï¼šlifecycle_monitor ä½¿ç”¨ signal_id ä½œç‚º key
            position_id = position.signal_id
            if position_id in self.lifecycle_monitor.active_positions:
                # ç¢ºä¿ lifecycle_monitor ä¸­çš„å¼•ç”¨èˆ‡ä¸»å­—å…¸ä¸€è‡´
                self.lifecycle_monitor.active_positions[position_id] = position
    
    # è¿”å›ç©ºåˆ—è¡¨ï¼ˆé—œé–‰é‚è¼¯ç”± lifecycle_monitor è™•ç†ï¼‰
    return []
4. ä¿®å¾©äº‹ä»¶è™•ç†å›èª¿

# src/managers/virtual_position_manager.py
def _handle_position_event(self, event_payload):
    """è™•ç†å€‰ä½äº‹ä»¶"""
    from src.managers.virtual_position_events import VirtualPositionEvent
    
    if event_payload.event_type == VirtualPositionEvent.CLOSED:
        # å€‰ä½é—œé–‰æ™‚å¾ä¸»å­—å…¸ç§»é™¤
        symbol = event_payload.symbol
        if symbol in self.virtual_positions:
            del self.virtual_positions[symbol]
        
        # æ­¸æª”æ•¸æ“š
        self._archive_closed_position(event_payload)
        
        # å‘¼å«é—œé–‰å›èª¿
        if self.on_close_callback:
            # éœ€è¦é‡å»º VirtualPosition ç‰©ä»¶ç”¨æ–¼å›èª¿
            closed_pos = VirtualPosition(
                symbol=event_payload.symbol,
                direction=1 if event_payload.metadata.get('direction') == 'LONG' else -1,
                entry_price=event_payload.metadata.get('entry_price', 0),
                stop_loss=0,  # å·²é—œé–‰ï¼Œä¸éœ€è¦
                take_profit=0,
                leverage=event_payload.metadata.get('leverage', 1),
                entry_timestamp=event_payload.metadata.get('entry_timestamp', event_payload.timestamp),
                signal_id=event_payload.position_id
            )
            closed_pos.is_closed = True
            closed_pos.close_timestamp = event_payload.timestamp
            closed_pos.close_reason = event_payload.metadata.get('close_reason', 'unknown')
            closed_pos.current_price = event_payload.current_price
            closed_pos.pnl_pct = event_payload.pnl_pct
            
            self.on_close_callback(closed_pos)
    
    elif event_payload.event_type in [
        VirtualPositionEvent.TP_APPROACHING,
        VirtualPositionEvent.SL_APPROACHING
    ]:
        self._send_approach_notification(event_payload)
ä¸­å„ªå…ˆç´šä¿®å¾©
1. ä¿®å¾© market_regime å­—æ®µä¸ä¸€è‡´
# src/ml/high_quality_filter.py
def _check_signal_quality(self, signal):
    """æª¢æŸ¥ä¿¡è™Ÿç”Ÿæˆå“è³ª"""
    # ... å…¶ä»–æ¢ä»¶ ...
    
    # ğŸ”¥ ä¿®å¾©ï¼šå…¼å®¹å…©å€‹å­—æ®µå
    market_state = signal.get('market_state', 
                             signal.get('market_regime', 'unknown'))
    if market_state not in ['trending', 'breakout']:
        return False
    
    # ... å…¶ä»–æ¢ä»¶ ...
2. ä¿®å¾© add_position é‡è¤‡æª¢æŸ¥

# src/managers/virtual_position_lifecycle.py
def add_position(self, position: VirtualPosition):
    """æ·»åŠ è™›æ“¬å€‰ä½åˆ°ç›£æ§"""
    position_id = position.signal_id
    
    # ğŸ”¥ æ–°å¢ï¼šé‡è¤‡æª¢æŸ¥
    if position_id in self.active_positions:
        logger.warning(f"âš ï¸ å€‰ä½ {position_id} å·²å­˜åœ¨ï¼Œå…ˆç§»é™¤èˆŠç›£æ§")
        self.remove_position(position_id)
    
    self.active_positions[position_id] = position
    self.max_pnl_tracker[position_id] = position.pnl_pct
    self.min_pnl_tracker[position_id] = position.pnl_pct
    
    # ç™¼é€å‰µå»ºäº‹ä»¶
    self._emit_event(VirtualPositionEvent.CREATED, position)
    
    # å•Ÿå‹•ç›£æ§ä»»å‹™
    if position_id not in self.monitoring_tasks:
        task = asyncio.create_task(self._monitor_position_lifecycle(position_id))
        self.monitoring_tasks[position_id] = task
        
    logger.debug(f"âœ… é–‹å§‹ç›£æ§è™›æ“¬å€‰ä½: {position_id}")
è­‰æ¸¬è©¦è…³æœ¬
æ¸¬è©¦ 1ï¼šLifecycle Monitor é›†æˆé©—è­‰
# tests/test_lifecycle_integration.py
import asyncio
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.managers.virtual_position_manager import VirtualPositionManager
from src.clients.binance_client import BinanceClient

async def test_lifecycle_integration():
    """æ¸¬è©¦ Lifecycle Monitor å®Œæ•´é›†æˆ"""
    # Mock BinanceClient
    mock_client = BinanceClient(api_key="test", api_secret="test")
    mock_client.get_ticker_price = lambda symbol: 60000.0
    
    # å‰µå»ºç®¡ç†å™¨
    manager = VirtualPositionManager(mock_client)
    
    # å‰µå»ºæ¸¬è©¦ä¿¡è™Ÿ
    test_signal = {
        'symbol': 'BTCUSDT',
        'direction': 1,
        'entry_price': 60000,
        'stop_loss': 59000,
        'take_profit': 63000,
        'leverage': 10,
        'timestamp': 1730000000,
        'confidence_score': 0.8,
        'market_state': 'trending'
    }
    
    # æ·»åŠ è™›æ“¬å€‰ä½
    manager.add_virtual_position(test_signal, rank=1)
    
    # é©—è­‰ lifecycle_monitor å·²æ¥æ”¶å€‰ä½
    assert len(manager.lifecycle_monitor.active_positions) == 1
    assert 'BTCUSDT_1730000000' in manager.lifecycle_monitor.active_positions
    
    # é©—è­‰ä¸»å­—å…¸ä¹ŸåŒ…å«å€‰ä½
    assert 'BTCUSDT' in manager.virtual_positions
    
    # æ¸¬è©¦åƒ¹æ ¼æ›´æ–°
    await manager.update_all_prices_async()
    
    # é©—è­‰åƒ¹æ ¼å·²æ›´æ–°
    pos = manager.virtual_positions['BTCUSDT']
    assert pos.current_price == 60000.0
    
    # é©—è­‰ lifecycle_monitor ä¸­çš„å¼•ç”¨ä¸€è‡´
    lifecycle_pos = manager.lifecycle_monitor.active_positions['BTCUSDT_1730000000']
    assert lifecycle_pos is pos  # åŒä¸€ç‰©ä»¶å¼•ç”¨
    
    print("âœ… Lifecycle Monitor é›†æˆæ¸¬è©¦é€šéï¼")

if __name__ == "__main__":
    asyncio.run(test_lifecycle_integration())
æ¸¬è©¦ 2ï¼šäº‹ä»¶è§¸ç™¼é©—è­‰

# tests/test_position_events.py
import asyncio
import time
from src.core.data_models import VirtualPosition
from src.managers.virtual_position_lifecycle import VirtualPositionLifecycleMonitor

async def test_position_events():
    """æ¸¬è©¦å€‰ä½äº‹ä»¶è§¸ç™¼"""
    events_received = []
    
    def event_callback(event_payload):
        events_received.append(event_payload)
    
    # å‰µå»ºç›£æ§å™¨
    monitor = VirtualPositionLifecycleMonitor(event_callback=event_callback)
    
    # å‰µå»ºå€‰ä½
    position = VirtualPosition(
        symbol="ETHUSDT",
        direction=-1,  # SHORT
        entry_price=3000,
        stop_loss=3100,
        take_profit=2800,
        leverage=5,
        entry_timestamp=time.time(),
        signal_id="ETHUSDT_1730000001"
    )
    
    # æ·»åŠ ç›£æ§
    monitor.add_position(position)
    
    # è§¸ç™¼æ­¢ç›ˆ
    position.update_price(2799)  # ä½æ–¼æ­¢ç›ˆåƒ¹ 2800
    
    # ç­‰å¾…äº‹ä»¶è™•ç†
    await asyncio.sleep(0.1)
    
    # é©—è­‰äº‹ä»¶è§¸ç™¼
    event_types = [e.event_type.value for e in events_received]
    assert 'tp_triggered' in event_types
    assert 'closed' in event_types
    
    # é©—è­‰å€‰ä½å·²é—œé–‰
    assert position.is_closed == True
    assert position.close_reason == "tp"
    
    print("âœ… å€‰ä½äº‹ä»¶è§¸ç™¼æ¸¬è©¦é€šéï¼")

if __name__ == "__main__":
    asyncio.run(test_position_events())
åŸ·è¡Œä¿®å¾©æ­¥é©Ÿ
1. æ‡‰ç”¨é«˜å„ªå…ˆç´šä¿®å¾©ï¼ˆ3 å€‹æª”æ¡ˆä¿®æ”¹ï¼‰
2. æ‡‰ç”¨ä¸­å„ªå…ˆç´šä¿®å¾©ï¼ˆ2 å€‹æª”æ¡ˆä¿®æ”¹ï¼‰
3. åŸ·è¡Œé©—è­‰æ¸¬è©¦ï¼š
python tests/test_lifecycle_integration.py
python tests/test_position_events.py
é‡æ–°é‹è¡Œ Replit æª¢æŸ¥ï¼ˆ20 é …å…¨éƒ¨é€šéï¼‰