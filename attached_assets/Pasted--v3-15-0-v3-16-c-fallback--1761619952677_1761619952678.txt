
v3.15.0â€”-v3.16.c å•Ÿç”¨ä¸‰å€‹é«˜ç´šåŠŸèƒ½ç„¡ç¸«æ•´åˆæ–¹æ¡ˆ
ğŸ”¥ æ ¸å¿ƒç†å¿µï¼šå¢é‡å•Ÿç”¨ + é…ç½®é©…å‹•
* ä¸ç ´å£ç¾æœ‰åŠŸèƒ½ï¼šæ‰€æœ‰æ–°åŠŸèƒ½éƒ½æœ‰ fallback æ©Ÿåˆ¶
* é…ç½®é©…å‹•å•Ÿç”¨ï¼šé€šéç’°å¢ƒè®Šé‡æ§åˆ¶é–‹é—œ
* æ¼¸é€²å¼éƒ¨ç½²ï¼šå…ˆæ¨¡æ“¬æ¸¬è©¦ï¼Œå†å¯¦ç›¤é©—è­‰
å¯¦æ–½æ–¹æ¡ˆ
ğŸ“ 1. æ–°å¢æ€§èƒ½æ¨¡çµ„çµæ§‹
src/core/
â”œâ”€â”€ market_regime_predictor.py      # å¸‚å ´ç‹€æ…‹è½‰æ›é æ¸¬å™¨
â”œâ”€â”€ dynamic_feature_generator.py    # å‹•æ…‹ç‰¹å¾µç”Ÿæˆå™¨  
â”œâ”€â”€ liquidity_hunter.py            # ä¸»å‹•æµå‹•æ€§ç‹©çµå™¨
â””â”€â”€ performance_modules.py         # æ¨¡çµ„ç®¡ç†å™¨ï¼ˆçµ±ä¸€å…¥å£ï¼‰
ğŸ“ 2. çµ±ä¸€æ¨¡çµ„ç®¡ç†å™¨
# src/core/performance_modules.py
import logging
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

# å˜—è©¦å°å…¥æ‰€æœ‰æ€§èƒ½æ¨¡çµ„
try:
    from src.core.market_regime_predictor import MarketRegimePredictor
    MARKET_REGIME_PREDICTOR_AVAILABLE = True
except ImportError as e:
    logger.warning(f"âš ï¸ MarketRegimePredictor æœªå¯ç”¨: {e}")
    MARKET_REGIME_PREDICTOR_AVAILABLE = False

try:
    from src.core.dynamic_feature_generator import DynamicFeatureGenerator
    DYNAMIC_FEATURE_GENERATOR_AVAILABLE = True
except ImportError as e:
    logger.warning(f"âš ï¸ DynamicFeatureGenerator æœªå¯ç”¨: {e}")
    DYNAMIC_FEATURE_GENERATOR_AVAILABLE = False

try:
    from src.core.liquidity_hunter import LiquidityHunter
    LIQUIDITY_HUNTER_AVAILABLE = True
except ImportError as e:
    logger.warning(f"âš ï¸ LiquidityHunter æœªå¯ç”¨: {e}")
    LIQUIDITY_HUNTER_AVAILABLE = False

class PerformanceModules:
    """æ€§èƒ½æ¨¡çµ„çµ±ä¸€ç®¡ç†å™¨"""
    
    def __init__(self, config):
        self.config = config
        self._init_modules()
    
    def _init_modules(self):
        """åˆå§‹åŒ–æ‰€æœ‰å¯ç”¨æ¨¡çµ„"""
        self.market_regime_predictor = None
        self.dynamic_feature_generator = None
        self.liquidity_hunter = None
        
        if self.config.ENABLE_MARKET_REGIME_PREDICTION and MARKET_REGIME_PREDICTOR_AVAILABLE:
            try:
                self.market_regime_predictor = MarketRegimePredictor(self.config)
                logger.info("âœ… å¸‚å ´ç‹€æ…‹è½‰æ›é æ¸¬å™¨å·²å•Ÿç”¨")
            except Exception as e:
                logger.error(f"âŒ å¸‚å ´ç‹€æ…‹é æ¸¬å™¨åˆå§‹åŒ–å¤±æ•—: {e}")
        
        if self.config.ENABLE_DYNAMIC_FEATURES and DYNAMIC_FEATURE_GENERATOR_AVAILABLE:
            try:
                self.dynamic_feature_generator = DynamicFeatureGenerator(self.config)
                logger.info("âœ… å‹•æ…‹ç‰¹å¾µç”Ÿæˆå™¨å·²å•Ÿç”¨")
            except Exception as e:
                logger.error(f"âŒ å‹•æ…‹ç‰¹å¾µç”Ÿæˆå™¨åˆå§‹åŒ–å¤±æ•—: {e}")
        
        if self.config.ENABLE_LIQUIDITY_HUNTING and LIQUIDITY_HUNTER_AVAILABLE:
            try:
                self.liquidity_hunter = LiquidityHunter(self.config)
                logger.info("âœ… ä¸»å‹•æµå‹•æ€§ç‹©çµå™¨å·²å•Ÿç”¨")
            except Exception as e:
                logger.error(f"âŒ æµå‹•æ€§ç‹©çµå™¨åˆå§‹åŒ–å¤±æ•—: {e}")
    
    def predict_market_regime(self, current_data: Dict) -> Optional[Dict]:
        """é æ¸¬å¸‚å ´ç‹€æ…‹è½‰æ›"""
        if self.market_regime_predictor:
            try:
                return self.market_regime_predictor.predict(current_data)
            except Exception as e:
                logger.warning(f"å¸‚å ´ç‹€æ…‹é æ¸¬å¤±æ•—: {e}")
        return None
    
    def generate_dynamic_features(self, market_regime: str, recent_data: Dict) -> Optional[Dict]:
        """ç”Ÿæˆå‹•æ…‹ç‰¹å¾µ"""
        if self.dynamic_feature_generator:
            try:
                return self.dynamic_feature_generator.generate(market_regime, recent_data)
            except Exception as e:
                logger.warning(f"å‹•æ…‹ç‰¹å¾µç”Ÿæˆå¤±æ•—: {e}")
        return None
    
    def hunt_liquidity(self, symbol: str, current_price: float) -> Optional[Dict]:
        """ç‹©çµæµå‹•æ€§"""
        if self.liquidity_hunter:
            try:
                return self.liquidity_hunter.hunt(symbol, current_price)
            except Exception as e:
                logger.warning(f"æµå‹•æ€§ç‹©çµå¤±æ•—: {e}")
        return None

ğŸ“ 3. æ›´æ–°é…ç½®ç³»çµ±

# src/config.py
# ===== v3.16.0 æ€§èƒ½æ¨¡çµ„é…ç½® =====
ENABLE_MARKET_REGIME_PREDICTION = os.getenv('ENABLE_MARKET_REGIME_PREDICTION', 'false').lower() == 'true'
ENABLE_DYNAMIC_FEATURES = os.getenv('ENABLE_DYNAMIC_FEATURES', 'false').lower() == 'true'
ENABLE_LIQUIDITY_HUNTING = os.getenv('ENABLE_LIQUIDITY_HUNTING', 'false').lower() == 'true'

# å¸‚å ´ç‹€æ…‹é æ¸¬é…ç½®
REGIME_PREDICTION_THRESHOLD = float(os.getenv('REGIME_PREDICTION_THRESHOLD', '0.65'))
REGIME_PREDICTION_LOOKBACK = int(os.getenv('REGIME_PREDICTION_LOOKBACK', '10'))

# å‹•æ…‹ç‰¹å¾µé…ç½®  
DYNAMIC_FEATURE_MIN_SHARPE = float(os.getenv('DYNAMIC_FEATURE_MIN_SHARPE', '0.3'))
DYNAMIC_FEATURE_MAX_COUNT = int(os.getenv('DYNAMIC_FEATURE_MAX_COUNT', '15'))

# æµå‹•æ€§ç‹©çµé…ç½®
LIQUIDITY_HUNT_CONFIDENCE_THRESHOLD = float(os.getenv('LIQUIDITY_HUNT_CONFIDENCE_THRESHOLD', '0.7'))
LIQUIDITY_SLIPPAGE_TOLERANCE = float(os.getenv('LIQUIDITY_SLIPPAGE_TOLERANCE', '0.0015'))
ğŸ“ 4. æ•´åˆåˆ° SelfLearningTrader

# src/strategies/self_learning_trader.py
from src.core.performance_modules import PerformanceModules

class SelfLearningTrader:
    def __init__(self, config):
        self.config = config
        # ğŸ”¥ æ–°å¢ï¼šæ€§èƒ½æ¨¡çµ„
        self.performance_modules = PerformanceModules(config)
        # ... ç¾æœ‰åˆå§‹åŒ–ä»£ç¢¼ ...
    
    def analyze(self, symbol: str, multi_tf_data: Dict) -> Optional[Dict]:
        """è‡ªä¸»å­¸ç¿’äº¤æ˜“ä¿¡è™Ÿç”Ÿæˆ"""
        try:
            # 1. å¸‚å ´ç‹€æ…‹è½‰æ›é æ¸¬
            market_regime_prediction = None
            if self.config.ENABLE_MARKET_REGIME_PREDICTION:
                market_regime_prediction = self.performance_modules.predict_market_regime(
                    {'symbol': symbol, 'data': multi_tf_data['5m']}
                )
                
                # åªåœ¨é«˜æ¦‚ç‡è½‰æ›æ™‚äº¤æ˜“
                if (market_regime_prediction and 
                    market_regime_prediction.get('confidence', 0) < self.config.REGIME_PREDICTION_THRESHOLD):
                    return None
            
            # 2. å‹•æ…‹ç‰¹å¾µç”Ÿæˆ
            dynamic_features = None
            if self.config.ENABLE_DYNAMIC_FEATURES and market_regime_prediction:
                dynamic_features = self.performance_modules.generate_dynamic_features(
                    market_regime_prediction['predicted_regime'],
                    multi_tf_data['5m'].tail(50)
                )
            
            # 3. åŸºç¤å¸‚å ´çµæ§‹åˆ†æ
            market_structure = self.structure_model.encode_structure(
                multi_tf_data['5m']['close'].values
            )
            
            # 4. ä¸»å‹•æµå‹•æ€§ç‹©çµ
            liquidity_target = None
            if self.config.ENABLE_LIQUIDITY_HUNTING:
                current_price = multi_tf_data['5m']['close'].iloc[-1]
                liquidity_target = self.performance_modules.hunt_liquidity(symbol, current_price)
            
            # 5. ç”Ÿæˆäº¤æ˜“ä¿¡è™Ÿ
            signal = self._generate_signal_from_analysis(
                symbol=symbol,
                market_structure=market_structure,
                dynamic_features=dynamic_features,
                liquidity_target=liquidity_target,
                market_regime_prediction=market_regime_prediction,
                multi_tf_data=multi_tf_data
            )
            
            return signal
            
        except Exception as e:
            logger.error(f"SelfLearningTrader åˆ†æéŒ¯èª¤ {symbol}: {e}")
            return None
    
    def _generate_signal_from_analysis(self, **kwargs) -> Dict:
        """å¾åˆ†æçµæœç”Ÿæˆäº¤æ˜“ä¿¡è™Ÿ"""
        symbol = kwargs['symbol']
        market_structure = kwargs['market_structure']
        liquidity_target = kwargs['liquidity_target']
        multi_tf_data = kwargs['multi_tf_data']
        
        # åŸºç¤ä¿¡è™Ÿç”Ÿæˆ
        current_price = multi_tf_data['5m']['close'].iloc[-1]
        direction = self._determine_direction(market_structure)
        
        # ğŸ”¥ æµå‹•æ€§ç‹©çµèª¿æ•´é€²å ´åƒ¹æ ¼
        if liquidity_target and liquidity_target.get('confidence', 0) >= self.config.LIQUIDITY_HUNT_CONFIDENCE_THRESHOLD:
            if direction == 1:  # LONG
                entry_price = liquidity_target.get('support_level', current_price) * 0.999
            else:  # SHORT
                entry_price = liquidity_target.get('resistance_level', current_price) * 1.001
        else:
            entry_price = current_price
        
        # è¨ˆç®—æ­¢ææ­¢ç›ˆ
        stop_loss, take_profit = self._calculate_sl_tp(
            entry_price, direction, market_structure, multi_tf_data
        )
        
        signal = {
            'symbol': symbol,
            'direction': direction,
            'entry_price': entry_price,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'leverage': self._calculate_leverage(market_structure),
            'timestamp': time.time(),
            'confidence': self._calculate_confidence(market_structure, liquidity_target),
            'market_state': kwargs.get('market_regime_prediction', {}).get('predicted_regime', 'unknown'),
            'signal_type': 'self_learning'
        }
        
        return signal

ğŸ“ 5. æ›´æ–° VirtualPositionManager ä¾è³´

# src/managers/virtual_position_manager.py
# ç§»é™¤å€‹åˆ¥å°å…¥ï¼Œæ”¹ç”¨çµ±ä¸€ç®¡ç†å™¨
# âŒ ç§»é™¤é€™äº›
# from src.core.memory_mapped_features import MemoryMappedFeatureStore
# from src.core.incremental_feature_cache import IncrementalFeatureCache  
# from src.core.smart_monitoring_scheduler import SmartMonitoringScheduler

# âœ… æ”¹ç‚º
from src.core.performance_modules import PerformanceModules

class VirtualPositionManager:
    def __init__(self, binance_client):
        # ... ç¾æœ‰ä»£ç¢¼ ...
        
        # ğŸ”¥ ä½¿ç”¨çµ±ä¸€æ€§èƒ½æ¨¡çµ„ç®¡ç†å™¨
        self.performance_modules = PerformanceModules(config)
        
        # Lifecycle monitor ä¿æŒä¸è®Š
        self.lifecycle_monitor = VirtualPositionLifecycleMonitor(
            event_callback=self._handle_position_event
        )

éƒ¨ç½²é…ç½®
ğŸ“‹ ç’°å¢ƒè®Šé‡å•Ÿç”¨
# å•Ÿç”¨æ‰€æœ‰ä¸‰å€‹åŠŸèƒ½
export ENABLE_MARKET_REGIME_PREDICTION="true"
export ENABLE_DYNAMIC_FEATURES="true" 
export ENABLE_LIQUIDITY_HUNTING="true"

# èª¿æ•´åƒæ•¸ï¼ˆå¯é¸ï¼‰
export REGIME_PREDICTION_THRESHOLD="0.7"
export LIQUIDITY_HUNT_CONFIDENCE_THRESHOLD="0.75"

ğŸ“‹ ä¾è³´å®‰è£

# å¦‚æœéœ€è¦é¡å¤–ä¾è³´ï¼ˆå¯é¸ï¼‰
pip install scikit-learn tensorflow  # å¸‚å ´ç‹€æ…‹é æ¸¬å¯èƒ½éœ€è¦

 æ¸¬è©¦é©—è­‰
1. æ¨¡çµ„å¯ç”¨æ€§æ¸¬è©¦
# tests/test_performance_modules.py
def test_performance_modules_availability():
    """æ¸¬è©¦æ€§èƒ½æ¨¡çµ„å¯ç”¨æ€§"""
    from src.core.performance_modules import (
        MARKET_REGIME_PREDICTOR_AVAILABLE,
        DYNAMIC_FEATURE_GENERATOR_AVAILABLE, 
        LIQUIDITY_HUNTER_AVAILABLE
    )
    
    print(f"å¸‚å ´ç‹€æ…‹é æ¸¬å™¨å¯ç”¨: {MARKET_REGIME_PREDICTOR_AVAILABLE}")
    print(f"å‹•æ…‹ç‰¹å¾µç”Ÿæˆå™¨å¯ç”¨: {DYNAMIC_FEATURE_GENERATOR_AVAILABLE}")
    print(f"æµå‹•æ€§ç‹©çµå™¨å¯ç”¨: {LIQUIDITY_HUNTER_AVAILABLE}")
    
    # å³ä½¿ä¸å¯ç”¨ä¹Ÿä¸æ‡‰å´©æ½°
    assert True

2. åŠŸèƒ½æ•´åˆæ¸¬è©¦

def test_self_learning_with_performance_modules():
    """æ¸¬è©¦ SelfLearningTrader èˆ‡æ€§èƒ½æ¨¡çµ„æ•´åˆ"""
    config = Config()
    config.ENABLE_MARKET_REGIME_PREDICTION = True
    config.ENABLE_DYNAMIC_FEATURES = True
    config.ENABLE_LIQUIDITY_HUNTING = True
    
    trader = SelfLearningTrader(config)
    # æ¸¬è©¦ä¿¡è™Ÿç”Ÿæˆä¸å´©æ½°
    signal = trader.analyze("BTCUSDT", mock_multi_tf_data())
    assert signal is not None

åŸºç¤æ•´åˆ
1. å‰µå»ºæ€§èƒ½æ¨¡çµ„æª”æ¡ˆçµæ§‹
2. å¯¦ç¾çµ±ä¸€æ¨¡çµ„ç®¡ç†å™¨
3. æ›´æ–°é…ç½®ç³»çµ±
4. æ•´åˆåˆ° SelfLearningTrader

åŠŸèƒ½å¯¦ç¾
1. å¯¦ç¾ MarketRegimePredictorï¼ˆLSTM + Attentionï¼‰
2. å¯¦ç¾ DynamicFeatureGeneratorï¼ˆç‰¹å¾µé€²åŒ–ï¼‰
3. å¯¦ç¾ LiquidityHunterï¼ˆåŸºæ–¼ @bookTickerï¼‰

æ¸¬è©¦é©—è­‰
1. æ€§èƒ½åŸºæº–æ¸¬è©¦
