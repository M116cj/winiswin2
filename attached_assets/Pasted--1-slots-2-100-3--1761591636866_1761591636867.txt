ğŸ¯ æ•´åˆç›®æ¨™
1. å…¨é¢æ›¿æ›èˆŠå­—å…¸çµæ§‹ â†’ æ–° __slots__ è³‡æ–™é¡åˆ¥
2. ç¢ºä¿é›¶åŠŸèƒ½æ”¹è®Šï¼ˆè¼¸å‡º/è¡Œç‚º 100% ä¸€è‡´ï¼‰
3. é€æ­¥æ•´åˆ + è‡ªå‹•é©—è­‰



ğŸ“ ç¬¬ä¸€æ­¥ï¼šå®šç¾©æ¨™æº–åŒ–è³‡æ–™é¡åˆ¥ï¼ˆsrc/core/data_models.pyï¼‰
# src/core/data_models.py
from typing import Optional, List
from dataclasses import dataclass, asdict
import json

@dataclass(frozen=True)
class TradingSignal:
    """äº¤æ˜“ä¿¡è™Ÿæ¨™æº–åŒ–è³‡æ–™é¡åˆ¥"""
    __slots__ = (
        'symbol', 'direction', 'confidence_score', 'entry_price',
        'stop_loss', 'take_profit', 'leverage', 'timestamp',
        'rsi_entry', 'atr_entry', 'trend_5m_encoded', 'market_structure_encoded',
        'order_blocks_count', 'liquidity_zones_count', 'risk_reward_ratio',
        'ml_prediction', 'market_regime', 'is_backtest'
    )
    
    symbol: str
    direction: int  # 1=LONG, -1=SHORT
    confidence_score: float
    entry_price: float
    stop_loss: float
    take_profit: float
    leverage: int
    timestamp: float
    rsi_entry: float
    atr_entry: float
    trend_5m_encoded: int
    market_structure_encoded: int
    order_blocks_count: int
    liquidity_zones_count: int
    risk_reward_ratio: float
    ml_prediction: float
    market_regime: str
    is_backtest: bool = False
    
    def to_dict(self) -> dict:
        """ç›¸å®¹èˆŠç³»çµ±çš„å­—å…¸è¼¸å‡º"""
        return asdict(self)
    
    def to_json(self) -> str:
        """JSON åºåˆ—åŒ–"""
        return json.dumps(self.to_dict())

@dataclass(frozen=True)
class VirtualPosition:
    """è™›æ“¬å€‰ä½æ¨™æº–åŒ–è³‡æ–™é¡åˆ¥"""
    __slots__ = (
        'symbol', 'direction', 'entry_price', 'stop_loss', 'take_profit',
        'leverage', 'entry_timestamp', 'current_price', 'pnl_pct',
        'is_closed', 'close_timestamp', 'close_reason', 'signal_id'
    )
    
    symbol: str
    direction: int
    entry_price: float
    stop_loss: float
    take_profit: float
    leverage: int
    entry_timestamp: float
    current_price: float
    pnl_pct: float
    is_closed: bool
    close_timestamp: Optional[float]
    close_reason: Optional[str]  # "tp", "sl", "expired"
    signal_id: str  # é—œè¯åŸå§‹ä¿¡è™Ÿ
    
    def to_dict(self) -> dict:
        return asdict(self)

# å…¶ä»–éœ€è¦çš„è³‡æ–™é¡åˆ¥...

 ç¬¬äºŒæ­¥ï¼šæ•´åˆåˆ° virtual_position_manager.py
âŒ èˆŠä»£ç¢¼ï¼ˆå­—å…¸çµæ§‹ï¼‰
# src/managers/virtual_position_manager.py (èˆŠ)
def create_virtual_position(self, signal: dict):
    position = {
        'symbol': signal['symbol'],
        'direction': signal['direction'],
        'entry_price': signal['entry_price'],
        # ... 20+ è¡Œ
    }
    self.positions.append(position)

âœ… æ–°ä»£ç¢¼ï¼ˆä½¿ç”¨è³‡æ–™é¡åˆ¥ï¼‰

# src/managers/virtual_position_manager.py (æ–°)
from src.core.data_models import VirtualPosition, TradingSignal

def create_virtual_position(self, signal: TradingSignal):
    """å‰µå»ºè™›æ“¬å€‰ä½ - ä½¿ç”¨æ¨™æº–åŒ–è³‡æ–™é¡åˆ¥"""
    position = VirtualPosition(
        symbol=signal.symbol,
        direction=signal.direction,
        entry_price=signal.entry_price,
        stop_loss=signal.stop_loss,
        take_profit=signal.take_profit,
        leverage=signal.leverage,
        entry_timestamp=signal.timestamp,
        current_price=signal.entry_price,  # åˆå§‹åƒ¹æ ¼
        pnl_pct=0.0,
        is_closed=False,
        close_timestamp=None,
        close_reason=None,
        signal_id=f"{signal.symbol}_{signal.timestamp}"
    )
    self.positions.append(position)
    return position

def _check_virtual_exit(self, position: VirtualPosition, current_price: float):
    """æª¢æŸ¥è™›æ“¬å€‰ä½æ˜¯å¦è§¸ç™¼é€€å‡º"""
    # ä½¿ç”¨ position.stop_loss è€Œé position['stop_loss']
    if position.direction == 1:  # LONG
        if current_price >= position.take_profit:
            return "tp"
        elif current_price <= position.stop_loss:
            return "sl"
    else:  # SHORT
        if current_price <= position.take_profit:
            return "tp"
        elif current_price >= position.stop_loss:
            return "sl"
    
    # æª¢æŸ¥éæœŸï¼ˆ96å°æ™‚ï¼‰
    if time.time() - position.entry_timestamp > 96 * 3600:
        return "expired"
    
    return None

ç¬¬ä¸‰æ­¥ï¼šæ•´åˆåˆ° data_archiver.pyï¼ˆML è³‡æ–™æ­¸æª”ï¼‰
âŒ èˆŠä»£ç¢¼
# src/ml/data_archiver.py (èˆŠ)
def archive_signal(self, signal: dict, result: dict):
    training_data = {
        'entry_price': signal['entry_price'],
        'exit_price': result['exit_price'],
        'pnl_pct': result['pnl_pct'],
        'is_winner': 1 if result['pnl_pct'] > 0 else 0,
        # ... 31 å€‹ç‰¹å¾µ
    }
    self.save_to_file(training_data)
âœ… æ–°ä»£ç¢¼
# src/ml/data_archiver.py (æ–°)
from src.core.data_models import TradingSignal

def archive_signal(self, signal: TradingSignal, result: dict):
    """æ­¸æª” ML è¨“ç·´è³‡æ–™ - ä½¿ç”¨æ¨™æº–åŒ–ä¿¡è™Ÿ"""
    training_data = {
        # ç›´æ¥å¾ signal ç‰©ä»¶æå–ï¼Œç¢ºä¿é †åºä¸€è‡´
        'confidence_score': signal.confidence_score,
        'leverage': signal.leverage,
        'rsi_entry': signal.rsi_entry,
        'atr_entry': signal.atr_entry,
        'trend_5m_encoded': signal.trend_5m_encoded,
        'market_structure_encoded': signal.market_structure_encoded,
        'order_blocks_count': signal.order_blocks_count,
        'liquidity_zones_count': signal.liquidity_zones_count,
        'risk_reward_ratio': signal.risk_reward_ratio,
        'hour_of_day': int(time.strftime('%H', time.localtime(signal.timestamp))),
        'day_of_week': int(time.strftime('%w', time.localtime(signal.timestamp))),
        'is_weekend': 1 if int(time.strftime('%w', time.localtime(signal.timestamp))) in [0, 6] else 0,
        # ... å…¶ä»–ç‰¹å¾µ
        'pnl_pct': result['pnl_pct'],
        'is_winner': 1 if result['pnl_pct'] > 0 else 0,
        'risk_adjusted_return': result['pnl_pct'] / signal.atr_entry if signal.atr_entry > 0 else 0
    }
    self.save_to_file(training_data)
ğŸ§ª ç¬¬å››æ­¥ï¼šå»ºç«‹é©—è­‰æ©Ÿåˆ¶ï¼ˆé—œéµï¼ï¼‰
1. é¡å‹æª¢æŸ¥è…³æœ¬
# tests/validate_data_models.py
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.core.data_models import TradingSignal, VirtualPosition

def test_trading_signal_creation():
    """æ¸¬è©¦ TradingSignal å‰µå»º"""
    signal = TradingSignal(
        symbol="BTCUSDT",
        direction=1,
        confidence_score=0.85,
        entry_price=60000.0,
        stop_loss=59000.0,
        take_profit=62000.0,
        leverage=10,
        timestamp=1730000000.0,
        rsi_entry=65.0,
        atr_entry=500.0,
        trend_5m_encoded=1,
        market_structure_encoded=1,
        order_blocks_count=3,
        liquidity_zones_count=2,
        risk_reward_ratio=2.0,
        ml_prediction=0.82,
        market_regime="trending",
        is_backtest=False
    )
    
    # é©—è­‰å±¬æ€§å­˜å–
    assert signal.symbol == "BTCUSDT"
    assert signal.confidence_score == 0.85
    
    # é©—è­‰ä¸å¯è®Šæ€§
    try:
        signal.symbol = "ETHUSDT"
        assert False, "æ‡‰è©²ç„¡æ³•ä¿®æ”¹ frozen ç‰©ä»¶"
    except:
        pass
    
    # é©—è­‰è¨˜æ†¶é«”ä½¿ç”¨
    import sys
    size = sys.getsizeof(signal)
    print(f"TradingSignal è¨˜æ†¶é«”å¤§å°: {size} bytes (é æœŸ < 400)")
    assert size < 400  # æ‡‰æ¯” dict å°å¾ˆå¤š
    
    print("âœ… TradingSignal æ¸¬è©¦é€šé")

def test_virtual_position_creation():
    """æ¸¬è©¦ VirtualPosition å‰µå»º"""
    pos = VirtualPosition(
        symbol="ETHUSDT",
        direction=-1,
        entry_price=3000.0,
        stop_loss=3100.0,
        take_profit=2800.0,
        leverage=5,
        entry_timestamp=1730000000.0,
        current_price=2950.0,
        pnl_pct=1.67,
        is_closed=False,
        close_timestamp=None,
        close_reason=None,
        signal_id="ETHUSDT_1730000000"
    )
    
    assert pos.symbol == "ETHUSDT"
    assert pos.pnl_pct == 1.67
    
    print("âœ… VirtualPosition æ¸¬è©¦é€šé")

if __name__ == "__main__":
    test_trading_signal_creation()
    test_virtual_position_creation()
    print("ğŸ‰ æ‰€æœ‰è³‡æ–™æ¨¡å‹é©—è­‰é€šéï¼")
2. åŠŸèƒ½ç›¸å®¹æ€§æ¸¬è©¦
# tests/compatibility_test.py
def test_dict_compatibility():
    """ç¢ºä¿ to_dict() èˆ‡èˆŠç³»çµ±ç›¸å®¹"""
    signal = TradingSignal(...)  # å‰µå»ºå¯¦ä¾‹
    old_dict = signal.to_dict()
    
    # é©—è­‰æ‰€æœ‰å¿…è¦æ¬„ä½å­˜åœ¨
    required_fields = ['symbol', 'direction', 'confidence_score', 'entry_price']
    for field in required_fields:
        assert field in old_dict
    
    # é©—è­‰æ•¸å€¼æ­£ç¢º
    assert old_dict['symbol'] == signal.symbol
    assert old_dict['confidence_score'] == signal.confidence_score
    
    print("âœ… å­—å…¸ç›¸å®¹æ€§æ¸¬è©¦é€šé")