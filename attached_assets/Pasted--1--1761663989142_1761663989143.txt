æ ¸å¿ƒå„ªåŒ–æ–¹å‘ï¼šè®“æ¨¡å‹å­¸å¾—æ›´å¿«ã€æ›´æº–ã€æ›´é©æ‡‰å¸‚å ´è®ŠåŒ–

1ï¸âƒ£ å¼·åŒ–è™›æ“¬å€‰ä½çš„çœŸå¯¦æ€§ï¼ˆè§£æ±ºã€Œæ¨¡æ“¬åèª¤ã€ï¼‰
å•é¡Œï¼š
è™›æ“¬å€‰ä½ä½¿ç”¨ç†æƒ³åƒ¹æ ¼ï¼Œå¿½ç•¥ æ»‘é»ã€æµå‹•æ€§ä¸è¶³ã€å¼·å¹³ ç­‰ç¾å¯¦å› ç´ ã€‚

âœ… å„ªåŒ–æ–¹æ¡ˆï¼š
# src/core/virtual_position_monitor.py
def _simulate_realistic_pnl(self, virtual_pos: VirtualPosition, current_price: float):
    """æ¨¡æ“¬çœŸå¯¦äº¤æ˜“æ¢ä»¶"""
    # 1. åŠ å…¥æ»‘é»ï¼ˆåŸºæ–¼æµå‹•æ€§åˆ†æ•¸ï¼‰
    liquidity_score = self._get_liquidity_score(virtual_pos.symbol)
    slippage = max(0.001, 0.003 * (1 - liquidity_score))  # 0.1%~0.3%
    
    # 2. èª¿æ•´æˆäº¤åƒ¹
    if virtual_pos.direction == "LONG":
        effective_price = current_price * (1 + slippage)
    else:
        effective_price = current_price * (1 - slippage)
    
    # 3. æ¨¡æ“¬å¼·å¹³ï¼ˆåŸºæ–¼ä¿è­‰é‡‘æ¯”ç‡ï¼‰
    margin_ratio = self._calculate_margin_ratio(virtual_pos, effective_price)
    if margin_ratio >= 0.8:  # Binance å¼·å¹³ç·š â‰ˆ100%ï¼Œ80% å®‰å…¨é‚Šéš›
        return self._simulate_liquidation(virtual_pos, effective_price)
    
    return self._calculate_pnl(virtual_pos, effective_price)
æ•ˆæœï¼šè™›æ“¬å€‰ä½ PnL æ›´æ¥è¿‘å¯¦ç›¤ï¼Œé¿å…æ¨¡å‹éåº¦æ¨‚è§€ã€‚ 



2ï¸âƒ£ ç«¶åƒ¹è¨˜éŒ„ â†’ ç‰¹å¾µå·¥ç¨‹ï¼ˆè§£æ±ºã€Œæ•¸æ“šæµªè²»ã€ï¼‰
å•é¡Œï¼š
signal_competitions.jsonl åƒ…ç”¨æ–¼å¯©è¨ˆï¼Œæœªç”¨æ–¼æ”¹é€²æ¨¡å‹ã€‚

âœ… å„ªåŒ–æ–¹æ¡ˆï¼š
# src/ml/feature_engine.py
def build_enhanced_features(self, signal: TradeSignal, competition_context: dict):
    """åŠ å…¥ç«¶åƒ¹ä¸Šä¸‹æ–‡ç‰¹å¾µ"""
    base_features = self._build_base_features(signal)
    
    # æ–°å¢ç‰¹å¾µï¼šä¿¡è™Ÿåœ¨ç«¶åƒ¹ä¸­çš„ç›¸å°æ’å
    rank_features = {
        'competition_rank': competition_context['rank'],  # 1, 2, 3...
        'score_gap_to_best': competition_context['best_score'] - competition_context['my_score'],
        'num_competing_signals': competition_context['total_signals']
    }
    
    return {**base_features, **rank_features}
æ•ˆæœï¼šæ¨¡å‹å­¸æœƒã€Œåœ¨å¤šä¿¡è™Ÿç«¶çˆ­ç’°å¢ƒä¸‹ï¼Œå“ªäº›ç‰¹å¾µçœŸæ­£é‡è¦ã€ã€‚ 



3ï¸âƒ£ å‹•æ…‹é‡è¨“ç·´è§¸ç™¼ï¼ˆè§£æ±ºã€Œå¸‚å ´é©æ‡‰æ…¢ã€ï¼‰
å•é¡Œï¼š
å›ºå®š 50 ç­†è§¸ç™¼ï¼Œç„¡æ³•æ‡‰å°å¸‚å ´ regime shiftï¼ˆå¦‚å¾ trending â†’ choppyï¼‰ã€‚

âœ… å„ªåŒ–æ–¹æ¡ˆï¼š
# src/core/model_initializer.py
def should_retrain(self) -> bool:
    """å‹•æ…‹é‡è¨“ç·´è§¸ç™¼æ¢ä»¶"""
    recent_trades = self._get_recent_trades(days=1)
    
    # æ¢ä»¶ 1ï¼šæ€§èƒ½é©Ÿé™ï¼ˆSharpe æ¯”ç‡ä¸‹é™ 50%ï¼‰
    if len(recent_trades) >= 10:
        current_sharpe = self._calculate_sharpe(recent_trades)
        historical_sharpe = self._get_historical_sharpe()
        if current_sharpe < historical_sharpe * 0.5:
            return True
    
    # æ¢ä»¶ 2ï¼šå¸‚å ´ç‹€æ…‹åŠ‡è®Š
    current_regime = self.trend_monitor.get_current_regime()
    if current_regime != self.last_regime:
        self.last_regime = current_regime
        return True  # ç«‹å³é‡è¨“ç·´
    
    # æ¢ä»¶ 3ï¼šç´¯ç©è¶³å¤ æ¨£æœ¬ï¼ˆåŸæœ‰é‚è¼¯ï¼‰
    return len(self.new_samples) >= 50
æ•ˆæœï¼šæ¨¡å‹åœ¨å¸‚å ´è½‰å‘æ™‚ 24 å°æ™‚å…§ è‡ªå‹•é©æ‡‰ï¼Œè€Œéç­‰å¾… 50 ç­†äº¤æ˜“ã€‚ 



4ï¸âƒ£ æ¢ç´¢-åˆ©ç”¨å¹³è¡¡ï¼ˆè§£æ±ºã€Œå±€éƒ¨æœ€å„ªã€ï¼‰
å•é¡Œï¼š
æ¨¡å‹åªåŸ·è¡Œæœ€é«˜åˆ†ä¿¡è™Ÿï¼Œå¯èƒ½éŒ¯éæ–°å¸‚å ´æ©Ÿæœƒã€‚

âœ… å„ªåŒ–æ–¹æ¡ˆï¼š
# src/strategies/self_learning_trader.py
async def execute_best_trade(self, signals: List[TradeSignal]):
    # ... [åŸæœ‰é‚è¼¯] ...
    
    # 5% æ™‚é–“åŸ·è¡Œæ¢ç´¢æ€§äº¤æ˜“
    if random.random() < 0.05:
        # å¾ Rank 2-5 ä¸­éš¨æ©Ÿé¸ä¸€å€‹
        exploration_candidates = [s for s in scored_signals if s != best]
        if exploration_candidates:
            explore = random.choice(exploration_candidates)
            logger.info(f"ğŸ” æ¢ç´¢æ¨¡å¼: åŸ·è¡Œ {explore['signal'].symbol}ï¼ˆéæœ€å„ªï¼‰")
            return await self._place_order_and_monitor(explore['signal'], explore['size'], available_balance)
    
    # åŸ·è¡Œæœ€å„ªä¿¡è™Ÿ
    return await self._place_order_and_monitor(best['signal'], best['size'], available_balance)
æ•ˆæœï¼šæŒçºŒæ”¶é›†ã€Œæ¨¡å‹ä¸å–œæ­¡ä½†å¯èƒ½æ­£ç¢ºã€çš„æ¨£æœ¬ï¼Œé¿å…éæ“¬åˆã€‚ 



5ï¸âƒ£ ç‰¹å¾µé‡è¦æ€§åé¥‹ï¼ˆè§£æ±ºã€Œç‰¹å¾µæ¼‚ç§»ã€ï¼‰
å•é¡Œï¼š
å¸‚å ´è®ŠåŒ–å°è‡´æŸäº›ç‰¹å¾µå¤±æ•ˆï¼ˆå¦‚ RSI åœ¨ trending å¸‚å¤±æ•ˆï¼‰ã€‚

âœ… å„ªåŒ–æ–¹æ¡ˆï¼š
# src/core/model_evaluator.py
def analyze_feature_importance(self, model: XGBClassifier):
    """åˆ†æç‰¹å¾µé‡è¦æ€§ä¸¦å‹•æ…‹èª¿æ•´"""
    importance = model.feature_importances_
    feature_names = self.feature_engine.get_feature_names()
    
    # è¨˜éŒ„é‡è¦æ€§åˆ°æ—¥èªŒ
    for name, imp in zip(feature_names, importance):
        print(f"[FEATURE_IMPORTANCE] {name}: {imp:.4f}")
    
    # å‹•æ…‹èª¿æ•´ç‰¹å¾µæ¬Šé‡ï¼ˆç”¨æ–¼ä¸‹è¼ªè¨“ç·´ï¼‰
    low_importance_features = [name for name, imp in zip(feature_names, importance) if imp < 0.01]
    if low_importance_features:
        logger.warning(f"âš ï¸ ä½é‡è¦æ€§ç‰¹å¾µ: {low_importance_features}ï¼Œè€ƒæ…®ç§»é™¤")
ğŸ’¡ æ•ˆæœï¼šæ¨¡å‹è‡ªå‹•èšç„¦æ–¼ ç•¶å‰å¸‚å ´æœ‰æ•ˆçš„ç‰¹å¾µã€‚ 

