核心優化方向：讓模型學得更快、更準、更適應市場變化

1️⃣ 強化虛擬倉位的真實性（解決「模擬偏誤」）
問題：
虛擬倉位使用理想價格，忽略 滑點、流動性不足、強平 等現實因素。

✅ 優化方案：
# src/core/virtual_position_monitor.py
def _simulate_realistic_pnl(self, virtual_pos: VirtualPosition, current_price: float):
    """模擬真實交易條件"""
    # 1. 加入滑點（基於流動性分數）
    liquidity_score = self._get_liquidity_score(virtual_pos.symbol)
    slippage = max(0.001, 0.003 * (1 - liquidity_score))  # 0.1%~0.3%
    
    # 2. 調整成交價
    if virtual_pos.direction == "LONG":
        effective_price = current_price * (1 + slippage)
    else:
        effective_price = current_price * (1 - slippage)
    
    # 3. 模擬強平（基於保證金比率）
    margin_ratio = self._calculate_margin_ratio(virtual_pos, effective_price)
    if margin_ratio >= 0.8:  # Binance 強平線 ≈100%，80% 安全邊際
        return self._simulate_liquidation(virtual_pos, effective_price)
    
    return self._calculate_pnl(virtual_pos, effective_price)
效果：虛擬倉位 PnL 更接近實盤，避免模型過度樂觀。 



2️⃣ 競價記錄 → 特徵工程（解決「數據浪費」）
問題：
signal_competitions.jsonl 僅用於審計，未用於改進模型。

✅ 優化方案：
# src/ml/feature_engine.py
def build_enhanced_features(self, signal: TradeSignal, competition_context: dict):
    """加入競價上下文特徵"""
    base_features = self._build_base_features(signal)
    
    # 新增特徵：信號在競價中的相對排名
    rank_features = {
        'competition_rank': competition_context['rank'],  # 1, 2, 3...
        'score_gap_to_best': competition_context['best_score'] - competition_context['my_score'],
        'num_competing_signals': competition_context['total_signals']
    }
    
    return {**base_features, **rank_features}
效果：模型學會「在多信號競爭環境下，哪些特徵真正重要」。 



3️⃣ 動態重訓練觸發（解決「市場適應慢」）
問題：
固定 50 筆觸發，無法應對市場 regime shift（如從 trending → choppy）。

✅ 優化方案：
# src/core/model_initializer.py
def should_retrain(self) -> bool:
    """動態重訓練觸發條件"""
    recent_trades = self._get_recent_trades(days=1)
    
    # 條件 1：性能驟降（Sharpe 比率下降 50%）
    if len(recent_trades) >= 10:
        current_sharpe = self._calculate_sharpe(recent_trades)
        historical_sharpe = self._get_historical_sharpe()
        if current_sharpe < historical_sharpe * 0.5:
            return True
    
    # 條件 2：市場狀態劇變
    current_regime = self.trend_monitor.get_current_regime()
    if current_regime != self.last_regime:
        self.last_regime = current_regime
        return True  # 立即重訓練
    
    # 條件 3：累積足夠樣本（原有邏輯）
    return len(self.new_samples) >= 50
效果：模型在市場轉向時 24 小時內 自動適應，而非等待 50 筆交易。 



4️⃣ 探索-利用平衡（解決「局部最優」）
問題：
模型只執行最高分信號，可能錯過新市場機會。

✅ 優化方案：
# src/strategies/self_learning_trader.py
async def execute_best_trade(self, signals: List[TradeSignal]):
    # ... [原有邏輯] ...
    
    # 5% 時間執行探索性交易
    if random.random() < 0.05:
        # 從 Rank 2-5 中隨機選一個
        exploration_candidates = [s for s in scored_signals if s != best]
        if exploration_candidates:
            explore = random.choice(exploration_candidates)
            logger.info(f"🔍 探索模式: 執行 {explore['signal'].symbol}（非最優）")
            return await self._place_order_and_monitor(explore['signal'], explore['size'], available_balance)
    
    # 執行最優信號
    return await self._place_order_and_monitor(best['signal'], best['size'], available_balance)
效果：持續收集「模型不喜歡但可能正確」的樣本，避免過擬合。 



5️⃣ 特徵重要性反饋（解決「特徵漂移」）
問題：
市場變化導致某些特徵失效（如 RSI 在 trending 市失效）。

✅ 優化方案：
# src/core/model_evaluator.py
def analyze_feature_importance(self, model: XGBClassifier):
    """分析特徵重要性並動態調整"""
    importance = model.feature_importances_
    feature_names = self.feature_engine.get_feature_names()
    
    # 記錄重要性到日誌
    for name, imp in zip(feature_names, importance):
        print(f"[FEATURE_IMPORTANCE] {name}: {imp:.4f}")
    
    # 動態調整特徵權重（用於下輪訓練）
    low_importance_features = [name for name, imp in zip(feature_names, importance) if imp < 0.01]
    if low_importance_features:
        logger.warning(f"⚠️ 低重要性特徵: {low_importance_features}，考慮移除")
💡 效果：模型自動聚焦於 當前市場有效的特徵。 

