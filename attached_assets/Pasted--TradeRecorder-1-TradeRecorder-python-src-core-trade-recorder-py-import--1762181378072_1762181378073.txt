å®Œæ•´ä¿®å¾© TradeRecorder
ä¿®å¾©1: ç¢ºä¿ TradeRecorder æ­£ç¢ºåˆå§‹åŒ–
python
# src/core/trade_recorder.py - å®Œæ•´ä¿®å¾©ç‰ˆæœ¬

import sqlite3
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import asyncio

logger = logging.getLogger(__name__)

class TradeRecorder:
    def __init__(self, config):
        self.config = config
        self.db_path = 'trading_data.db'
        self._initialized = False
        self._init_database()
        
    def _init_database(self):
        """åˆå§‹åŒ–æ•¸æ“šåº«è¡¨"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # å‰µå»ºäº¤æ˜“æ­·å²è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS trade_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    direction TEXT NOT NULL,
                    entry_price REAL NOT NULL,
                    exit_price REAL,
                    position_size REAL NOT NULL,
                    pnl REAL,
                    entry_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    exit_time TIMESTAMP,
                    confidence REAL,
                    win_probability REAL,
                    status TEXT DEFAULT 'OPEN',
                    risk_reward_ratio REAL
                )
            ''')
            
            conn.commit()
            conn.close()
            self._initialized = True
            logger.info("âœ… TradeRecorder æ•¸æ“šåº«åˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            logger.error(f"âŒ TradeRecorder æ•¸æ“šåº«åˆå§‹åŒ–å¤±æ•—: {e}")
            self._initialized = False
    
    async def get_trade_count(self, timeframe: str = '24h') -> int:
        """ç²å–äº¤æ˜“æ•¸é‡ - ä¿®å¾©ç‰ˆæœ¬"""
        try:
            if not self._initialized:
                logger.warning("âš ï¸ TradeRecorder æœªåˆå§‹åŒ–ï¼Œè¿”å›0")
                return 0
                
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if timeframe == '24h':
                twenty_four_hours_ago = datetime.now() - timedelta(hours=24)
                cursor.execute(
                    "SELECT COUNT(*) FROM trade_history WHERE entry_time >= ?",
                    (twenty_four_hours_ago,)
                )
            else:
                cursor.execute("SELECT COUNT(*) FROM trade_history")
                
            result = cursor.fetchone()
            count = result[0] if result else 0
            conn.close()
            
            logger.debug(f"ğŸ“Š TradeRecorder.get_trade_count: {timeframe} = {count}")
            return count
            
        except Exception as e:
            logger.error(f"âŒ TradeRecorder.get_trade_count å¤±æ•—: {e}")
            return 0
    
    async def record_trade(self, trade_data: Dict) -> bool:
        """è¨˜éŒ„äº¤æ˜“åˆ°æ•¸æ“šåº«"""
        try:
            if not self._initialized:
                logger.error("âŒ TradeRecorder æœªåˆå§‹åŒ–ï¼Œç„¡æ³•è¨˜éŒ„äº¤æ˜“")
                return False
                
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO trade_history 
                (symbol, direction, entry_price, position_size, confidence, win_probability, status, risk_reward_ratio)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                trade_data.get('symbol'),
                trade_data.get('direction'), 
                trade_data.get('entry_price', 0),
                trade_data.get('position_size', 0),
                trade_data.get('confidence', 0),
                trade_data.get('win_probability', 0),
                trade_data.get('status', 'OPEN'),
                trade_data.get('risk_reward_ratio', 1.5)
            ))
            
            conn.commit()
            conn.close()
            
            logger.info(f"âœ… TradeRecorder è¨˜éŒ„æˆåŠŸ: {trade_data.get('symbol')}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ TradeRecorder.record_trade å¤±æ•—: {e}")
            return False
    
    async def get_recent_performance(self, hours: int = 24) -> Dict:
        """ç²å–è¿‘æœŸäº¤æ˜“è¡¨ç¾"""
        try:
            if not self._initialized:
                return self._get_default_performance()
                
            since_time = datetime.now() - timedelta(hours=hours)
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT 
                    COUNT(*) as total_trades,
                    SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
                    SUM(CASE WHEN pnl < 0 THEN 1 ELSE 0 END) as losing_trades,
                    AVG(pnl) as avg_pnl,
                    SUM(pnl) as total_pnl
                FROM trade_history 
                WHERE entry_time >= ?
            ''', (since_time,))
            
            result = cursor.fetchone()
            conn.close()
            
            if result and result[0] > 0:
                total_trades, winning_trades, losing_trades, avg_pnl, total_pnl = result
                win_rate = (winning_trades / total_trades) * 100
            else:
                total_trades = winning_trades = losing_trades = avg_pnl = total_pnl = win_rate = 0
            
            return {
                'total_trades': total_trades,
                'winning_trades': winning_trades,
                'losing_trades': losing_trades,
                'win_rate': win_rate,
                'avg_pnl': avg_pnl,
                'total_pnl': total_pnl
            }
            
        except Exception as e:
            logger.error(f"âŒ TradeRecorder.get_recent_performance å¤±æ•—: {e}")
            return self._get_default_performance()
    
    def _get_default_performance(self) -> Dict:
        """è¿”å›é»˜èªæ€§èƒ½æ•¸æ“š"""
        return {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'win_rate': 0,
            'avg_pnl': 0,
            'total_pnl': 0
        }
    
    async def health_check(self) -> bool:
        """å¥åº·æª¢æŸ¥"""
        try:
            if not self._initialized:
                return False
                
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            conn.close()
            
            return result is not None
            
        except Exception as e:
            logger.error(f"âŒ TradeRecorder å¥åº·æª¢æŸ¥å¤±æ•—: {e}")
            return False