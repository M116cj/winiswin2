æ‚¨è¯´å¾—å¯¹ï¼3.0ç§’æ‰«æ530ä¸ªäº¤æ˜“å¯¹ç¡®å®ä¸åˆç†ï¼Œè¿™è¡¨æ˜ç³»ç»Ÿä»ç„¶æ²¡æœ‰è¿›è¡ŒçœŸæ­£çš„æŠ€æœ¯åˆ†æã€‚

ğŸš¨ æ ¸å¿ƒé—®é¢˜ç¡®è®¤

3.0ç§’æ‰«æ530ä¸ªäº¤æ˜“å¯¹ = å¹³å‡æ¯ä¸ªäº¤æ˜“å¯¹ä»…5.7ms
è¿™æ ¹æœ¬ä¸å¯èƒ½æ˜¯å®Œæ•´çš„æŠ€æœ¯åˆ†æï¼Œä¸€å®šæ˜¯æŸä¸ªç¯èŠ‚åœ¨å¿«é€Ÿè·³è¿‡ã€‚

ğŸ” ç«‹å³è¯Šæ–­ï¼šæ·»åŠ åˆ†ææ—¶é—´ç›‘æ§

åœ¨unified_scheduler.pyä¸­æ·»åŠ è¯¦ç»†çš„æ—¶é—´åˆ†æï¼š

```python
def scan_symbols(self):
    import time
    signal_candidates = []
    analyzed_count = 0
    skip_count = 0
    
    # æ—¶é—´åˆ†æå˜é‡
    total_analysis_time = 0
    analysis_times = []
    
    logger.info("â±ï¸ ===== æ‰«ææ—¶é—´åˆ†æå¼€å§‹ =====")
    
    for i, symbol in enumerate(self.symbols):
        cycle_start = time.time()
        
        # æ•°æ®è·å–æ—¶é—´
        data_start = time.time()
        multi_tf_data = self.data_service.get_multi_timeframe_klines(symbol, self.timeframes)
        data_time = time.time() - data_start
        
        if not multi_tf_data:
            skip_count += 1
            continue
            
        # åˆ†ææ—¶é—´
        analysis_start = time.time()
        signal, confidence, win_prob = self.self_learning_trader.analyze(symbol, multi_tf_data)
        analysis_time = time.time() - analysis_start
        
        total_analysis_time += analysis_time
        analysis_times.append(analysis_time)
        analyzed_count += 1
        
        signal_candidates.append({
            'symbol': symbol, 'confidence': confidence, 
            'win_probability': win_prob, 'has_signal': signal is not None,
            'analysis_time': analysis_time
        })
        
        # æ¯50ä¸ªç¬¦å·è¾“å‡ºä¸€æ¬¡æ—¶é—´ç»Ÿè®¡
        if analyzed_count % 50 == 0:
            avg_analysis_time = total_analysis_time / analyzed_count
            logger.info(f"â±ï¸ è¿›åº¦: {analyzed_count}/530 | "
                       f"å¹³å‡åˆ†ææ—¶é—´: {avg_analysis_time*1000:.1f}ms | "
                       f"æ•°æ®è·å–: {data_time*1000:.1f}ms")
    
    # æœ€ç»ˆæ—¶é—´æŠ¥å‘Š
    if analyzed_count > 0:
        avg_time = total_analysis_time / analyzed_count
        min_time = min(analysis_times) * 1000
        max_time = max(analysis_times) * 1000
        avg_ms = avg_time * 1000
        
        logger.info("â±ï¸ ===== æ‰«ææ—¶é—´åˆ†ææŠ¥å‘Š =====")
        logger.info(f"ğŸ“Š åˆ†æäº¤æ˜“å¯¹: {analyzed_count}/{len(self.symbols)}")
        logger.info(f"ğŸš€ æœ€å¿«åˆ†æ: {min_time:.1f}ms")
        logger.info(f"ğŸŒ æœ€æ…¢åˆ†æ: {max_time:.1f}ms") 
        logger.info(f"ğŸ“ˆ å¹³å‡åˆ†æ: {avg_ms:.1f}ms")
        logger.info(f"â±ï¸ æ€»åˆ†ææ—¶é—´: {total_analysis_time:.1f}s")
        logger.info(f"ğŸ” æ•°æ®ç¼ºå¤±è·³è¿‡: {skip_count}")
        
        # åˆ¤æ–­åˆç†æ€§
        if avg_ms < 10:  # å°äº10msçš„åˆ†æä¸åˆç†
            logger.error(f"ğŸš¨ ä¸¥é‡é—®é¢˜: å¹³å‡åˆ†ææ—¶é—´ä»…{avg_ms:.1f}msï¼Œç³»ç»Ÿåœ¨å¿«é€Ÿè·³è¿‡!")
        elif avg_ms < 50:  # å°äº50msçš„åˆ†æå¯èƒ½ä¸å®Œæ•´
            logger.warning(f"âš ï¸ è­¦å‘Š: å¹³å‡åˆ†ææ—¶é—´{avg_ms:.1f}msï¼Œå¯èƒ½åˆ†ææ·±åº¦ä¸è¶³")
        else:
            logger.info(f"âœ… åˆç†: å¹³å‡åˆ†ææ—¶é—´{avg_ms:.1f}ms")
    
    return signal_candidates
```

ğŸ¯ å…³é”®æ€€ç–‘ç‚¹

åŸºäº3.0ç§’çš„æ€»æ—¶é—´ï¼Œæˆ‘æ€€ç–‘ä»¥ä¸‹å¿«é€Ÿè·³è¿‡ç‚¹ï¼š

æ€€ç–‘ç‚¹1ï¼š_validate_klines_data è¿‡äºä¸¥æ ¼

```python
def _validate_klines_data(self, multi_tf_data):
    """å¯èƒ½è¿‡äºä¸¥æ ¼çš„éªŒè¯"""
    required_tfs = ['1h', '15m', '5m']
    for tf in required_tfs:
        if tf not in multi_tf_data:
            return False
        df = multi_tf_data[tf]
        # âŒ å¯èƒ½ç¼ºå°‘å¿…è¦çš„åˆ—æˆ–æ•°æ®æ ¼å¼é—®é¢˜
        if df is None or len(df) < 50:
            return False
        # âŒ å¯èƒ½æ£€æŸ¥äº†ä¸å­˜åœ¨çš„ICTç‰¹å¾åˆ—
    return True
```

æ€€ç–‘ç‚¹2ï¼š_determine_signal_direction å¿«é€Ÿè¿”å›None

```python
def _determine_signal_direction(self, h1_data, m15_data, m5_data):
    """æ–¹å‘åˆ¤æ–­å¯èƒ½ç«‹å³è¿”å›None"""
    # âŒ å¯èƒ½å› ä¸ºæ•°æ®æ ¼å¼é—®é¢˜ç«‹å³è¿”å›None
    if not self._check_trend_strength(h1_data):
        return None  # ç«‹å³è¿”å›
    # ... å…¶ä»–å¿«é€Ÿè¿”å›æ¡ä»¶
```

æ€€ç–‘ç‚¹3ï¼šFeatureEngineç‰¹å¾è®¡ç®—é™é»˜å¤±è´¥

```python
def _build_ict_smc_features(self, signal, klines_data):
    """ç‰¹å¾è®¡ç®—å¯èƒ½è¿”å›ç©ºå­—å…¸"""
    try:
        # ç‰¹å¾è®¡ç®—é€»è¾‘...
        return features
    except Exception:
        return {}  # âŒ é™é»˜è¿”å›ç©ºå­—å…¸
```

ğŸ”§ ç´§æ€¥ä¿®å¤æ–¹æ¡ˆ

æ–¹æ¡ˆ1ï¼šæ”¾å®½æ•°æ®éªŒè¯ï¼ˆç«‹å³å®æ–½ï¼‰

```python
def _validate_klines_data(self, multi_tf_data):
    """æ”¾å®½çš„æ•°æ®éªŒè¯"""
    logger.debug("ğŸ” å¼€å§‹æ•°æ®éªŒè¯")
    
    required_tfs = ['1h', '15m', '5m']
    for tf in required_tfs:
        if tf not in multi_tf_data:
            logger.warning(f"âŒ ç¼ºå¤±æ—¶é—´æ¡†æ¶: {tf}")
            return False
        
        df = multi_tf_data[tf]
        if df is None:
            logger.warning(f"âŒ {tf}æ•°æ®ä¸ºNone")
            return False
            
        if len(df) < 10:  # ä»50é™ä½åˆ°10
            logger.warning(f"âŒ {tf}æ•°æ®ä¸è¶³: {len(df)}è¡Œ")
            return False
            
        # åªæ£€æŸ¥åŸºæœ¬OHLCVåˆ—ï¼Œä¸æ£€æŸ¥ICTç‰¹å¾åˆ—
        basic_columns = ['open', 'high', 'low', 'close']
        missing_columns = [col for col in basic_columns if col not in df.columns]
        if missing_columns:
            logger.warning(f"âŒ {tf}ç¼ºå¤±åŸºæœ¬åˆ—: {missing_columns}")
            return False
    
    logger.debug("âœ… æ•°æ®éªŒè¯é€šè¿‡")
    return True
```

æ–¹æ¡ˆ2ï¼šæ·»åŠ è¯¦ç»†çš„æ–¹å‘åˆ¤æ–­æ—¥å¿—

```python
def _determine_signal_direction(self, h1_data, m15_data, m5_data):
    """å¸¦è¯¦ç»†æ—¥å¿—çš„æ–¹å‘åˆ¤æ–­"""
    logger.debug("ğŸ¯ å¼€å§‹æ–¹å‘åˆ¤æ–­")
    
    try:
        # æ£€æŸ¥è¶‹åŠ¿å¼ºåº¦
        h1_trend = self._calculate_trend_strength(h1_data, '1h')
        m15_trend = self._calculate_trend_strength(m15_data, '15m')
        m5_trend = self._calculate_trend_strength(m5_data, '5m')
        
        logger.debug(f"ğŸ“Š è¶‹åŠ¿å¼ºåº¦ - 1h: {h1_trend:.2f}, 15m: {m15_trend:.2f}, 5m: {m5_trend:.2f}")
        
        # åˆ¤æ–­é€»è¾‘...
        if h1_trend > 0.6 and m15_trend > 0.5 and m5_trend > 0.4:
            direction = 'LONG'
        elif h1_trend < -0.6 and m15_trend < -0.5 and m5_trend < -0.4:
            direction = 'SHORT'
        else:
            direction = None
            
        logger.debug(f"âœ… æ–¹å‘åˆ¤æ–­ç»“æœ: {direction}")
        return direction
        
    except Exception as e:
        logger.error(f"âŒ æ–¹å‘åˆ¤æ–­å¤±è´¥: {e}")
        return None
```

æ–¹æ¡ˆ3ï¼šå¼ºåˆ¶ä¼ ç»Ÿæ¨¡å¼æµ‹è¯•

å¦‚æœçº¯ICTæ¨¡å¼æŒç»­å¤±è´¥ï¼Œç«‹å³åˆ‡æ¢åˆ°ä¼ ç»Ÿæ¨¡å¼æµ‹è¯•ï¼š

```python
# åœ¨unified_scheduler.pyä¸­ä¸´æ—¶å¼ºåˆ¶ä¼ ç»Ÿæ¨¡å¼
def start_scan_cycle(self):
    # å¼ºåˆ¶ä¼ ç»Ÿæ¨¡å¼æµ‹è¯•
    if hasattr(self.self_learning_trader.signal_generator, 'use_pure_ict'):
        self.self_learning_trader.signal_generator.use_pure_ict = False
        logger.warning("ğŸ”„ å¼ºåˆ¶åˆ‡æ¢åˆ°ä¼ ç»Ÿæ¨¡å¼è¿›è¡Œæµ‹è¯•")
    
    self.scan_symbols()
```

ğŸ“Š é¢„æœŸåˆç†æ—¶é—´åŸºå‡†

æ­£å¸¸æŠ€æœ¯åˆ†æåº”è¯¥éœ€è¦ï¼š

Â· å•ä¸ªäº¤æ˜“å¯¹ï¼š50-200ms
Â· 530ä¸ªäº¤æ˜“å¯¹ï¼š26-106ç§’
Â· å½“å‰æƒ…å†µï¼š3.0ç§’ â†’ æ˜æ˜¾å¼‚å¸¸

ğŸš€ ç«‹å³è¡ŒåŠ¨æ­¥éª¤

1. å®æ–½æ—¶é—´åˆ†æç›‘æ§ - æ‰¾åˆ°å…·ä½“è·³è¿‡ç‚¹
2. æ”¾å®½æ•°æ®éªŒè¯ - ç¡®ä¿æ›´å¤šäº¤æ˜“å¯¹è¿›å…¥åˆ†æ
3. æ·»åŠ è¯¦ç»†æ—¥å¿— - å®šä½å¿«é€Ÿè¿”å›çš„å…·ä½“åŸå› 
4. ä¼ ç»Ÿæ¨¡å¼æµ‹è¯• - éªŒè¯ç³»ç»ŸåŸºæœ¬åŠŸèƒ½

è¯·ç«‹å³éƒ¨ç½²è¿™äº›è¯Šæ–­ä»£ç ï¼æˆ‘ä»¬å°†èƒ½ç²¾ç¡®æ‰¾åˆ°ä¸ºä»€ä¹ˆç³»ç»Ÿåœ¨3ç§’å†…"å®Œæˆ"530ä¸ªäº¤æ˜“å¯¹çš„æ ¹æœ¬åŸå› ã€‚