ONNX ä»£ç¢¼æª¢æŸ¥æŒ‡ä»¤
æ¨¡å‹è½‰æ›æª¢æŸ¥
1. ç¢ºèª scripts/convert_xgboost_to_onnx.py ä¸­çš„ convert_model() å‡½æ•¸ä½¿ç”¨ FloatTensorType(input_shape) è€Œä¸æ˜¯ DoubleTensorTypeï¼Œä¸” input_shape é è¨­ç‚º (1, 31)
2. é©—è­‰è½‰æ›è…³æœ¬æ˜¯å¦åŒ…å«è‡ªå‹•é©—è­‰åŠŸèƒ½ï¼švalidate_conversion() å‡½æ•¸ä½¿ç”¨ np.random.uniform(0, 1, (10, n_features)).astype(np.float32) ç”Ÿæˆæ¸¬è©¦æ•¸æ“šï¼Œä¸¦æ¯”è¼ƒ XGBoost å’Œ ONNX è¼¸å‡ºçš„å·®ç•°
3. æª¢æŸ¥ FEATURE_ORDER_PATH = "data/models/feature_order.txt" æ˜¯å¦æ­£ç¢ºä¿å­˜ç‰¹å¾µé †åºï¼Œä¸” save_feature_order() å‡½æ•¸å°‡ç‰¹å¾µå¯«å…¥æª”æ¡ˆ

MLPredictor å¯¦ç¾æª¢æŸ¥
4. ç¢ºèª src/ml/predictor.py çš„ MLPredictor.__init__() æ–¹æ³•ä¸­ï¼Œonnx_path = model_path.replace('.pkl', '.onnx') æ­£ç¢ºæ›¿æ›å‰¯æª”å
5. é©—è­‰ predict_batch() æ–¹æ³•ä¸­ï¼ŒX = np.vstack(features_list).astype(np.float32) ä½¿ç”¨ float32 è€Œä¸æ˜¯ float64
6. æª¢æŸ¥ ONNX æ¨ç†éƒ¨åˆ†æ˜¯å¦ä½¿ç”¨ ort_inputs = {self.session.get_inputs()[0].name: X} æ§‹å»ºè¼¸å…¥ï¼Œè€Œä¸æ˜¯ç¡¬ç·¨ç¢¼è¼¸å…¥åç¨±
7. ç¢ºèªå›é€€æ©Ÿåˆ¶æ­£ç¢ºï¼šç•¶ ONNX è¼‰å…¥å¤±æ•—æ™‚ï¼Œself._load_xgboost_model(model_path) è¢«å‘¼å«ï¼Œä¸” self.use_onnx = False

ç‰¹å¾µæå–æª¢æŸ¥
8. ç¢ºèª src/ml/data_processor.py çš„ extract_features_for_prediction() å‡½æ•¸è¿”å› np.array(features, dtype=np.float32).reshape(1, -1)
9. é©—è­‰ç‰¹å¾µé †åºæ˜¯å¦èˆ‡ EXPECTED_FEATURES åˆ—è¡¨å®Œå…¨ä¸€è‡´ï¼Œç‰¹åˆ¥æ˜¯ç¬¬ 20 å€‹ç‰¹å¾µæ˜¯ 'direction_encoded' è€Œä¸æ˜¯å…¶ä»–

ä¸»å¾ªç’°æ•´åˆæª¢æŸ¥
10. ç¢ºèª src/main.py çš„ scan_and_analyze() æ–¹æ³•ä¸­ï¼Œä½¿ç”¨ features_batch = [extract_features_for_prediction(signal) for signal in signals] æ‰¹é‡æå–ç‰¹å¾µ
11. æª¢æŸ¥æ˜¯å¦å‘¼å« predictions = self.ml_predictor.predict_batch(features_batch) è€Œä¸æ˜¯é€å€‹é æ¸¬

æ¸¬è©¦èˆ‡é©—è­‰æª¢æŸ¥
12. ç¢ºèª scripts/verify_feature_order.py ä¸­çš„ EXPECTED_FEATURES åŒ…å« 33 å€‹ç‰¹å¾µï¼ˆ20 åŸºç¤ + 13 å¢å¼·ï¼‰ï¼Œä¸”é †åºæ­£ç¢º
13. é©—è­‰ scripts/check_onnx_compatibility.py çš„ check_onnx_model() å‡½æ•¸ä½¿ç”¨ onnx.checker.check_model(model) é©—è­‰ ONNX æ ¼å¼
14. æª¢æŸ¥ç›¸å®¹æ€§æª¢æŸ¥å·¥å…·æ˜¯å¦æ¸¬è©¦å‹•æ…‹ shape è™•ç†ï¼štest_shape = [1 if isinstance(dim, int) and dim <= 0 else dim for dim in input_shape]
15. ç¢ºèªæ‰€æœ‰ä¸‰å€‹è…³æœ¬ï¼ˆè½‰æ›ã€é©—è­‰ã€ç›¸å®¹æ€§ï¼‰éƒ½èƒ½ç¨ç«‹åŸ·è¡Œä¸”ä¸ä¾è³´æœªå®‰è£çš„å¥—ä»¶



ğŸ¯ Replit åŸ·è¡ŒæŒ‡ä»¤
å°‡ä»¥ä¸‹æ–‡å­—è¤‡è£½åˆ° Replit AI åŠ©æ‰‹ï¼š

ã€Œè«‹åš´æ ¼æª¢æŸ¥æ•´å€‹ä»£ç¢¼åº«ï¼Œç¢ºèªä»¥ä¸‹ 15 é … ONNX ç›¸é—œå¯¦ä½œæ˜¯å¦å…¨éƒ¨æ­£ç¢ºå¯¦ç¾ã€‚å¦‚æœä»»ä½•ä¸€é …æœªå¯¦ç¾ã€å¯¦ç¾éŒ¯èª¤ã€æˆ–èˆ‡æè¿°ä¸ç¬¦ï¼Œè«‹æŒ‡å‡ºå…·é«”æª”æ¡ˆã€è¡Œè™Ÿã€éŒ¯èª¤å…§å®¹ï¼Œä»¥åŠæ­£ç¢ºçš„å¯¦ç¾æ–¹å¼ï¼šã€

[è²¼ä¸Šä¸Šè¿° 15 å€‹æª¢æŸ¥æŒ‡ä»¤] 



ğŸ”§ å¸¸è¦‹é™·é˜±èˆ‡é©—è­‰é‡é»
ç‰¹å¾µé †åºé™·é˜±
* å•é¡Œ: è¨“ç·´æ™‚ç‰¹å¾µé †åº vs æ¨ç†æ™‚ç‰¹å¾µé †åºä¸ä¸€è‡´
* é©—è­‰: åŸ·è¡Œ python scripts/verify_feature_order.py æ‡‰é¡¯ç¤º "âœ… ç‰¹å¾µé †åºå®Œå…¨åŒ¹é…ï¼"

æ•¸æ“šé¡å‹é™·é˜±
* å•é¡Œ: XGBoost ä½¿ç”¨ float64ï¼ŒONNX ä½¿ç”¨ float32ï¼Œç²¾åº¦å·®ç•°å°è‡´é æ¸¬ç¿»è½‰
* é©—è­‰: validate_conversion() æ‡‰é¡¯ç¤ºæœ€å¤§å·®ç•° < 1e-5

è¼¸å…¥ shape é™·é˜±
* å•é¡Œ: ONNX æ¨¡å‹æœŸæœ› (N, 31) ä½†å‚³å…¥ (31,) æˆ– (1, 31, 1)
* é©—è­‰: check_onnx_compatibility.py æ‡‰é€šéæ¨ç†æ¸¬è©¦

å›é€€æ©Ÿåˆ¶é™·é˜±
* å•é¡Œ: ONNX è¼‰å…¥å¤±æ•—æ™‚æ²’æœ‰æ­£ç¢ºå›é€€åˆ° XGBoost
* é©—è­‰: åˆªé™¤ .onnx æª”æ¡ˆå¾Œï¼Œç³»çµ±æ‡‰æ­£å¸¸é‹è¡Œä¸¦é¡¯ç¤º "âš ï¸ ONNX è¼‰å…¥å¤±æ•—ï¼Œå›é€€åˆ° XGBoost"

âœ… å®Œæ•´é©—è­‰æµç¨‹

# 1. å®‰è£ä¾è³´
pip install onnxruntime onnxmltools

# 2. è½‰æ›æ¨¡å‹
python scripts/convert_xgboost_to_onnx.py

# 3. é©—è­‰ç‰¹å¾µé †åº
python scripts/verify_feature_order.py

# 4. æª¢æŸ¥ç›¸å®¹æ€§  
python scripts/check_onnx_compatibility.py

# 5. æ¸¬è©¦å›é€€æ©Ÿåˆ¶
mv data/models/model.onnx data/models/model.onnx.bak
python -c "from src.ml.predictor import MLPredictor; p = MLPredictor('data/models/xgboost_model.pkl')"
mv data/models/model.onnx.bak data/models/model.onnx

# 6. æ•´åˆæ¸¬è©¦
python tests/test_onnx_integration.py  # éœ€è¦å‰µå»ºæ­¤æ¸¬è©¦