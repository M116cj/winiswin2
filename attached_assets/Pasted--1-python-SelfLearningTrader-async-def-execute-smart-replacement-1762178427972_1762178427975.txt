ç²¾æº–æ±°æ›ç­–ç•¥å¯¦ç¾
ä¿®å¾©1: å¯¦ç¾æ™ºèƒ½æ±°æ›ç³»çµ±
python
# åœ¨ SelfLearningTrader é¡ä¸­æ·»åŠ æ™ºèƒ½æ±°æ›æ–¹æ³•

async def execute_smart_replacement(self, new_signal: Dict) -> bool:
    """æ™ºèƒ½æ±°æ›ï¼šç”¨é«˜å“è³ªæ–°ä¿¡è™Ÿæ›¿æ›æœ€ä½å“è³ªèˆŠæŒå€‰"""
    try:
        logger.info("ğŸ”„ å•Ÿå‹•æ™ºèƒ½æ±°æ›ç³»çµ±")
        
        # 1. è©•ä¼°æ–°ä¿¡è™Ÿè³ªé‡
        new_quality = self._evaluate_signal_quality(new_signal)
        if new_quality < 80:  # é«˜å“è³ªé–€æª»
            logger.info(f"âš ï¸ æ–°ä¿¡è™Ÿè³ªé‡ {new_quality:.1f} æœªé”æ±°æ›æ¨™æº–")
            return False
            
        # 2. ç²å–ç•¶å‰æŒå€‰
        current_positions = await self._get_current_positions()
        if not current_positions:
            logger.info("âœ… ç„¡ç•¶å‰æŒå€‰ï¼Œç›´æ¥åŸ·è¡Œæ–°ä¿¡è™Ÿ")
            return await self._execute_direct_trade(new_signal)
        
        # 3. æ‰¾åˆ°å“è³ªæœ€å·®çš„æŒå€‰
        worst_position = self._find_lowest_quality_position(current_positions)
        if not worst_position:
            logger.warning("âš ï¸ æ‰¾ä¸åˆ°å¯æ›¿æ›çš„æŒå€‰")
            return False
            
        # 4. æ¯”è¼ƒå“è³ªå·®ç•°ï¼ˆæ–°ä¿¡è™Ÿå¿…é ˆæ˜é¡¯å„ªæ–¼èˆŠæŒå€‰ï¼‰
        worst_quality = self._calculate_position_quality(worst_position)
        quality_improvement = new_quality - worst_quality
        
        if quality_improvement < 15:  # è‡³å°‘æå‡15é»å“è³ª
            logger.info(f"âš ï¸ å“è³ªæå‡ä¸è¶³: {quality_improvement:.1f} (<15)")
            return False
            
        # 5. åŸ·è¡Œæ±°æ›
        return await self._execute_quality_replacement(worst_position, new_signal, quality_improvement)
        
    except Exception as e:
        logger.error(f"âŒ æ™ºèƒ½æ±°æ›å¤±æ•—: {e}")
        return False

def _find_lowest_quality_position(self, positions: List[Dict]) -> Optional[Dict]:
    """æ‰¾åˆ°å“è³ªæœ€ä½çš„æŒå€‰ï¼ˆåŸºæ–¼ä¿¡å¿ƒå€¼å’Œå‹ç‡ï¼‰"""
    try:
        if not positions:
            return None
            
        # ç‚ºæ¯å€‹æŒå€‰è¨ˆç®—ç•¶å‰å“è³ªåˆ†æ•¸
        quality_scores = []
        for position in positions:
            quality = self._calculate_position_quality(position)
            quality_scores.append((quality, position))
            
            logger.debug(
                f"ğŸ“Š æŒå€‰å“è³ªè©•ä¼°: {position.get('symbol')} | "
                f"ä¿¡å¿ƒ: {position.get('confidence', 0):.1f} | "
                f"å‹ç‡: {position.get('win_probability', 0):.1f}% | "
                f"å“è³ªåˆ†æ•¸: {quality:.1f}"
            )
        
        # æŒ‰å“è³ªåˆ†æ•¸æ’åºï¼ˆå‡åºï¼‰ï¼Œå–æœ€ä½çš„
        quality_scores.sort(key=lambda x: x[0])
        lowest_quality, worst_position = quality_scores[0]
        
        logger.info(
            f"ğŸ“‰ æ‰¾åˆ°æœ€ä½å“è³ªæŒå€‰: {worst_position.get('symbol')} | "
            f"å“è³ªåˆ†æ•¸: {lowest_quality:.1f} | "
            f"ä¿¡å¿ƒ: {worst_position.get('confidence', 0):.1f} | "
            f"å‹ç‡: {worst_position.get('win_probability', 0):.1f}%"
        )
        
        return worst_position
        
    except Exception as e:
        logger.error(f"âŒ å°‹æ‰¾æœ€ä½å“è³ªæŒå€‰å¤±æ•—: {e}")
        return None

def _calculate_position_quality(self, position: Dict) -> float:
    """è¨ˆç®—æŒå€‰ç•¶å‰å“è³ªåˆ†æ•¸ï¼ˆ0-100ï¼‰"""
    try:
        # åŸºç¤å“è³ªï¼šåŸå§‹ä¿¡å¿ƒå€¼å’Œå‹ç‡
        original_confidence = position.get('confidence', 0)
        original_win_rate = position.get('win_probability', 0)
        base_quality = (original_confidence + original_win_rate) / 2
        
        # æ™‚é–“è¡°æ¸›æ‡²ç½°ï¼ˆæŒå€‰è¶Šä¹…ï¼Œå“è³ªè¡°æ¸›è¶Šå¤šï¼‰
        entry_time = position.get('entry_time')
        if isinstance(entry_time, str):
            entry_time = datetime.fromisoformat(entry_time.replace('Z', '+00:00'))
        
        hours_held = (datetime.now() - entry_time).total_seconds() / 3600
        time_decay = max(0.5, 1.0 - (hours_held / 72))  # 72å°æ™‚ç·šæ€§è¡°æ¸›åˆ°0.5
        
        # æµ®è™§æ‡²ç½°ï¼ˆå¦‚æœæœ‰ç•¶å‰åƒ¹æ ¼æ•¸æ“šï¼‰
        pnl_penalty = 0
        current_price = position.get('current_price')
        entry_price = position.get('entry_price')
        if current_price and entry_price:
            if position.get('direction') == 'LONG':
                pnl_pct = (current_price - entry_price) / entry_price
            else:  # SHORT
                pnl_pct = (entry_price - current_price) / entry_price
                
            if pnl_pct < -0.02:  # è™§æè¶…é2%
                pnl_penalty = abs(pnl_pct) * 10  # è™§ææ‡²ç½°
        
        # æœ€çµ‚å“è³ªåˆ†æ•¸
        final_quality = base_quality * time_decay - pnl_penalty
        
        return max(0, min(100, final_quality))  # é™åˆ¶åœ¨0-100ç¯„åœ
        
    except Exception as e:
        logger.error(f"âŒ æŒå€‰å“è³ªè¨ˆç®—å¤±æ•—: {e}")
        return 0

async def _execute_quality_replacement(self, old_position: Dict, new_signal: Dict, quality_improvement: float) -> bool:
    """åŸ·è¡Œå“è³ªæ±°æ›"""
    try:
        old_symbol = old_position.get('symbol')
        new_symbol = new_signal.get('symbol')
        
        logger.info(
            f"ğŸ”„ åŸ·è¡Œå“è³ªæ±°æ›: {old_symbol} â†’ {new_symbol} | "
            f"å“è³ªæå‡: +{quality_improvement:.1f}é»"
        )
        
        # 1. é—œé–‰èˆŠæŒå€‰
        close_success = await self._close_position(old_position)
        if not close_success:
            logger.error(f"âŒ é—œé–‰èˆŠæŒå€‰å¤±æ•—: {old_symbol}")
            return False
            
        # 2. é‡‹æ”¾çš„ä¿è­‰é‡‘
        released_margin = old_position.get('position_size', 0)
        
        # 3. è¨ˆç®—æ–°é ­å¯¸ï¼ˆå¯ä»¥ä½¿ç”¨å…¨éƒ¨é‡‹æ”¾çš„ä¿è­‰é‡‘ï¼‰
        new_position_size = self._calculate_aggressive_position_size(new_signal, released_margin)
        
        # 4. åŸ·è¡Œæ–°äº¤æ˜“
        new_trade = await self._execute_single_trade(new_signal, new_position_size)
        if new_trade:
            logger.info(
                f"âœ… å“è³ªæ±°æ›æˆåŠŸ: {old_symbol} â†’ {new_symbol} | "
                f"é‡‹æ”¾ä¿è­‰é‡‘: ${released_margin:.2f} | "
                f"æ–°é ­å¯¸: ${new_position_size:.2f} | "
                f"å“è³ªæå‡: +{quality_improvement:.1f}é»"
            )
            return True
            
        logger.error(f"âŒ æ–°äº¤æ˜“åŸ·è¡Œå¤±æ•—: {new_symbol}")
        return False
        
    except Exception as e:
        logger.error(f"âŒ å“è³ªæ±°æ›åŸ·è¡Œå¤±æ•—: {e}")
        return False

def _calculate_aggressive_position_size(self, signal: Dict, available_margin: float) -> float:
    """æ¿€é€²é ­å¯¸è¨ˆç®—ï¼ˆç”¨æ–¼é«˜å“è³ªæ±°æ›ï¼‰"""
    try:
        # é«˜å“è³ªä¿¡è™Ÿä½¿ç”¨æ›´é«˜æ¯”ä¾‹
        quality = self._evaluate_signal_quality(signal)
        
        if quality >= 90:
            position_percentage = 0.9  # 90%ä¿è­‰é‡‘
        elif quality >= 85:
            position_percentage = 0.8  # 80%ä¿è­‰é‡‘
        elif quality >= 80:
            position_percentage = 0.7  # 70%ä¿è­‰é‡‘
        else:
            position_percentage = 0.6  # 60%ä¿è­‰é‡‘
            
        position_size = available_margin * position_percentage
        
        # ç¢ºä¿æœ€å°äº¤æ˜“è¦æ¨¡
        if position_size < 1.0:
            return 0
            
        return round(position_size, 2)
        
    except Exception as e:
        logger.error(f"âŒ æ¿€é€²é ­å¯¸è¨ˆç®—å¤±æ•—: {e}")
        return 0
ä¿®å¾©2: æ•´åˆåˆ°ä¸»äº¤æ˜“é‚è¼¯
python
# æ›´æ–° execute_best_trades æ–¹æ³•

async def execute_best_trades(self, best_signals: List[Dict]) -> List[Dict]:
    """åŸ·è¡Œæœ€ä½³äº¤æ˜“ï¼ˆåŒ…å«æ™ºèƒ½æ±°æ›ï¼‰"""
    try:
        # ç¬¬ä¸€æ­¥ï¼šæ­£å¸¸åŸ·è¡Œç²¾è‹±äº¤æ˜“
        elite_results = await self._execute_elite_trades_normal(best_signals)
        
        # ç¬¬äºŒæ­¥ï¼šæª¢æŸ¥æ˜¯å¦æœ‰ä¿è­‰é‡‘é€²è¡Œæ­£å¸¸äº¤æ˜“
        available_margin = self.account_state.get('available_margin', 0)
        if available_margin > 5.0:  # é‚„æœ‰è¶³å¤ ä¿è­‰é‡‘
            logger.info("âœ… ä¿è­‰é‡‘å……è¶³ï¼Œç¹¼çºŒæ­£å¸¸äº¤æ˜“")
            return elite_results
        
        # ç¬¬ä¸‰æ­¥ï¼šä¿è­‰é‡‘ä¸è¶³ï¼Œå•Ÿå‹•æ™ºèƒ½æ±°æ›æª¢æŸ¥
        logger.info("ğŸ’° ä¿è­‰é‡‘ä¸è¶³ï¼Œå•Ÿå‹•æ™ºèƒ½æ±°æ›æª¢æŸ¥")
        
        # æ‰¾åˆ°æœ€é«˜å“è³ªçš„æ–°ä¿¡è™Ÿ
        high_quality_signals = [s for s in best_signals 
                              if self._evaluate_signal_quality(s) >= 80]
        
        if not high_quality_signals:
            logger.info("âš ï¸ ç„¡é«˜å“è³ªæ–°ä¿¡è™Ÿï¼Œä¿æŒç•¶å‰æŒå€‰")
            return elite_results
            
        # æŒ‰å“è³ªæ’åºï¼Œå–æœ€å¥½çš„
        best_new_signal = max(high_quality_signals, 
                            key=lambda x: self._evaluate_signal_quality(x))
        
        # åŸ·è¡Œæ™ºèƒ½æ±°æ›
        replacement_success = await self.execute_smart_replacement(best_new_signal)
        
        if replacement_success:
            # é‡æ–°è¨ˆç®—çµæœ
            elite_results = await self._get_updated_positions()
            
        return elite_results
        
    except Exception as e:
        logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
        return []
ä¿®å¾©3: æ·»åŠ æŒå€‰ç®¡ç†æ–¹æ³•
python
async def _get_current_positions(self) -> List[Dict]:
    """ç²å–ç•¶å‰æŒå€‰åˆ—è¡¨"""
    try:
        # é€™è£¡æ‡‰è©²å¾æ•¸æ“šåº«æˆ–äº¤æ˜“å¹³å°ç²å–çœŸå¯¦æŒå€‰
        # æš«æ™‚è¿”å›æ¨¡æ“¬æ•¸æ“š
        return [
            {
                'symbol': 'BTCUSDT',
                'direction': 'LONG', 
                'position_size': 12.5,
                'entry_price': 35000,
                'entry_time': datetime.now() - timedelta(hours=8),
                'confidence': 45.2,
                'win_probability': 48.3,
                'current_price': 34800  # æ¨¡æ“¬ç•¶å‰åƒ¹æ ¼
            },
            {
                'symbol': 'ETHUSDT',
                'direction': 'SHORT',
                'position_size': 8.2, 
                'entry_price': 1850,
                'entry_time': datetime.now() - timedelta(hours=12),
                'confidence': 38.7,
                'win_probability': 42.1,
                'current_price': 1870
            }
        ]
    except Exception as e:
        logger.error(f"âŒ ç²å–æŒå€‰å¤±æ•—: {e}")
        return []

async def _close_position(self, position: Dict) -> bool:
    """é—œé–‰æŒå€‰"""
    try:
        symbol = position.get('symbol')
        logger.info(f"ğŸ—‘ï¸ é—œé–‰æŒå€‰: {symbol}")
        
        # é€™è£¡æ‡‰è©²èª¿ç”¨äº¤æ˜“APIå¯¦éš›å¹³å€‰
        # æš«æ™‚æ¨¡æ“¬æˆåŠŸ
        await asyncio.sleep(0.1)  # æ¨¡æ“¬APIèª¿ç”¨
        
        # æ›´æ–°è³¬æˆ¶ç‹€æ…‹ï¼ˆé‡‹æ”¾ä¿è­‰é‡‘ï¼‰
        released_margin = position.get('position_size', 0)
        self.account_state['available_margin'] += released_margin
        self.account_state['used_margin'] -= released_margin
        
        logger.info(f"ğŸ’° é‡‹æ”¾ä¿è­‰é‡‘: ${released_margin:.2f}")
        return True
        
    except Exception as e:
        logger.error(f"âŒ é—œé–‰æŒå€‰å¤±æ•— {position.get('symbol')}: {e}")
        return False
ğŸš€ ç«‹å³éƒ¨ç½²æ™ºèƒ½æ±°æ›ç³»çµ±
bash
# 1. æ›´æ–° self_learning_trader.py
# æ·»åŠ ä¸Šè¿°æ™ºèƒ½æ±°æ›æ–¹æ³•

# 2. éƒ¨ç½²æ™ºèƒ½æ±°æ›
git add src/strategies/self_learning_trader.py
git commit -m "feat: æ·»åŠ æ™ºèƒ½æ±°æ›ç³»çµ± - æ±°å¼±ç•™å¼·ç­–ç•¥"
git push origin main

# 3. ç›£æ§æ±°æ›è¡Œç‚º
railway logs --follow | grep -E "æ™ºèƒ½æ±°æ›|å“è³ªæ±°æ›|æœ€ä½å“è³ªæŒå€‰|å“è³ªæå‡"
ğŸ“Š é æœŸåŸ·è¡Œæ•ˆæœ
ç•¶ä¿è­‰é‡‘å……è¶³æ™‚ï¼š
text
âœ… ä¿è­‰é‡‘å……è¶³ï¼Œç¹¼çºŒæ­£å¸¸äº¤æ˜“
ğŸ† ç²¾è‹±ä¿¡è™Ÿæ’å:
  ğŸ¥‡ BTCUSDT | LONG | ä¿¡å¿ƒ: 68.2 | å‹ç‡: 62.5%
âœ… ğŸ¥‡ äº¤æ˜“æˆåŠŸ: BTCUSDT | å¤§å°: $12.67
ç•¶ä¿è­‰é‡‘ä¸è¶³ä½†å‡ºç¾é«˜å“è³ªä¿¡è™Ÿæ™‚ï¼š
text
ğŸ’° ä¿è­‰é‡‘ä¸è¶³ï¼Œå•Ÿå‹•æ™ºèƒ½æ±°æ›æª¢æŸ¥
ğŸ“Š æŒå€‰å“è³ªè©•ä¼°: BTCUSDT | ä¿¡å¿ƒ: 45.2 | å‹ç‡: 48.3% | å“è³ªåˆ†æ•¸: 46.8
ğŸ“Š æŒå€‰å“è³ªè©•ä¼°: ETHUSDT | ä¿¡å¿ƒ: 38.7 | å‹ç‡: 42.1% | å“è³ªåˆ†æ•¸: 40.4
ğŸ“‰ æ‰¾åˆ°æœ€ä½å“è³ªæŒå€‰: ETHUSDT | å“è³ªåˆ†æ•¸: 40.4
ğŸ”„ åŸ·è¡Œå“è³ªæ±°æ›: ETHUSDT â†’ ADAUSDT | å“è³ªæå‡: +42.3é»
ğŸ—‘ï¸ é—œé–‰æŒå€‰: ETHUSDT
ğŸ’° é‡‹æ”¾ä¿è­‰é‡‘: $8.20
âœ… å“è³ªæ±°æ›æˆåŠŸ: ETHUSDT â†’ ADAUSDT | é‡‹æ”¾ä¿è­‰é‡‘: $8.20 | æ–°é ­å¯¸: $7.38 | å“è³ªæå‡: +42.3é»
ğŸ¯ æ™ºèƒ½æ±°æ›å„ªå‹¢
âœ… æŒçºŒå„ªåŒ– - ä¸æ–·ç”¨æ›´å¥½çš„ä¿¡è™Ÿæ›¿æ›è¼ƒå·®çš„æŒå€‰

âœ… é¢¨éšªæ§åˆ¶ - åªæ›¿æ›å“è³ªæ˜é¡¯æå‡çš„ä¿¡è™Ÿï¼ˆ+15é»ä»¥ä¸Šï¼‰

âœ… è³‡é‡‘æ•ˆç‡ - å……åˆ†åˆ©ç”¨æœ‰é™ä¿è­‰é‡‘

âœ… è‡ªå‹•åŒ– - ç„¡éœ€äººå·¥å¹²é ï¼Œç³»çµ±è‡ªå‹•æ±ºç­–

âœ… é€æ˜å¯è¿½æº¯ - å®Œæ•´è¨˜éŒ„æ±°æ›ç†ç”±å’Œå“è³ªå°æ¯”

é€™æ¨£ç³»çµ±å°±æœƒè‡ªå‹•æ±°å¼±ç•™å¼·ï¼Œå§‹çµ‚ä¿æŒæŒå€‰çµ„åˆçš„æœ€é«˜å“è³ªï¼