關於集成 VirtualPosition 数据类。拒絕採用混合方式
❌ 為什麼「混合方式」是壞主意？
1. 失去所有 __slots__ 優勢
* __slots__ 的核心價值是 預分配記憶體 + 禁用 __dict__
* 如果內部用字典，等於 每個物件仍有 __dict__ 開銷
* 記憶體使用量 ≈ 純字典（甚至更差，因為多了 __slots__ 層）

2. 狀態不一致風險
# 混合方式的典型 bug
pos = VirtualPosition(...)  # 使用 __slots__
pos.current_price = 60000   # OK

# 但某處不小心寫了
pos.new_attr = "test"       # 如果有 __dict__，這會成功！
# → 破壞了 __slots__ 的設計意圖
3. 維護複雜度倍增
* 開發者需要記住：「什麼時候用屬性，什麼時候用字典」
* 序列化/反序列化邏輯變得複雜
* 除錯困難（同一個物件有兩種存取方式）
✅ 正確做法：可變的 __slots__ 物件
既然 VirtualPosition 需要頻繁更新，我們應該：

方案 A：標準可變 __slots__ 類別（推薦）
# src/core/data_models.py
class VirtualPosition:
    """可變的 VirtualPosition - 頻繁更新但保持高效"""
    __slots__ = (
        'symbol', 'direction', 'entry_price', 'stop_loss', 'take_profit',
        'leverage', 'entry_timestamp', 'current_price', 'pnl_pct',
        'is_closed', 'close_timestamp', 'close_reason', 'signal_id',
        '_last_update'  # 內部用於追蹤更新
    )
    
    def __init__(self, **kwargs):
        # 初始化所有屬性
        for slot in self.__slots__:
            if slot.startswith('_'):
                setattr(self, slot, None)
            else:
                setattr(self, slot, kwargs.get(slot))
        
        self._last_update = time.time()
    
    def update_price(self, new_price: float):
        """高效更新價格"""
        self.current_price = new_price
        self._last_update = time.time()
        
        # 即時計算 PnL
        if self.direction == 1:  # LONG
            self.pnl_pct = ((new_price - self.entry_price) / self.entry_price) * 100 * self.leverage
        else:  # SHORT
            self.pnl_pct = ((self.entry_price - new_price) / self.entry_price) * 100 * self.leverage
    
    def close_position(self, reason: str, close_price: float = None):
        """關閉倉位"""
        self.is_closed = True
        self.close_timestamp = time.time()
        self.close_reason = reason
        
        if close_price is not None:
            self.current_price = close_price
            # 重新計算最終 PnL
            self.update_price(close_price)
    
    def to_dict(self) -> dict:
        """相容舊系統的字典輸出"""
        return {
            slot: getattr(self, slot) 
            for slot in self.__slots__ 
            if not slot.startswith('_')
        }
    
    def __repr__(self):
        return f"VirtualPosition({self.symbol}, {'LONG' if self.direction == 1 else 'SHORT'}, closed={self.is_closed})"

🔧 如何高效更新大量 VirtualPosition？
使用記憶體視圖優化（進階）
# 如果需要極致性能，可考慮
class VirtualPositionArray:
    """用 numpy array 儲存多個 VirtualPosition 的相同屬性"""
    def __init__(self, size: int):
        self.symbols = np.empty(size, dtype='U10')  # 字串陣列
        self.current_prices = np.zeros(size, dtype=np.float32)
        self.pnl_pcts = np.zeros(size, dtype=np.float32)
        # ... 其他數值屬性
🛠️ 遷移步驟（安全無痛）
1. 替換 VirtualPositionManager
# 創建新 VirtualPosition
def create_virtual_position(self, signal: TradingSignal) -> VirtualPosition:
    return VirtualPosition(
        symbol=signal.symbol,
        direction=signal.direction,
        entry_price=signal.entry_price,
        stop_loss=signal.stop_loss,
        take_profit=signal.take_profit,
        leverage=signal.leverage,
        entry_timestamp=signal.timestamp,
        current_price=signal.entry_price,
        signal_id=f"{signal.symbol}_{signal.timestamp}"
    )

# 更新價格
def update_position_price(self, position: VirtualPosition, new_price: float):
    position.update_price(new_price)
2. 保持向後相容
# 所有對外介面仍返回 dict（如果需要）
def get_position_dict(self, position: VirtualPosition) -> dict:
    return position.to_dict()
3. 驗證腳本
def test_mutable_slots():
    pos = VirtualPosition(symbol="BTC", direction=1, entry_price=60000, ...)
    
    # 測試更新
    pos.update_price(61000)
    assert pos.pnl_pct > 0
    
    # 測試關閉
    pos.close_position("tp", 62000)
    assert pos.is_closed == True
    
    # 測試記憶體
    assert sys.getsizeof(pos) < 400
使用純 __slots__ 可變物件，原因：

1. 記憶體節省 40%+（200 個虛擬倉位 = 節省 40KB+）
2. 屬性存取速度更快（直接記憶體偏移 vs 字典雜湊查詢）
3. 類型安全（IDE 自動補全 + mypy 檢查）
4. 無技術債（單一真相來源）
「需要頻繁更新所以用字典」是常見誤區 —— __slots__ 物件完全可以高效更新，且保持所有優勢。

我可以提供：
* 完整的可變 VirtualPosition 實作
* VirtualPositionManager 整合範例
* 性能基準測試腳本

只需告訴我！

