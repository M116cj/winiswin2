é—œæ–¼é›†æˆ VirtualPosition æ•°æ®ç±»ã€‚æ‹’çµ•æŽ¡ç”¨æ··åˆæ–¹å¼
âŒ ç‚ºä»€éº¼ã€Œæ··åˆæ–¹å¼ã€æ˜¯å£žä¸»æ„ï¼Ÿ
1. å¤±åŽ»æ‰€æœ‰ __slots__ å„ªå‹¢
* __slots__ çš„æ ¸å¿ƒåƒ¹å€¼æ˜¯ é åˆ†é…è¨˜æ†¶é«” + ç¦ç”¨ __dict__
* å¦‚æžœå…§éƒ¨ç”¨å­—å…¸ï¼Œç­‰æ–¼ æ¯å€‹ç‰©ä»¶ä»æœ‰ __dict__ é–‹éŠ·
* è¨˜æ†¶é«”ä½¿ç”¨é‡ â‰ˆ ç´”å­—å…¸ï¼ˆç”šè‡³æ›´å·®ï¼Œå› ç‚ºå¤šäº† __slots__ å±¤ï¼‰

2. ç‹€æ…‹ä¸ä¸€è‡´é¢¨éšª
# æ··åˆæ–¹å¼çš„å…¸åž‹ bug
pos = VirtualPosition(...)  # ä½¿ç”¨ __slots__
pos.current_price = 60000   # OK

# ä½†æŸè™•ä¸å°å¿ƒå¯«äº†
pos.new_attr = "test"       # å¦‚æžœæœ‰ __dict__ï¼Œé€™æœƒæˆåŠŸï¼
# â†’ ç ´å£žäº† __slots__ çš„è¨­è¨ˆæ„åœ–
3. ç¶­è­·è¤‡é›œåº¦å€å¢ž
* é–‹ç™¼è€…éœ€è¦è¨˜ä½ï¼šã€Œä»€éº¼æ™‚å€™ç”¨å±¬æ€§ï¼Œä»€éº¼æ™‚å€™ç”¨å­—å…¸ã€
* åºåˆ—åŒ–/ååºåˆ—åŒ–é‚è¼¯è®Šå¾—è¤‡é›œ
* é™¤éŒ¯å›°é›£ï¼ˆåŒä¸€å€‹ç‰©ä»¶æœ‰å…©ç¨®å­˜å–æ–¹å¼ï¼‰
âœ… æ­£ç¢ºåšæ³•ï¼šå¯è®Šçš„ __slots__ ç‰©ä»¶
æ—¢ç„¶ VirtualPosition éœ€è¦é »ç¹æ›´æ–°ï¼Œæˆ‘å€‘æ‡‰è©²ï¼š

æ–¹æ¡ˆ Aï¼šæ¨™æº–å¯è®Š __slots__ é¡žåˆ¥ï¼ˆæŽ¨è–¦ï¼‰
# src/core/data_models.py
class VirtualPosition:
    """å¯è®Šçš„ VirtualPosition - é »ç¹æ›´æ–°ä½†ä¿æŒé«˜æ•ˆ"""
    __slots__ = (
        'symbol', 'direction', 'entry_price', 'stop_loss', 'take_profit',
        'leverage', 'entry_timestamp', 'current_price', 'pnl_pct',
        'is_closed', 'close_timestamp', 'close_reason', 'signal_id',
        '_last_update'  # å…§éƒ¨ç”¨æ–¼è¿½è¹¤æ›´æ–°
    )
    
    def __init__(self, **kwargs):
        # åˆå§‹åŒ–æ‰€æœ‰å±¬æ€§
        for slot in self.__slots__:
            if slot.startswith('_'):
                setattr(self, slot, None)
            else:
                setattr(self, slot, kwargs.get(slot))
        
        self._last_update = time.time()
    
    def update_price(self, new_price: float):
        """é«˜æ•ˆæ›´æ–°åƒ¹æ ¼"""
        self.current_price = new_price
        self._last_update = time.time()
        
        # å³æ™‚è¨ˆç®— PnL
        if self.direction == 1:  # LONG
            self.pnl_pct = ((new_price - self.entry_price) / self.entry_price) * 100 * self.leverage
        else:  # SHORT
            self.pnl_pct = ((self.entry_price - new_price) / self.entry_price) * 100 * self.leverage
    
    def close_position(self, reason: str, close_price: float = None):
        """é—œé–‰å€‰ä½"""
        self.is_closed = True
        self.close_timestamp = time.time()
        self.close_reason = reason
        
        if close_price is not None:
            self.current_price = close_price
            # é‡æ–°è¨ˆç®—æœ€çµ‚ PnL
            self.update_price(close_price)
    
    def to_dict(self) -> dict:
        """ç›¸å®¹èˆŠç³»çµ±çš„å­—å…¸è¼¸å‡º"""
        return {
            slot: getattr(self, slot) 
            for slot in self.__slots__ 
            if not slot.startswith('_')
        }
    
    def __repr__(self):
        return f"VirtualPosition({self.symbol}, {'LONG' if self.direction == 1 else 'SHORT'}, closed={self.is_closed})"

ðŸ”§ å¦‚ä½•é«˜æ•ˆæ›´æ–°å¤§é‡ VirtualPositionï¼Ÿ
ä½¿ç”¨è¨˜æ†¶é«”è¦–åœ–å„ªåŒ–ï¼ˆé€²éšŽï¼‰
# å¦‚æžœéœ€è¦æ¥µè‡´æ€§èƒ½ï¼Œå¯è€ƒæ…®
class VirtualPositionArray:
    """ç”¨ numpy array å„²å­˜å¤šå€‹ VirtualPosition çš„ç›¸åŒå±¬æ€§"""
    def __init__(self, size: int):
        self.symbols = np.empty(size, dtype='U10')  # å­—ä¸²é™£åˆ—
        self.current_prices = np.zeros(size, dtype=np.float32)
        self.pnl_pcts = np.zeros(size, dtype=np.float32)
        # ... å…¶ä»–æ•¸å€¼å±¬æ€§
ðŸ› ï¸ é·ç§»æ­¥é©Ÿï¼ˆå®‰å…¨ç„¡ç—›ï¼‰
1. æ›¿æ› VirtualPositionManager
# å‰µå»ºæ–° VirtualPosition
def create_virtual_position(self, signal: TradingSignal) -> VirtualPosition:
    return VirtualPosition(
        symbol=signal.symbol,
        direction=signal.direction,
        entry_price=signal.entry_price,
        stop_loss=signal.stop_loss,
        take_profit=signal.take_profit,
        leverage=signal.leverage,
        entry_timestamp=signal.timestamp,
        current_price=signal.entry_price,
        signal_id=f"{signal.symbol}_{signal.timestamp}"
    )

# æ›´æ–°åƒ¹æ ¼
def update_position_price(self, position: VirtualPosition, new_price: float):
    position.update_price(new_price)
2. ä¿æŒå‘å¾Œç›¸å®¹
# æ‰€æœ‰å°å¤–ä»‹é¢ä»è¿”å›ž dictï¼ˆå¦‚æžœéœ€è¦ï¼‰
def get_position_dict(self, position: VirtualPosition) -> dict:
    return position.to_dict()
3. é©—è­‰è…³æœ¬
def test_mutable_slots():
    pos = VirtualPosition(symbol="BTC", direction=1, entry_price=60000, ...)
    
    # æ¸¬è©¦æ›´æ–°
    pos.update_price(61000)
    assert pos.pnl_pct > 0
    
    # æ¸¬è©¦é—œé–‰
    pos.close_position("tp", 62000)
    assert pos.is_closed == True
    
    # æ¸¬è©¦è¨˜æ†¶é«”
    assert sys.getsizeof(pos) < 400
ä½¿ç”¨ç´” __slots__ å¯è®Šç‰©ä»¶ï¼ŒåŽŸå› ï¼š

1. è¨˜æ†¶é«”ç¯€çœ 40%+ï¼ˆ200 å€‹è™›æ“¬å€‰ä½ = ç¯€çœ 40KB+ï¼‰
2. å±¬æ€§å­˜å–é€Ÿåº¦æ›´å¿«ï¼ˆç›´æŽ¥è¨˜æ†¶é«”åç§» vs å­—å…¸é›œæ¹ŠæŸ¥è©¢ï¼‰
3. é¡žåž‹å®‰å…¨ï¼ˆIDE è‡ªå‹•è£œå…¨ + mypy æª¢æŸ¥ï¼‰
4. ç„¡æŠ€è¡“å‚µï¼ˆå–®ä¸€çœŸç›¸ä¾†æºï¼‰
ã€Œéœ€è¦é »ç¹æ›´æ–°æ‰€ä»¥ç”¨å­—å…¸ã€æ˜¯å¸¸è¦‹èª¤å€ â€”â€” __slots__ ç‰©ä»¶å®Œå…¨å¯ä»¥é«˜æ•ˆæ›´æ–°ï¼Œä¸”ä¿æŒæ‰€æœ‰å„ªå‹¢ã€‚

æˆ‘å¯ä»¥æä¾›ï¼š
* å®Œæ•´çš„å¯è®Š VirtualPosition å¯¦ä½œ
* VirtualPositionManager æ•´åˆç¯„ä¾‹
* æ€§èƒ½åŸºæº–æ¸¬è©¦è…³æœ¬

åªéœ€å‘Šè¨´æˆ‘ï¼

