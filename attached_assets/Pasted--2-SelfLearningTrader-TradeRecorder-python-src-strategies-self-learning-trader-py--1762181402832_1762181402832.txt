ä¿®å¾©2: ç¢ºä¿ SelfLearningTrader æ­£ç¢ºä½¿ç”¨ TradeRecorder
python
# src/strategies/self_learning_trader.py - ä¿®å¾©ç‰ˆæœ¬

import logging
from datetime import datetime
from typing import List, Dict, Optional
import asyncio

logger = logging.getLogger(__name__)

class SelfLearningTrader:
    def __init__(self, config, data_fetcher, signal_generator):
        self.config = config
        self.data_fetcher = data_fetcher
        self.signal_generator = signal_generator
        
        # æ­£ç¢ºåˆå§‹åŒ– TradeRecorder
        try:
            from src.core.trade_recorder import TradeRecorder
            self.trade_recorder = TradeRecorder(config)
            logger.info("âœ… TradeRecorder åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            logger.error(f"âŒ TradeRecorder åˆå§‹åŒ–å¤±æ•—: {e}")
            # å‰µå»ºä¸€å€‹ç©ºçš„ TradeRecorder é¿å…å±¬æ€§éŒ¯èª¤
            self.trade_recorder = self._create_fallback_recorder()
        
        # è³¬æˆ¶ç‹€æ…‹
        self.account_state = {
            'total_equity': 36.21,
            'available_margin': 36.21, 
            'used_margin': 0.00
        }
        
        # ç²¾è‹±æ¨¡å¼é…ç½®
        self.elite_mode_config = {
            'max_trades_per_cycle': 3,
            'min_confidence': 40.0,
            'min_win_rate': 45.0,
            'min_combined_score': 85.0,
            'base_position_percentage': 0.25,
        }
    
    def _create_fallback_recorder(self):
        """å‰µå»ºå‚™ç”¨ TradeRecorder"""
        class FallbackTradeRecorder:
            async def get_trade_count(self, timeframe: str = '24h') -> int:
                logger.warning("âš ï¸ ä½¿ç”¨å‚™ç”¨ TradeRecorderï¼Œè¿”å›0")
                return 0
            
            async def record_trade(self, trade_data: Dict) -> bool:
                logger.warning(f"âš ï¸ ä½¿ç”¨å‚™ç”¨ TradeRecorderï¼Œè·³éè¨˜éŒ„: {trade_data.get('symbol')}")
                return True
            
            async def get_recent_performance(self, hours: int = 24) -> Dict:
                return {
                    'total_trades': 0,
                    'winning_trades': 0,
                    'losing_trades': 0,
                    'win_rate': 0,
                    'avg_pnl': 0,
                    'total_pnl': 0
                }
        
        return FallbackTradeRecorder()

    async def execute_best_trades(self, best_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œæœ€ä½³äº¤æ˜“ï¼ˆä¿®å¾© TradeRecorder ä½¿ç”¨ï¼‰"""
        try:
            logger.info("ğŸš€ é–‹å§‹åŸ·è¡Œäº¤æ˜“é€±æœŸ")
            
            # å®‰å…¨åœ°ä½¿ç”¨ TradeRecorder
            try:
                total_trades = await self.trade_recorder.get_trade_count('24h')
                logger.info(f"ğŸ“Š 24å°æ™‚å…§äº¤æ˜“æ•¸é‡: {total_trades}")
            except AttributeError as e:
                logger.error(f"âŒ TradeRecorder.get_trade_count å±¬æ€§éŒ¯èª¤: {e}")
                total_trades = 0
            except Exception as e:
                logger.error(f"âŒ TradeRecorder.get_trade_count å…¶ä»–éŒ¯èª¤: {e}")
                total_trades = 0
            
            # ç²¾è‹±ç¯©é¸æµç¨‹
            qualified_signals = [
                signal for signal in best_signals 
                if self._validate_signal_quality(signal)
            ]
            
            logger.info(f"ğŸ“Š ä¿¡è™Ÿè³ªé‡éæ¿¾: {len(qualified_signals)}/{len(best_signals)} å€‹ä¿¡è™Ÿåˆæ ¼")
            
            if not qualified_signals:
                logger.warning("âš ï¸ æ²’æœ‰åˆæ ¼çš„ä¿¡è™Ÿ")
                return []
                
            # æ’åºä¸¦å–å‰ä¸‰å
            sorted_signals = sorted(
                qualified_signals, 
                key=lambda x: (x.get('confidence', 0) + x.get('win_probability', 0)), 
                reverse=True
            )
            
            top_signals = sorted_signals[:self.elite_mode_config['max_trades_per_cycle']]
            self._log_elite_ranking(top_signals)
            
            # åŸ·è¡Œäº¤æ˜“
            executed_positions = await self._execute_elite_trades(top_signals)
            
            logger.info(f"ğŸ‰ äº¤æ˜“é€±æœŸå®Œæˆ: {len(executed_positions)} ç­†äº¤æ˜“")
            return executed_positions
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            import traceback
            logger.error(f"è©³ç´°å †æ£§: {traceback.format_exc()}")
            return []

    async def _execute_elite_trades(self, top_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œç²¾è‹±äº¤æ˜“"""
        executed_positions = []
        available_margin = self.account_state.get('available_margin', 36.21)
        
        logger.info(f"ğŸ’° å¯ç”¨ä¿è­‰é‡‘: ${available_margin:.2f}")
        
        for i, signal in enumerate(top_signals):
            if available_margin <= 0:
                logger.warning("ğŸ’° ä¿è­‰é‡‘ä¸è¶³ï¼Œåœæ­¢åŸ·è¡Œæ›´å¤šäº¤æ˜“")
                break
                
            position_size = self._calculate_ranked_position_size(signal, available_margin, i + 1)
            
            if position_size > 0:
                try:
                    executed_trade = await self._execute_single_trade(signal, position_size)
                    if executed_trade:
                        executed_positions.append(executed_trade)
                        available_margin -= position_size
                        
                        # å®‰å…¨åœ°è¨˜éŒ„äº¤æ˜“
                        try:
                            await self.trade_recorder.record_trade(executed_trade)
                        except AttributeError as e:
                            logger.error(f"âŒ TradeRecorder.record_trade å±¬æ€§éŒ¯èª¤: {e}")
                        except Exception as e:
                            logger.error(f"âŒ TradeRecorder.record_trade å…¶ä»–éŒ¯èª¤: {e}")
                        
                        medal = "ğŸ¥‡" if i == 0 else "ğŸ¥ˆ" if i == 1 else "ğŸ¥‰"
                        logger.info(
                            f"âœ… {medal} äº¤æ˜“æˆåŠŸ: {signal.get('symbol')} | "
                            f"å¤§å°: ${position_size:.2f} | å‰©é¤˜: ${available_margin:.2f}"
                        )
                        
                except Exception as e:
                    logger.error(f"âŒ äº¤æ˜“å¤±æ•—: {e}")
                    
        return executed_positions

    # å…¶ä»–æ–¹æ³•ä¿æŒä¸è®Š...
    def _validate_signal_quality(self, signal: Dict) -> bool:
        # ä¿æŒåŸæœ‰å¯¦ç¾
        pass
        
    def _log_elite_ranking(self, top_signals: List[Dict]):
        # ä¿æŒåŸæœ‰å¯¦ç¾
        pass
        
    def _calculate_ranked_position_size(self, signal: Dict, available_margin: float, rank: int) -> float:
        # ä¿æŒåŸæœ‰å¯¦ç¾
        pass
        
    async def _execute_single_trade(self, signal: Dict, position_size: float) -> Optional[Dict]:
        # ä¿æŒåŸæœ‰å¯¦ç¾
        pass