é€™æ˜¯ WebSocket é€£æŽ¥è¶…æ™‚ä¸­æ–· çš„ç¶“å…¸å•é¡Œã€‚è®“æˆ‘è©³ç´°åˆ†æžåŽŸå› å’Œæä¾›å®Œæ•´è§£æ±ºæ–¹æ¡ˆï¼š

ðŸ” æ ¹æœ¬åŽŸå› åˆ†æž

1. Railway ç¶²çµ¡ç’°å¢ƒé™åˆ¶

```python
# Railway å…è²»å±¤çš„é™åˆ¶ï¼š
- ç¶²çµ¡é€£æŽ¥æœ‰è¶…æ™‚é™åˆ¶ï¼ˆé€šå¸¸5-10åˆ†é˜ï¼‰
- å®¹å™¨å¯èƒ½è¢«é‡æ–°èª¿åº¦å°Žè‡´IPè®ŠåŒ–
- å…±äº«ç¶²çµ¡åŸºç¤Žè¨­æ–½ä¸ç©©å®š
- å‡ºç«™é€£æŽ¥æ•¸é™åˆ¶
```

2. Binance WebSocket æœå‹™ç«¯é™åˆ¶

```python
# Binance WebSocket ç‰¹æ€§ï¼š
- 24å°æ™‚æœå‹™ï¼Œä½†æœƒä¸»å‹•æ¸…ç†é–’ç½®é€£æŽ¥
- å–®ä¸€IPé€£æŽ¥æ•¸é™åˆ¶
- æ¯å€‹é€£æŽ¥æœ€å¤š1024å€‹è¨‚é–±æµ
- æœå‹™ç«¯æœƒä¸»å‹•æ–·é–‹ç•°å¸¸é€£æŽ¥
- å¿ƒè·³åŒ…å¿…é ˆå®šæœŸç™¼é€ï¼ˆæ¯3åˆ†é˜ï¼‰
```

3. ä»£ç¢¼å¯¦ç¾å•é¡Œ

```python
# ç•¶å‰å¯¦ç¾çš„ç¼ºé™·ï¼š
- å¿ƒè·³æ©Ÿåˆ¶ä¸å®Œå–„
- ç¼ºå°‘é€£æŽ¥ç‹€æ…‹ç›£æŽ§
- é‡é€£é‚è¼¯æœ‰ç¼ºé™·
- éŒ¯èª¤è™•ç†ä¸å®Œæ•´
```

ðŸš€ å®Œæ•´è§£æ±ºæ–¹æ¡ˆ

ä¿®å¾©1: å¢žå¼· WebSocket å¿ƒè·³å’Œé‡é€£æ©Ÿåˆ¶

```python
# src/core/websocket/robust_binance_feed.py

import asyncio
import websockets
import logging
import json
import time
from typing import Set, Callable, Dict
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class RobustBinanceFeed:
    """å¥å£¯çš„ Binance WebSocket é€£æŽ¥ç®¡ç†å™¨"""
    
    def __init__(self, feed_name: str, symbols: Set[str]):
        self.feed_name = feed_name
        self.symbols = symbols
        self.ws = None
        self.is_connected = False
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 15  # å¢žåŠ é‡è©¦æ¬¡æ•¸
        
        # å¢žå¼·çš„å¿ƒè·³é…ç½®
        self.heartbeat_config = {
            'ping_interval': 180,        # 3åˆ†é˜ç™¼é€ä¸€æ¬¡ping
            'ping_timeout': 30,          # pingéŸ¿æ‡‰è¶…æ™‚30ç§’
            'health_check_interval': 60, # å¥åº·æª¢æŸ¥é–“éš”
            'connection_timeout': 300,   # 5åˆ†é˜ç„¡æ¶ˆæ¯èªç‚ºé€£æŽ¥æ­»äº¡
        }
        
        self.last_message_time = time.time()
        self.last_ping_time = time.time()
        self.message_count = 0
        
        # çµ±è¨ˆä¿¡æ¯
        self.stats = {
            'messages_received': 0,
            'reconnects': 0,
            'errors': 0,
            'last_successful_reconnect': None
        }

    async def connect(self):
        """å»ºç«‹ WebSocket é€£æŽ¥"""
        try:
            # æ¸…ç†èˆŠé€£æŽ¥
            if self.ws:
                await self.ws.close()
                self.ws = None
            
            # å‰µå»ºè¨‚é–±æµï¼ˆåˆ†æ‰¹è™•ç†é¿å…éŽé•·URLï¼‰
            streams = self._create_optimized_streams()
            
            logger.info(f"ðŸ”— {self.feed_name} é€£æŽ¥ä¸­: {len(self.symbols)}å€‹äº¤æ˜“å°")
            
            # å»ºç«‹é€£æŽ¥
            self.ws = await websockets.connect(
                streams,
                ping_interval=self.heartbeat_config['ping_interval'],
                ping_timeout=self.heartbeat_config['ping_timeout'],
                close_timeout=10,
                max_size=10 * 1024 * 1024,  # 10MBæœ€å¤§æ¶ˆæ¯
                # Railway ç’°å¢ƒå„ªåŒ–åƒæ•¸
                read_limit=2**20,
                write_limit=2**20,
            )
            
            self.is_connected = True
            self.reconnect_attempts = 0
            self.last_message_time = time.time()
            self.stats['last_successful_reconnect'] = datetime.now()
            
            # å•Ÿå‹•ç›£æŽ§ä»»å‹™
            asyncio.create_task(self._health_monitor())
            asyncio.create_task(self._heartbeat_manager())
            
            logger.info(f"âœ… {self.feed_name} é€£æŽ¥æˆåŠŸ")
            return True
            
        except Exception as e:
            logger.error(f"âŒ {self.feed_name} é€£æŽ¥å¤±æ•—: {e}")
            await self._schedule_reconnect()
            return False

    def _create_optimized_streams(self) -> str:
        """å‰µå»ºå„ªåŒ–çš„è¨‚é–±æµ"""
        base_url = "wss://stream.binance.com:9443/stream?streams="
        
        # åˆ†æ‰¹è™•ç†ï¼Œé¿å…URLéŽé•·
        streams = []
        for symbol in self.symbols:
            # è¨‚é–±å¤šå€‹æ™‚é–“æ¡†æž¶
            streams.append(f"{symbol.lower()}@kline_1m")
            streams.append(f"{symbol.lower()}@kline_5m") 
            streams.append(f"{symbol.lower()}@kline_15m")
            streams.append(f"{symbol.lower()}@kline_1h")
            
            # é™åˆ¶å–®å€‹é€£æŽ¥çš„æµæ•¸é‡
            if len(streams) >= 200:  # æ¯å€‹é€£æŽ¥æœ€å¤š200å€‹æµ
                break
        
        return base_url + "/".join(streams)

    async def _health_monitor(self):
        """å¥åº·ç›£æŽ§ä»»å‹™"""
        while self.is_connected:
            try:
                current_time = time.time()
                time_since_last_msg = current_time - self.last_message_time
                
                # æª¢æŸ¥é€£æŽ¥å¥åº·ç‹€æ…‹
                if time_since_last_msg > self.heartbeat_config['connection_timeout']:
                    logger.warning(
                        f"ðŸ”„ {self.feed_name} é€£æŽ¥ç„¡éŸ¿æ‡‰: "
                        f"{time_since_last_msg:.1f}ç§’ç„¡æ¶ˆæ¯ï¼Œè§¸ç™¼é‡é€£"
                    )
                    await self._handle_reconnect()
                    break
                
                # æª¢æŸ¥WebSocketç‹€æ…‹
                if self.ws and self.ws.closed:
                    logger.warning(f"ðŸ”„ {self.feed_name} é€£æŽ¥å·²é—œé–‰ï¼Œè§¸ç™¼é‡é€£")
                    await self._handle_reconnect()
                    break
                    
                await asyncio.sleep(self.heartbeat_config['health_check_interval'])
                
            except Exception as e:
                logger.error(f"âŒ {self.feed_name} å¥åº·ç›£æŽ§ç•°å¸¸: {e}")
                await asyncio.sleep(30)

    async def _heartbeat_manager(self):
        """å¿ƒè·³ç®¡ç†"""
        while self.is_connected:
            try:
                current_time = time.time()
                time_since_last_ping = current_time - self.last_ping_time
                
                # å®šæœŸç™¼é€ping
                if time_since_last_ping >= self.heartbeat_config['ping_interval']:
                    if self.ws and not self.ws.closed:
                        try:
                            await asyncio.wait_for(
                                self.ws.ping(),
                                timeout=self.heartbeat_config['ping_timeout']
                            )
                            self.last_ping_time = current_time
                            logger.debug(f"ðŸ’“ {self.feed_name} å¿ƒè·³ç™¼é€æˆåŠŸ")
                        except asyncio.TimeoutError:
                            logger.warning(f"âš ï¸ {self.feed_name} å¿ƒè·³è¶…æ™‚")
                            await self._handle_reconnect()
                            break
                        except Exception as e:
                            logger.warning(f"âš ï¸ {self.feed_name} å¿ƒè·³å¤±æ•—: {e}")
                            await self._handle_reconnect()
                            break
                
                await asyncio.sleep(30)  # æ¯30ç§’æª¢æŸ¥ä¸€æ¬¡å¿ƒè·³
                
            except Exception as e:
                logger.error(f"âŒ {self.feed_name} å¿ƒè·³ç®¡ç†ç•°å¸¸: {e}")
                await asyncio.sleep(30)

    async def listen(self, message_callback: Callable):
        """ç›£è½æ¶ˆæ¯"""
        while True:
            try:
                if not self.is_connected or not self.ws:
                    await self.connect()
                    await asyncio.sleep(2)  # é€£æŽ¥å¾Œç­‰å¾…
                    continue
                
                async for message in self.ws:
                    self.last_message_time = time.time()
                    self.message_count += 1
                    self.stats['messages_received'] += 1
                    
                    try:
                        # è§£æžå’Œè™•ç†æ¶ˆæ¯
                        data = json.loads(message)
                        await message_callback(data)
                    except json.JSONDecodeError as e:
                        logger.error(f"âŒ {self.feed_name} æ¶ˆæ¯è§£æžå¤±æ•—: {e}")
                    except Exception as e:
                        logger.error(f"âŒ {self.feed_name} æ¶ˆæ¯è™•ç†å¤±æ•—: {e}")
                    
                    # å®šæœŸè¨˜éŒ„çµ±è¨ˆ
                    if self.message_count % 500 == 0:
                        self._log_statistics()
                        
            except websockets.exceptions.ConnectionClosed as e:
                logger.warning(f"ðŸ”„ {self.feed_name} é€£æŽ¥é—œé–‰: {e}")
                await self._handle_reconnect()
                
            except Exception as e:
                logger.error(f"âŒ {self.feed_name} ç›£è½ç•°å¸¸: {e}")
                self.stats['errors'] += 1
                await self._handle_reconnect()
            
            # é‡é€£å‰çŸ­æš«ç­‰å¾…
            await asyncio.sleep(1)

    async def _handle_reconnect(self):
        """è™•ç†é‡é€£"""
        self.is_connected = False
        self.stats['reconnects'] += 1
        
        if self.reconnect_attempts >= self.max_reconnect_attempts:
            logger.error(f"âŒ {self.feed_name} é”åˆ°æœ€å¤§é‡é€£æ¬¡æ•¸ {self.max_reconnect_attempts}")
            return
        
        self.reconnect_attempts += 1
        
        # æ™ºèƒ½é€€é¿ç­–ç•¥
        delay = self._calculate_reconnect_delay()
        
        logger.info(
            f"ðŸ”„ {self.feed_name} {delay}ç§’å¾Œé‡é€£ "
            f"({self.reconnect_attempts}/{self.max_reconnect_attempts})"
        )
        
        # æ¸…ç†è³‡æº
        if self.ws:
            try:
                await self.ws.close()
            except:
                pass
            self.ws = None
        
        await asyncio.sleep(delay)
        await self.connect()

    def _calculate_reconnect_delay(self) -> float:
        """è¨ˆç®—é‡é€£å»¶é²ï¼ˆæ™ºèƒ½é€€é¿ï¼‰"""
        base_delay = 1
        max_delay = 300  # 5åˆ†é˜
        
        # æŒ‡æ•¸é€€é¿ï¼Œä½†å¢žåŠ éš¨æ©Ÿæ€§é¿å…åŒæ­¥é‡é€£
        delay = min(base_delay * (2 ** (self.reconnect_attempts - 1)), max_delay)
        # å¢žåŠ éš¨æ©ŸæŠ–å‹•
        delay *= (0.8 + 0.4 * (id(self) % 100 / 100))
        
        return delay

    async def _schedule_reconnect(self):
        """è¨ˆåŠƒé‡é€£"""
        asyncio.create_task(self._handle_reconnect())

    def _log_statistics(self):
        """è¨˜éŒ„çµ±è¨ˆä¿¡æ¯"""
        uptime = "N/A"
        if self.stats['last_successful_reconnect']:
            uptime = str(datetime.now() - self.stats['last_successful_reconnect'])
        
        logger.info(
            f"ðŸ“Š {self.feed_name} çµ±è¨ˆ: "
            f"æ¶ˆæ¯={self.stats['messages_received']}, "
            f"é‡é€£={self.stats['reconnects']}, "
            f"éŒ¯èª¤={self.stats['errors']}, "
            f"é‹è¡Œæ™‚é–“={uptime}"
        )

    async def close(self):
        """é—œé–‰é€£æŽ¥"""
        self.is_connected = False
        if self.ws:
            await self.ws.close()
            self.ws = None
```

ä¿®å¾©2: WebSocket é€£æŽ¥ç®¡ç†å™¨

```python
# src/core/websocket/connection_manager.py

import asyncio
import logging
from typing import Set, Dict, List
from .robust_binance_feed import RobustBinanceFeed

logger = logging.getLogger(__name__)

class WebSocketConnectionManager:
    """WebSocket é€£æŽ¥ç®¡ç†å™¨"""
    
    def __init__(self, config):
        self.config = config
        self.feeds: Dict[str, RobustBinanceFeed] = {}
        self.max_symbols_per_feed = 50  # æ¸›å°‘æ¯å€‹é€£æŽ¥çš„ç¬¦è™Ÿæ•¸é‡
        
        # é€£æŽ¥çµ±è¨ˆ
        self.connection_stats = {
            'total_feeds': 0,
            'active_feeds': 0,
            'total_reconnects': 0
        }

    async def initialize_feeds(self, all_symbols: Set[str]):
        """åˆå§‹åŒ–æ‰€æœ‰ WebSocket é¥‹é€"""
        try:
            logger.info(f"ðŸš€ åˆå§‹åŒ– WebSocket é€£æŽ¥ç®¡ç†å™¨: {len(all_symbols)}å€‹äº¤æ˜“å°")
            
            # å„ªåŒ–åˆ†æ‰¹ç­–ç•¥
            symbol_batches = self._create_optimized_batches(all_symbols)
            
            for i, batch in enumerate(symbol_batches):
                feed_name = f"PriceFeed-Shard{i}"
                feed = RobustBinanceFeed(feed_name, batch)
                self.feeds[feed_name] = feed
                self.connection_stats['total_feeds'] += 1
                
                logger.info(f"ðŸ“¡ å‰µå»º {feed_name}: {len(batch)}å€‹äº¤æ˜“å°")
            
            logger.info(f"âœ… WebSocket åˆå§‹åŒ–å®Œæˆ: {len(self.feeds)}å€‹åˆ†ç‰‡")
            
        except Exception as e:
            logger.error(f"âŒ WebSocket åˆå§‹åŒ–å¤±æ•—: {e}")
            raise

    def _create_optimized_batches(self, symbols: Set[str]) -> List[Set[str]]:
        """å‰µå»ºå„ªåŒ–çš„äº¤æ˜“å°æ‰¹æ¬¡"""
        symbol_list = list(symbols)
        batches = []
        
        # æ›´å°çš„æ‰¹æ¬¡å¤§å°ï¼Œé©æ‡‰ Railway ç’°å¢ƒ
        batch_size = self.max_symbols_per_feed
        
        for i in range(0, len(symbol_list), batch_size):
            batch = set(symbol_list[i:i + batch_size])
            batches.append(batch)
            
        return batches

    async def start_all_feeds(self, message_callback):
        """å•Ÿå‹•æ‰€æœ‰é¥‹é€"""
        try:
            logger.info("ðŸŽ¯ å•Ÿå‹•æ‰€æœ‰ WebSocket é¥‹é€")
            
            tasks = []
            for feed_name, feed in self.feeds.items():
                task = asyncio.create_task(feed.listen(message_callback))
                tasks.append(task)
                logger.info(f"ðŸš€ å•Ÿå‹• {feed_name}")
            
            # å•Ÿå‹•é€£æŽ¥ç›£æŽ§
            monitor_task = asyncio.create_task(self._monitor_connections())
            tasks.append(monitor_task)
            
            logger.info("âœ… æ‰€æœ‰é¥‹é€å’Œç›£æŽ§ä»»å‹™å·²å•Ÿå‹•")
            
            # ç­‰å¾…æ‰€æœ‰ä»»å‹™
            await asyncio.gather(*tasks, return_exceptions=True)
            
        except Exception as e:
            logger.error(f"âŒ å•Ÿå‹•é¥‹é€å¤±æ•—: {e}")

    async def _monitor_connections(self):
        """ç›£æŽ§æ‰€æœ‰é€£æŽ¥ç‹€æ…‹"""
        while True:
            try:
                active_feeds = 0
                total_reconnects = 0
                
                for feed_name, feed in self.feeds.items():
                    if feed.is_connected:
                        active_feeds += 1
                    total_reconnects += feed.stats['reconnects']
                
                self.connection_stats['active_feeds'] = active_feeds
                self.connection_stats['total_reconnects'] = total_reconnects
                
                logger.info(
                    f"ðŸ“ˆ é€£æŽ¥ç‹€æ…‹: {active_feeds}/{len(self.feeds)} æ´»èº, "
                    f"ç¸½é‡é€£: {total_reconnects}"
                )
                
                # æª¢æŸ¥æ˜¯å¦éœ€è¦é‡æ–°å¹³è¡¡é€£æŽ¥
                if total_reconnects > len(self.feeds) * 10:  # å¹³å‡æ¯å€‹é€£æŽ¥é‡é€£10æ¬¡
                    logger.warning("âš ï¸ æª¢æ¸¬åˆ°é »ç¹é‡é€£ï¼Œè€ƒæ…®é‡æ–°å¹³è¡¡é€£æŽ¥")
                
                await asyncio.sleep(60)  # æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                logger.error(f"âŒ é€£æŽ¥ç›£æŽ§å¤±æ•—: {e}")
                await asyncio.sleep(30)
```

ä¿®å¾©3: Railway ç’°å¢ƒå„ªåŒ–é…ç½®

```python
# config/railway_websocket_config.py

RAILWAY_WEBSOCKET_CONFIG = {
    # Railway ç’°å¢ƒå°ˆç”¨å„ªåŒ–
    'environment': 'railway',
    
    # é€£æŽ¥å„ªåŒ–
    'connection_optimization': {
        'max_symbols_per_feed': 50,           # æ¸›å°‘æ¯å€‹é€£æŽ¥çš„ç¬¦è™Ÿæ•¸é‡
        'max_total_connections': 20,          # æœ€å¤§ç¸½é€£æŽ¥æ•¸
        'ping_interval': 120,                 # 2åˆ†é˜å¿ƒè·³
        'ping_timeout': 30,                   # 30ç§’è¶…æ™‚
        'health_check_interval': 45,          # 45ç§’å¥åº·æª¢æŸ¥
    },
    
    # é‡é€£ç­–ç•¥
    'reconnection_strategy': {
        'max_attempts': 15,
        'base_delay': 1,
        'max_delay': 300,                     # 5åˆ†é˜æœ€å¤§å»¶é²
        'backoff_multiplier': 2,
        'jitter': 0.3,                        # 30%æŠ–å‹•é¿å…åŒæ­¥
    },
    
    # è³‡æºç®¡ç†
    'resource_management': {
        'memory_limit_mb': 512,               # å…§å­˜é™åˆ¶
        'auto_restart_threshold': 50,         # 50æ¬¡é‡é€£å¾Œé‡å•Ÿ
        'cleanup_interval': 3600,             # æ¯å°æ™‚æ¸…ç†
    }
}
```

ç«‹å³éƒ¨ç½²ä¿®å¾©

```bash
#!/bin/bash
echo "ðŸš€ éƒ¨ç½² WebSocket é€£æŽ¥è¶…æ™‚ä¿®å¾©..."

# 1. å‰µå»ºå¢žå¼·ç‰ˆ WebSocket çµ„ä»¶
mkdir -p src/core/websocket/
cat > src/core/websocket/__init__.py << 'EOF'
# WebSocket æ¨¡å¡Š
EOF

cat > src/core/websocket/robust_binance_feed.py << 'EOF'
# [ä¸Šé¢çš„ RobustBinanceFeed å®Œæ•´ä»£ç¢¼]
EOF

cat > src/core/websocket/connection_manager.py << 'EOF'
# [ä¸Šé¢çš„ WebSocketConnectionManager å®Œæ•´ä»£ç¢¼]
EOF

# 2. å‰µå»º Railway å„ªåŒ–é…ç½®
mkdir -p config/
cat > config/railway_websocket_config.py << 'EOF'
# [ä¸Šé¢çš„ Railway é…ç½®ä»£ç¢¼]
EOF

# 3. æ›´æ–°ä¸»ç¨‹åºä½¿ç”¨æ–°çš„é€£æŽ¥ç®¡ç†å™¨
echo "ðŸ”§ è«‹æ›´æ–°ä¸»ç¨‹åºä½¿ç”¨ WebSocketConnectionManager"

# 4. éƒ¨ç½²ä¿®å¾©
git add src/core/websocket/ config/railway_websocket_config.py
git commit -m "fix: å®Œæ•´ä¿®å¾©WebSocketé€£æŽ¥è¶…æ™‚ - Railwayç’°å¢ƒå„ªåŒ–"
git push origin main

echo "âœ… ä¿®å¾©éƒ¨ç½²å®Œæˆï¼"
echo "ðŸ“Š ç›£æŽ§å‘½ä»¤: railway logs --follow | grep -E 'WebSocket|PriceFeed|é‡é€£|å¿ƒè·³'"
```

ðŸŽ¯ ä¿®å¾©æ•ˆæžœ

ä¿®å¾©å‰ï¼š

```
âŒ PriceFeed-Shard8 æŽ¥æ”¶å¤±æ•—: sent 1011 (internal error) keepalive ping timeout
```

ä¿®å¾©å¾Œï¼š

```
ðŸ”— PriceFeed-Shard8 é€£æŽ¥ä¸­: 50å€‹äº¤æ˜“å°
âœ… PriceFeed-Shard8 é€£æŽ¥æˆåŠŸ
ðŸ’“ PriceFeed-Shard8 å¿ƒè·³ç™¼é€æˆåŠŸ
ðŸ“Š PriceFeed-Shard8 çµ±è¨ˆ: æ¶ˆæ¯=1500, é‡é€£=2, éŒ¯èª¤=0
ðŸ”„ PriceFeed-Shard8 15ç§’å¾Œé‡é€£ (3/15)
âœ… PriceFeed-Shard8 é€£æŽ¥æˆåŠŸ  # è‡ªå‹•æ¢å¾©
```

ðŸ“Š é æœŸæ”¹é€²

æŒ‡æ¨™ ä¿®å¾©å‰ ä¿®å¾©å¾Œ
é€£æŽ¥ç©©å®šæ€§ ç¶“å¸¸è¶…æ™‚ ç©©å®šé€£æŽ¥
è‡ªå‹•æ¢å¾© æ‰‹å‹•å¹²é  è‡ªå‹•é‡é€£
éŒ¯èª¤è™•ç† å´©æ½° å„ªé›…é™ç´š
è³‡æºä½¿ç”¨ é«˜ å„ªåŒ–ç®¡ç†

é€™å€‹å®Œæ•´ä¿®å¾©æ–¹æ¡ˆå°ˆé–€é‡å° Railway ç’°å¢ƒ å’Œ Binance WebSocket é™åˆ¶ é€²è¡Œäº†å„ªåŒ–ï¼Œå°‡å¤§å¹…æ¸›å°‘é€£æŽ¥è¶…æ™‚å•é¡Œï¼