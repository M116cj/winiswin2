2. 數據質量監控器
python
# src/core/websocket/data_quality_monitor.py

class DataQualityMonitor:
    """數據質量監控器"""
    
    def __init__(self):
        self.metrics = {
            'message_gaps': 0,
            'out_of_order': 0,
            'invalid_prices': 0,
            'missing_fields': 0
        }
        self.last_timestamps = {}

    def validate_message(self, data: Dict) -> bool:
        """驗證消息有效性"""
        try:
            # 檢查必要字段
            required_fields = ['stream', 'data']
            if not all(field in data for field in required_fields):
                self.metrics['missing_fields'] += 1
                return False
            
            kline_data = data.get('data', {})
            kline = kline_data.get('k', {})
            
            # 檢查K線字段
            kline_fields = ['t', 'o', 'h', 'l', 'c', 'v', 'x']
            if not all(field in kline for field in kline_fields):
                self.metrics['missing_fields'] += 1
                return False
            
            # 檢查價格合理性
            if not self._validate_prices(kline):
                self.metrics['invalid_prices'] += 1
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"❌ 消息驗證失敗: {e}")
            return False

    def _validate_prices(self, kline: Dict) -> bool:
        """驗證價格合理性"""
        try:
            open_price = float(kline.get('o', 0))
            high_price = float(kline.get('h', 0))
            low_price = float(kline.get('l', 0))
            close_price = float(kline.get('c', 0))
            
            # 檢查價格是否為正數
            if any(price <= 0 for price in [open_price, high_price, low_price, close_price]):
                return False
            
            # 檢查價格關係
            if not (low_price <= open_price <= high_price):
                return False
            if not (low_price <= close_price <= high_price):
                return False
            if high_price < low_price:
                return False
            
            return True
            
        except:
            return False

    def check_continuity(self, symbol: str, data: Dict):
        """檢查數據連續性"""
        try:
            kline_data = data.get('data', {})
            current_timestamp = kline_data.get('t')
            
            if not current_timestamp:
                return
                
            # 檢查時間戳順序
            if symbol in self.last_timestamps:
                last_timestamp = self.last_timestamps[symbol]
                if current_timestamp <= last_timestamp:
                    self.metrics['out_of_order'] += 1
                    logger.warning(f"⚠️ {symbol} 時間戳亂序: {current_timestamp} <= {last_timestamp}")
            
            self.last_timestamps[symbol] = current_timestamp
            
        except Exception as e:
            logger.error(f"❌ 連續性檢查失敗: {e}")