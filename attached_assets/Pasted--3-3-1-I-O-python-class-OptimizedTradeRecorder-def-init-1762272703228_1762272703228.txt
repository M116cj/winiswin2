ğŸŸ¢Â ç¬¬3éšæ®µï¼šæ€§èƒ½å„ªåŒ–
3.1 I/Oæ€§èƒ½å„ªåŒ–
python
class OptimizedTradeRecorder:
    """å„ªåŒ–çš„äº¤æ˜“è¨˜éŒ„å™¨"""
    
    def __init__(self, config):
        self.completed_trades = []
        self.pending_writes = asyncio.Queue()
        self.batch_size = config.ML_FLUSH_COUNT
        self.flush_interval = 60  # æ‰¹é‡å¯«å…¥é–“éš”
        self.max_file_size = 10 * 1024 * 1024  # 10MB
        
        # å•Ÿå‹•å¾Œå°å¯«å…¥ä»»å‹™
        self._writer_task = asyncio.create_task(self._batch_writer_loop())
        
    async def _batch_writer_loop(self):
        """å¾Œå°æ‰¹é‡å¯«å…¥å¾ªç’°"""
        buffer = []
        last_flush = time.time()
        
        while True:
            try:
                # ç­‰å¾…æ•¸æ“šæˆ–è¶…æ™‚
                trade = await asyncio.wait_for(
                    self.pending_writes.get(), 
                    timeout=self.flush_interval
                )
                buffer.append(trade)
            except asyncio.TimeoutError:
                pass  # è¶…æ™‚è§¸ç™¼flush
                
            # æª¢æŸ¥flushæ¢ä»¶
            should_flush = (
                len(buffer) >= self.batch_size or
                (buffer and time.time() - last_flush >= self.flush_interval)
            )
            
            if should_flush and buffer:
                await self._flush_buffer(buffer)
                buffer = []
                last_flush = time.time()
                
    async def _flush_buffer(self, buffer: list):
        """æ‰¹é‡å¯«å…¥ç·©è¡å€"""
        # æ–‡ä»¶å¤§å°æª¢æŸ¥å’Œè¼ªè½‰
        await self._check_file_rotation()
        
        # æ‰¹é‡å¯«å…¥
        batch_lines = "\n".join(
            json.dumps(trade, ensure_ascii=False, default=str) 
            for trade in buffer
        ) + "\n"
        
        async with self._flush_lock:
            with open(self.trades_file, 'a', encoding='utf-8') as f:
                f.write(batch_lines)
                
        logger.debug(f"ğŸ’¾ æ‰¹é‡å¯«å…¥ {len(buffer)} ç­†äº¤æ˜“")
3.2 æ™ºèƒ½æ—¥èªŒç³»çµ±
python
class SmartLogger:
    """æ™ºèƒ½æ—¥èªŒç®¡ç†å™¨"""
    
    def __init__(self, base_logger):
        self.logger = base_logger
        self.message_counts = {}  # æ¶ˆæ¯é »ç‡è¨ˆæ•¸
        self.last_reset_time = time.time()
        
    def debug_sampled(self, message: str, sample_rate: float = 0.01):
        """é‡‡æ¨£debugæ—¥èªŒ"""
        if random.random() < sample_rate:
            self.logger.debug(f"[SAMPLED] {message}")
            
    def info_throttled(self, message: str, key: str, interval: int = 60):
        """é™é »infoæ—¥èªŒ"""
        current_time = time.time()
        
        if key not in self.message_counts:
            self.message_counts[key] = current_time
            self.logger.info(message)
        elif current_time - self.message_counts[key] >= interval:
            self.message_counts[key] = current_time
            self.logger.info(message)
            
    def error_with_context(self, message: str, context: dict = None):
        """å¸¶ä¸Šä¸‹æ–‡çš„éŒ¯èª¤æ—¥èªŒ"""
        context_str = json.dumps(context, ensure_ascii=False) if context else ""
        self.logger.error(f"{message} | Context: {context_str}")

# æ‡‰ç”¨ç¤ºä¾‹
smart_log = SmartLogger(logger)

# åœ¨ç†±è·¯å¾‘ä¸­ä½¿ç”¨é‡‡æ¨£æ—¥èªŒ
for symbol in symbols:
    smart_log.debug_sampled(f"ğŸ’¡ {symbol} Kç·šæ›´æ–°", sample_rate=0.005)
3.3 é…ç½®é©—è­‰ç³»çµ±
python
class ConfigValidator:
    """é…ç½®å€¼é©—è­‰å™¨"""
    
    @staticmethod
    def validate_ratio(value: float, name: str, min_val: float = 0.0, max_val: float = 1.0) -> float:
        """é©—è­‰æ¯”ç‡é…ç½®"""
        if not (min_val <= value <= max_val):
            logger.warning(f"âš ï¸ é…ç½® {name} è¶…å‡ºç¯„åœ [{min_val}, {max_val}]ï¼Œå·²èª¿æ•´: {value}")
            return max(min_val, min(value, max_val))
        return value
    
    @staticmethod
    def validate_positive_int(value: int, name: str, default: int) -> int:
        """é©—è­‰æ­£æ•´æ•¸é…ç½®"""
        if value <= 0:
            logger.warning(f"âš ï¸ é…ç½® {name} å¿…é ˆç‚ºæ­£æ•´æ•¸ï¼Œä½¿ç”¨é»˜èªå€¼: {default}")
            return default
        return value

# åœ¨é…ç½®åŠ è¼‰æ™‚æ‡‰ç”¨
class AppConfig:
    def __init__(self):
        # åŸå§‹å€¼
        raw_ratio = float(os.getenv("MAX_TOTAL_BUDGET_RATIO", "0.80"))
        
        # é©—è­‰ä¸¦èª¿æ•´
        self.MAX_TOTAL_BUDGET_RATIO = ConfigValidator.validate_ratio(
            raw_ratio, "MAX_TOTAL_BUDGET_RATIO", 0.0, 1.0
        )

ğŸ“ŠÂ ç›£æ§å’Œé©—è­‰é«”ç³»
4.1 å¯¦æ™‚å¥åº·æª¢æŸ¥
python
class SystemHealthMonitor:
    """ç³»çµ±å¥åº·ç›£æ§"""
    
    def __init__(self):
        self.metrics = {
            'concurrent_errors': 0,
            'margin_usage': 0.0,
            'ws_latency': 0.0,
            'api_success_rate': 1.0
        }
        self.health_status = "HEALTHY"
        
    async def continuous_monitoring(self):
        """æŒçºŒå¥åº·ç›£æ§"""
        while True:
            health_report = await self._generate_health_report()
            
            if health_report['overall_status'] == "CRITICAL":
                await self._trigger_emergency_protocol()
            elif health_report['overall_status'] == "WARNING":
                await self._trigger_alert_protocol()
                
            await asyncio.sleep(30)  # 30ç§’æª¢æŸ¥é–“éš”
            
    async def _generate_health_report(self) -> dict:
        """ç”Ÿæˆå¥åº·å ±å‘Š"""
        checks = {
            'margin_safety': await self._check_margin_safety(),
            'ws_connection': await self._check_websocket_health(),
            'api_availability': await self._check_api_health(),
            'disk_space': await self._check_disk_health()
        }
        
        critical_count = sum(1 for check in checks.values() if check['status'] == 'CRITICAL')
        warning_count = sum(1 for check in checks.values() if check['status'] == 'WARNING')
        
        overall_status = (
            "CRITICAL" if critical_count > 0 else
            "WARNING" if warning_count > 0 else
            "HEALTHY"
        )
        
        return {
            'overall_status': overall_status,
            'checks': checks,
            'timestamp': time.time()
        }