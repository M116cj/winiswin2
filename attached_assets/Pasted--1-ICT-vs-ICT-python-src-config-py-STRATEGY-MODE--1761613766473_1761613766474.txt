### 1. **ICT ç­–ç•¥ä¿ç•™ vs å®Œå…¨æ›¿æ›**
**å»ºè­°ï¼šğŸŸ¢ ä¿ç•™ ICT ä½œç‚ºå‚™é¸ï¼ˆé…ç½®é©…å‹•ï¼‰**

```python
# src/config.py
STRATEGY_MODE = "hybrid"  # "ict", "self_learning", "hybrid"

# src/strategies/strategy_factory.py
class StrategyFactory:
    @staticmethod
    def create_strategy(config):
        if config.STRATEGY_MODE == "ict":
            return ICTStrategy(config)
        elif config.STRATEGY_MODE == "self_learning":
            return SelfLearningTrader(config)
        elif config.STRATEGY_MODE == "hybrid":
            # æ··åˆæ¨¡å¼ï¼šML éæ¿¾ ICT ä¿¡è™Ÿ
            return HybridStrategy(config)
```

**ç†ç”±**ï¼š
- **é¢¨éšªæ§åˆ¶**ï¼šæ–°æ¨¡å‹éœ€è¦æ™‚é–“é©—è­‰
- **A/B æ¸¬è©¦**ï¼šå¯ä¸¦è¡Œæ¯”è¼ƒå…©ç¨®ç­–ç•¥è¡¨ç¾
- **æ¼¸é€²é·ç§»**ï¼šé¿å…ä¸€æ¬¡æ€§åˆ‡æ›çš„é¢¨éšª

### 2. **æ·±åº¦å­¸ç¿’æ¡†æ¶é¸æ“‡**
**å»ºè­°ï¼šğŸŸ¢ TensorFlow**

**ç†ç”±**ï¼š
- **ç”Ÿç”¢éƒ¨ç½²æˆç†Ÿ**ï¼šTensorFlow Servingã€ONNX è½‰æ›æ”¯æ´æ›´å¥½
- **ä½ çš„ç¾æœ‰æ¶æ§‹**ï¼šå·²ç¶“ä½¿ç”¨ ONNXï¼ŒTensorFlow â†’ ONNX æ›´ç©©å®š
- **æ€§èƒ½**ï¼šTensorFlow åœ¨ CPU æ¨ç†ä¸Šé€šå¸¸æ¯” PyTorch å¿« 10-15%
- **å­¸ç¿’æ›²ç·š**ï¼šä½ å·²æœ‰ XGBoost ç¶“é©—ï¼ŒKeras API æ›´æ˜“ä¸Šæ‰‹

```python
# requirements.txt
tensorflow>=2.13.0
tensorflow-addons>=0.19.0  # Attention å±¤
```

### 3. **å¯¦æ–½ç¯„åœ**
**å»ºè­°ï¼šğŸŸ¢ æ¼¸é€²å¯¦æ–½ï¼ˆå…ˆæ ¸å¿ƒï¼Œå¾Œé€²åŒ–ï¼‰**

#### éšæ®µ 1ï¼šæ ¸å¿ƒè‡ªä¸»å­¸ç¿’
- âœ… `SelfLearningTrader`ï¼ˆæœ€å°å¯è¡Œç‰ˆæœ¬ï¼‰
- âœ… `MarketStructureAutoencoder`ï¼ˆç„¡ç›£ç£å­¸ç¿’ï¼‰
- âœ… `SelfLearningPredictor`ï¼ˆç«¯åˆ°ç«¯é æ¸¬ï¼‰
- âœ… ä¸»å¾ªç’°æ•´åˆï¼ˆé…ç½®é©…å‹•ï¼‰

#### éšæ®µ 2ï¼šé€²åŒ–èƒ½åŠ›
- âœ… `FeatureDiscoveryNetwork`
- âœ… `LiquidityPredictionModel`  
- âœ… `AdaptiveStrategyEvolver`ï¼ˆå¼·åŒ–å­¸ç¿’ï¼‰

#### éšæ®µ 3ï¼šå„ªåŒ–å®Œå–„
- âœ… è‡ªå‹•è¶…åƒæ•¸èª¿å„ª
- âœ… æ¨¡å‹å£“ç¸®ï¼ˆé‡åŒ–ã€å‰ªæï¼‰
- âœ… GPU åŠ é€Ÿæ”¯æ´

### 4. **è¨“ç·´æ•¸æ“šç­–ç•¥**
**å»ºè­°ï¼šğŸŸ¢ é›™è»Œä¸¦è¡Œ**

---

## ğŸ”§ **é«˜å“è³ªä¿¡è™Ÿå®šç¾©æ¨™æº–**

### ğŸ“‹ **åš´æ ¼ç¯©é¸æ¢ä»¶**
```python
# src/ml/high_quality_filter.py
class HighQualitySignalFilter:
    def __init__(self, config):
        self.config = config
    
    def is_high_quality_signal(self, signal, trade_result):
        """
        åˆ¤æ–·æ˜¯å¦ç‚ºé«˜å“è³ªäº¤æ˜“ä¿¡è™Ÿ
        """
        # 1. äº¤æ˜“çµæœå“è³ª
        if not self._check_trade_quality(trade_result):
            return False
            
        # 2. ä¿¡è™Ÿç”Ÿæˆå“è³ª  
        if not self._check_signal_quality(signal):
            return False
            
        # 3. å¸‚å ´ç’°å¢ƒå“è³ª
        if not self._check_market_quality(signal):
            return False
            
        return True
    
    def _check_trade_quality(self, trade_result):
        """æª¢æŸ¥äº¤æ˜“çµæœå“è³ª"""
        # æ¢ä»¶1: ç›ˆè™§æ¯” >= 1.5
        if trade_result.get('risk_reward_ratio', 0) < 1.5:
            return False
            
        # æ¢ä»¶2: å‹ç‡è²¢ç»ç‚ºæ­£ï¼ˆç›ˆåˆ©äº¤æ˜“ï¼‰
        if trade_result.get('pnl_pct', 0) <= 0:
            return False
            
        # æ¢ä»¶3: é¢¨éšªèª¿æ•´æ”¶ç›Š >= 0.5
        risk_adjusted = trade_result.get('risk_adjusted_return', 0)
        if risk_adjusted < 0.5:
            return False
            
        # æ¢ä»¶4: æŒå€‰æ™‚é–“åˆç†ï¼ˆéæ¥µç«¯çŸ­/é•·ï¼‰
        hold_time = trade_result.get('hold_duration_hours', 0)
        if hold_time < 0.1 or hold_time > 48:  # 6åˆ†é˜ - 2å¤©
            return False
            
        return True
    
    def _check_signal_quality(self, signal):
        """æª¢æŸ¥ä¿¡è™Ÿç”Ÿæˆå“è³ª"""
        # æ¢ä»¶1: ä¿¡å¿ƒåº¦ >= 60%
        if signal.get('confidence_score', 0) < 0.6:
            return False
            
        # æ¢ä»¶2: MLé æ¸¬åˆ†æ•¸ >= 0.5
        if signal.get('ml_score', 0) < 0.5:
            return False
            
        # æ¢ä»¶3: å¸‚å ´ç‹€æ…‹ç‚º trending æˆ– breakout
        market_state = signal.get('market_regime', 'unknown')
        if market_state not in ['trending', 'breakout']:
            return False
            
        # æ¢ä»¶4: åè½‰é¢¨éšªè©•åˆ† < 0.2ï¼ˆä½é¢¨éšªï¼‰
        reversal_risk = signal.get('reversal_risk_score', 1.0)
        if reversal_risk >= 0.2:
            return False
            
        return True
    
    def _check_market_quality(self, signal):
        """æª¢æŸ¥å¸‚å ´ç’°å¢ƒå“è³ª"""
        # æ¢ä»¶1: æ³¢å‹•ç‡é©ä¸­ï¼ˆéæ¥µç«¯é«˜/ä½ï¼‰
        volatility = signal.get('volatility', 0)
        if volatility < 0.005 or volatility > 0.05:  # 0.5% - 5%
            return False
            
        # æ¢ä»¶2: æµå‹•æ€§å……è¶³
        volume_rank = signal.get('volume_rank_pct', 1.0)
        if volume_rank > 0.3:  # å‰30%æµå‹•æ€§
            return False
            
        # æ¢ä»¶3: è³‡é‡‘è²»ç‡åˆç†
        funding_rate = signal.get('funding_rate', 0)
        if abs(funding_rate) > 0.001:  # è³‡é‡‘è²» < 0.1%
            return False
            
        return True
```

---

## ğŸ“Š **é«˜å“è³ªè¨“ç·´æ•¸æ“šç®¡é“**

### ğŸ”„ **å¯¦æ–½æµç¨‹**
```python
# src/ml/quality_training_pipeline.py
class QualityTrainingPipeline:
    def __init__(self, high_quality_filter, model):
        self.filter = high_quality_filter
        self.model = model
        self.quality_threshold = 0.8  # é«˜å“è³ªé–¾å€¼
        
    def collect_quality_training_data(self):
        """æ”¶é›†é«˜å“è³ªè¨“ç·´æ•¸æ“š"""
        quality_data = []
        
        # å¾è™›æ“¬å€‰ä½å’ŒçœŸå¯¦å€‰ä½æ”¶é›†æ•¸æ“š
        all_trades = self._get_all_trades()
        
        for trade in all_trades:
            signal = trade['signal']
            result = trade['result']
            
            # åš´æ ¼ç¯©é¸é«˜å“è³ªä¿¡è™Ÿ
            if self.filter.is_high_quality_signal(signal, result):
                # æ§‹å»ºè¨“ç·´æ¨£æœ¬
                training_sample = self._build_training_sample(signal, result)
                quality_data.append(training_sample)
        
        logger.info(f"æ”¶é›†åˆ° {len(quality_data)} å€‹é«˜å“è³ªè¨“ç·´æ¨£æœ¬")
        return quality_data
    
    def _build_training_sample(self, signal, result):
        """æ§‹å»ºè¨“ç·´æ¨£æœ¬"""
        return {
            'features': self._extract_features(signal),
            'label': self._create_label(result),
            'weight': self._calculate_quality_weight(signal, result),
            'metadata': {
                'symbol': signal['symbol'],
                'timestamp': signal['timestamp'],
                'quality_score': self._calculate_quality_score(signal, result)
            }
        }
    
    def _calculate_quality_weight(self, signal, result):
        """è¨ˆç®—å“è³ªæ¬Šé‡"""
        base_weight = 1.0
        
        # ç›ˆè™§æ¯”è¶Šé«˜ï¼Œæ¬Šé‡è¶Šå¤§
        rr_weight = min(result['risk_reward_ratio'], 3.0)  # æœ€å¤§3å€
        
        # ä¿¡å¿ƒåº¦è¶Šé«˜ï¼Œæ¬Šé‡è¶Šå¤§  
        confidence_weight = signal['confidence_score'] * 2  # æœ€å¤§2å€
        
        # å‹ç‡è²¢ç»è¶Šå¤§ï¼Œæ¬Šé‡è¶Šå¤§
        pnl_weight = max(1.0, abs(result['pnl_pct']) / 1.0)  # æ¯1% PnL +1æ¬Šé‡
        
        return base_weight * rr_weight * confidence_weight * pnl_weight
```


**è™›æ“¬å€‰ä½å…¨ç”Ÿå‘½é€±æœŸç›£æ§åŠŸèƒ½**ï¼Œå¾é–‹å€‰åˆ°å¹³å€‰çš„å®Œæ•´å¯¦ç¾ï¼š

---

## ğŸ“¦ **æ–°å¢æ¨¡çµ„çµæ§‹**
```
src/managers/
â”œâ”€â”€ virtual_position_manager.py    # ä¸»è¦ç®¡ç†å™¨ï¼ˆå·²å­˜åœ¨ï¼‰
â”œâ”€â”€ virtual_position_lifecycle.py   # ğŸ”¥ æ–°å¢ï¼šç”Ÿå‘½é€±æœŸç›£æ§
â””â”€â”€ virtual_position_events.py      # ğŸ”¥ æ–°å¢ï¼šäº‹ä»¶å®šç¾©
```

---

## ğŸ”¥ **1. è™›æ“¬å€‰ä½äº‹ä»¶å®šç¾©**

```python
# src/managers/virtual_position_events.py
from enum import Enum
from dataclasses import dataclass
from typing import Optional, Dict, Any
import time

class VirtualPositionEvent(Enum):
    """è™›æ“¬å€‰ä½ç”Ÿå‘½é€±æœŸäº‹ä»¶"""
    CREATED = "created"           # å€‰ä½å‰µå»º
    PRICE_UPDATED = "price_updated"  # åƒ¹æ ¼æ›´æ–°
    MAX_PNL_UPDATED = "max_pnl_updated"  # æœ€å¤§ç›ˆåˆ©æ›´æ–°
    MIN_PNL_UPDATED = "min_pnl_updated"  # æœ€å¤§è™§ææ›´æ–°
    TP_APPROACHING = "tp_approaching"    # æ¥è¿‘æ­¢ç›ˆ
    SL_APPROACHING = "sl_approaching"    # æ¥è¿‘æ­¢æ
    TP_TRIGGERED = "tp_triggered"        # æ­¢ç›ˆè§¸ç™¼
    SL_TRIGGERED = "sl_triggered"        # æ­¢æè§¸ç™¼
    EXPIRED = "expired"                  # éæœŸå¹³å€‰
    MANUAL_CLOSE = "manual_close"        # æ‰‹å‹•å¹³å€‰
    CLOSED = "closed"                    # å€‰ä½é—œé–‰ï¼ˆæœ€çµ‚ç‹€æ…‹ï¼‰

@dataclass
class VirtualPositionEventPayload:
    """äº‹ä»¶è¼‰è·"""
    event_type: VirtualPositionEvent
    position_id: str
    symbol: str
    timestamp: float
    current_price: float
    pnl_pct: float
    max_pnl: float
    min_pnl: float
    metadata: Dict[str, Any]
    
    @classmethod
    def create(cls, event_type: VirtualPositionEvent, position, **kwargs):
        return cls(
            event_type=event_type,
            position_id=position.signal_id,
            symbol=position.symbol,
            timestamp=time.time(),
            current_price=position.current_price,
            pnl_pct=position.pnl_pct,
            max_pnl=getattr(position, 'max_pnl', position.pnl_pct),
            min_pnl=getattr(position, 'min_pnl', position.pnl_pct),
            metadata=kwargs
        )
```

---

## ğŸ”¥ **2. è™›æ“¬å€‰ä½ç”Ÿå‘½é€±æœŸç›£æ§å™¨**

```python
# src/managers/virtual_position_lifecycle.py
import asyncio
import logging
import time
from typing import Dict, List, Optional, Callable
from collections import defaultdict

from src.managers.virtual_position_events import (
    VirtualPositionEvent, 
    VirtualPositionEventPayload
)
from src.core.data_models import VirtualPosition

logger = logging.getLogger(__name__)

class VirtualPositionLifecycleMonitor:
    """è™›æ“¬å€‰ä½å…¨ç”Ÿå‘½é€±æœŸç›£æ§å™¨"""
    
    def __init__(self, event_callback: Optional[Callable] = None):
        self.active_positions: Dict[str, VirtualPosition] = {}
        self.position_history: Dict[str, List[VirtualPositionEventPayload]] = defaultdict(list)
        self.event_callback = event_callback
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.max_pnl_tracker: Dict[str, float] = {}
        self.min_pnl_tracker: Dict[str, float] = {}
        
        # é…ç½®åƒæ•¸
        self.tp_approach_threshold = 0.8  # è·é›¢æ­¢ç›ˆ 20% æ™‚è§¸ç™¼
        self.sl_approach_threshold = 0.8  # è·é›¢æ­¢æ 20% æ™‚è§¸ç™¼
        self.update_interval = 1.0        # 1ç§’æ›´æ–°ä¸€æ¬¡
        
    def add_position(self, position: VirtualPosition):
        """æ·»åŠ è™›æ“¬å€‰ä½åˆ°ç›£æ§"""
        position_id = position.signal_id
        self.active_positions[position_id] = position
        self.max_pnl_tracker[position_id] = position.pnl_pct
        self.min_pnl_tracker[position_id] = position.pnl_pct
        
        # ç™¼é€å‰µå»ºäº‹ä»¶
        self._emit_event(VirtualPositionEvent.CREATED, position)
        
        # å•Ÿå‹•ç›£æ§ä»»å‹™
        if position_id not in self.monitoring_tasks:
            task = asyncio.create_task(self._monitor_position_lifecycle(position_id))
            self.monitoring_tasks[position_id] = task
            
        logger.debug(f"é–‹å§‹ç›£æ§è™›æ“¬å€‰ä½: {position_id}")
    
    def remove_position(self, position_id: str):
        """ç§»é™¤è™›æ“¬å€‰ä½ç›£æ§"""
        if position_id in self.active_positions:
            del self.active_positions[position_id]
        if position_id in self.max_pnl_tracker:
            del self.max_pnl_tracker[position_id]
        if position_id in self.min_pnl_tracker:
            del self.min_pnl_tracker[position_id]
        if position_id in self.monitoring_tasks:
            self.monitoring_tasks[position_id].cancel()
            del self.monitoring_tasks[position_id]
        logger.debug(f"åœæ­¢ç›£æ§è™›æ“¬å€‰ä½: {position_id}")
    
    async def _monitor_position_lifecycle(self, position_id: str):
        """ç›£æ§å–®å€‹å€‰ä½çš„ç”Ÿå‘½é€±æœŸ"""
        try:
            while position_id in self.active_positions:
                position = self.active_positions[position_id]
                
                if position.is_closed:
                    # å€‰ä½å·²é—œé–‰ï¼Œè¨˜éŒ„æ­·å²ä¸¦é€€å‡º
                    self._record_position_history(position_id)
                    self.remove_position(position_id)
                    break
                
                # æ›´æ–° PnL è¿½è¹¤
                self._update_pnl_trackers(position_id, position)
                
                # æª¢æŸ¥å„ç¨®äº‹ä»¶
                await self._check_lifecycle_events(position_id, position)
                
                # ç­‰å¾…ä¸‹ä¸€æ¬¡æ›´æ–°
                await asyncio.sleep(self.update_interval)
                
        except asyncio.CancelledError:
            logger.debug(f"ç›£æ§ä»»å‹™è¢«å–æ¶ˆ: {position_id}")
        except Exception as e:
            logger.error(f"ç›£æ§ä»»å‹™éŒ¯èª¤ {position_id}: {e}")
    
    def _update_pnl_trackers(self, position_id: str, position: VirtualPosition):
        """æ›´æ–°æœ€å¤§/æœ€å° PnL è¿½è¹¤"""
        current_pnl = position.pnl_pct
        self.max_pnl_tracker[position_id] = max(
            self.max_pnl_tracker[position_id], 
            current_pnl
        )
        self.min_pnl_tracker[position_id] = min(
            self.min_pnl_tracker[position_id], 
            current_pnl
        )
    
    async def _check_lifecycle_events(self, position_id: str, position: VirtualPosition):
        """æª¢æŸ¥ç”Ÿå‘½é€±æœŸäº‹ä»¶"""
        current_pnl = position.pnl_pct
        max_pnl = self.max_pnl_tracker[position_id]
        min_pnl = self.min_pnl_tracker[position_id]
        
        # 1. PnL æ›´æ–°äº‹ä»¶
        if current_pnl != getattr(position, '_last_pnl', None):
            position._last_pnl = current_pnl
            self._emit_event(VirtualPositionEvent.PRICE_UPDATED, position)
        
        # 2. æœ€å¤§/æœ€å° PnL æ›´æ–°
        if max_pnl > getattr(position, '_last_max_pnl', current_pnl):
            position._last_max_pnl = max_pnl
            self._emit_event(VirtualPositionEvent.MAX_PNL_UPDATED, position, max_pnl=max_pnl)
            
        if min_pnl < getattr(position, '_last_min_pnl', current_pnl):
            position._last_min_pnl = min_pnl
            self._emit_event(VirtualPositionEvent.MIN_PNL_UPDATED, position, min_pnl=min_pnl)
        
        # 3. æ¥è¿‘æ­¢ç›ˆ/æ­¢ææª¢æŸ¥
        await self._check_approach_events(position_id, position)
        
        # 4. æ­¢ç›ˆ/æ­¢æ/éæœŸæª¢æŸ¥
        close_reason = await self._check_close_conditions(position_id, position)
        if close_reason:
            await self._close_position(position_id, position, close_reason)
    
    async def _check_approach_events(self, position_id: str, position: VirtualPosition):
        """æª¢æŸ¥æ¥è¿‘æ­¢ç›ˆ/æ­¢æäº‹ä»¶"""
        if position.is_closed:
            return
            
        current_price = position.current_price
        
        if position.direction == 1:  # LONG
            # è¨ˆç®—è·é›¢æ­¢ç›ˆ/æ­¢æçš„æ¯”ä¾‹
            tp_distance = (position.take_profit - current_price) / (position.take_profit - position.entry_price)
            sl_distance = (current_price - position.stop_loss) / (position.entry_price - position.stop_loss)
            
            # æ¥è¿‘æ­¢ç›ˆ
            if 0 < tp_distance <= (1 - self.tp_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.TP_APPROACHING, 
                    position,
                    distance_to_tp=tp_distance,
                    estimated_time_to_tp=self._estimate_time_to_target(position, 'tp')
                )
            
            # æ¥è¿‘æ­¢æ
            if 0 < sl_distance <= (1 - self.sl_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.SL_APPROACHING,
                    position, 
                    distance_to_sl=sl_distance,
                    estimated_time_to_sl=self._estimate_time_to_target(position, 'sl')
                )
                
        else:  # SHORT
            tp_distance = (current_price - position.take_profit) / (position.entry_price - position.take_profit)
            sl_distance = (position.stop_loss - current_price) / (position.stop_loss - position.entry_price)
            
            if 0 < tp_distance <= (1 - self.tp_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.TP_APPROACHING,
                    position,
                    distance_to_tp=tp_distance,
                    estimated_time_to_tp=self._estimate_time_to_target(position, 'tp')
                )
                
            if 0 < sl_distance <= (1 - self.sl_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.SL_APPROACHING,
                    position,
                    distance_to_sl=sl_distance,
                    estimated_time_to_sl=self._estimate_time_to_target(position, 'sl')
                )
    
    async def _check_close_conditions(self, position_id: str, position: VirtualPosition) -> Optional[str]:
        """æª¢æŸ¥å¹³å€‰æ¢ä»¶"""
        if position.is_closed:
            return None
            
        current_price = position.current_price
        current_time = time.time()
        
        # 1. æ­¢ç›ˆè§¸ç™¼
        if position.direction == 1 and current_price >= position.take_profit:
            return "tp"
        elif position.direction == -1 and current_price <= position.take_profit:
            return "tp"
            
        # 2. æ­¢æè§¸ç™¼
        if position.direction == 1 and current_price <= position.stop_loss:
            return "sl"
        elif position.direction == -1 and current_price >= position.stop_loss:
            return "sl"
            
        # 3. éæœŸæª¢æŸ¥ (96å°æ™‚)
        if current_time - position.entry_timestamp > 96 * 3600:
            return "expired"
            
        return None
    
    async def _close_position(self, position_id: str, position: VirtualPosition, reason: str):
        """é—œé–‰å€‰ä½"""
        position.is_closed = True
        position.close_timestamp = time.time()
        position.close_reason = reason
        
        # ç™¼é€å°æ‡‰çš„é—œé–‰äº‹ä»¶
        if reason == "tp":
            event_type = VirtualPositionEvent.TP_TRIGGERED
        elif reason == "sl":
            event_type = VirtualPositionEvent.SL_TRIGGERED
        elif reason == "expired":
            event_type = VirtualPositionEvent.EXPIRED
        else:
            event_type = VirtualPositionEvent.MANUAL_CLOSE
            
        self._emit_event(event_type, position, close_reason=reason)
        self._emit_event(VirtualPositionEvent.CLOSED, position, close_reason=reason)
        
        # è¨˜éŒ„æ­·å²ä¸¦ç§»é™¤ç›£æ§
        self._record_position_history(position_id)
        self.remove_position(position_id)
        
        logger.info(f"è™›æ“¬å€‰ä½é—œé–‰: {position_id}, åŸå› : {reason}, PnL: {position.pnl_pct:.2f}%")
    
    def _emit_event(self, event_type: VirtualPositionEvent, position: VirtualPosition, **metadata):
        """ç™¼é€äº‹ä»¶"""
        event_payload = VirtualPositionEventPayload.create(
            event_type, position, **metadata
        )
        
        # ä¿å­˜åˆ°æ­·å²
        self.position_history[position.signal_id].append(event_payload)
        
        # å‘¼å«å›èª¿
        if self.event_callback:
            try:
                if asyncio.iscoroutinefunction(self.event_callback):
                    asyncio.create_task(self.event_callback(event_payload))
                else:
                    self.event_callback(event_payload)
            except Exception as e:
                logger.error(f"äº‹ä»¶å›èª¿éŒ¯èª¤: {e}")
        
        # è¨˜éŒ„é‡è¦äº‹ä»¶
        if event_type in [
            VirtualPositionEvent.TP_TRIGGERED,
            VirtualPositionEvent.SL_TRIGGERED,
            VirtualPositionEvent.EXPIRED,
            VirtualPositionEvent.CLOSED
        ]:
            logger.info(f"å€‰ä½äº‹ä»¶: {event_type.value} - {position.symbol} PnL: {position.pnl_pct:.2f}%")
    
    def _record_position_history(self, position_id: str):
        """è¨˜éŒ„å€‰ä½å®Œæ•´æ­·å²"""
        if position_id in self.active_positions:
            position = self.active_positions[position_id]
            # å¯ä»¥ä¿å­˜åˆ°æ–‡ä»¶æˆ–æ•¸æ“šåº«
            # self._save_position_history_to_file(position_id)
    
    def _estimate_time_to_target(self, position: VirtualPosition, target_type: str) -> float:
        """ä¼°ç®—åˆ°é”ç›®æ¨™æ™‚é–“ï¼ˆç§’ï¼‰"""
        # ç°¡å–®çš„åŸºæ–¼æœ€è¿‘åƒ¹æ ¼è®Šå‹•é€Ÿåº¦çš„ä¼°ç®—
        try:
            # é€™è£¡å¯ä»¥å¯¦ç¾æ›´è¤‡é›œçš„é æ¸¬é‚è¼¯
            # ç›®å‰è¿”å›å›ºå®šå€¼ä½œç‚ºä½”ä½ç¬¦
            return 300.0  # 5åˆ†é˜
        except:
            return 600.0  # 10åˆ†é˜
    
    def get_position_events(self, position_id: str) -> List[VirtualPositionEventPayload]:
        """ç²å–å€‰ä½çš„æ‰€æœ‰äº‹ä»¶æ­·å²"""
        return self.position_history.get(position_id, [])
    
    def get_active_positions_count(self) -> int:
        """ç²å–æ´»èºå€‰ä½æ•¸é‡"""
        return len(self.active_positions)
    
    def get_position_summary(self, position_id: str) -> Dict:
        """ç²å–å€‰ä½æ‘˜è¦ä¿¡æ¯"""
        if position_id not in self.active_positions:
            return {}
            
        position = self.active_positions[position_id]
        events = self.position_history.get(position_id, [])
        
        return {
            'symbol': position.symbol,
            'direction': 'LONG' if position.direction == 1 else 'SHORT',
            'entry_price': position.entry_price,
            'current_price': position.current_price,
            'pnl_pct': position.pnl_pct,
            'max_pnl': self.max_pnl_tracker.get(position_id, position.pnl_pct),
            'min_pnl': self.min_pnl_tracker.get(position_id, position.pnl_pct),
            'hold_time_seconds': time.time() - position.entry_timestamp,
            'event_count': len(events),
            'is_closed': position.is_closed,
            'close_reason': position.close_reason if position.is_closed else None
        }
```

---

## ğŸ”¥ **3. æ•´åˆåˆ°ç¾æœ‰ VirtualPositionManager**

```python
# src/managers/virtual_position_manager.py - ä¿®æ”¹ç¾æœ‰é¡åˆ¥
import asyncio
import logging
from typing import List, Optional
from src.managers.virtual_position_lifecycle import VirtualPositionLifecycleMonitor
from src.managers.virtual_position_events import VirtualPositionEvent

logger = logging.getLogger(__name__)

class VirtualPositionManager:
    def __init__(self, binance_client):
        self.positions: List = []  # ä¿æŒå…¼å®¹æ€§
        self.binance_client = binance_client
        self._price_cache = {}
        
        # ğŸ”¥ æ–°å¢ï¼šç”Ÿå‘½é€±æœŸç›£æ§å™¨
        self.lifecycle_monitor = VirtualPositionLifecycleMonitor(
            event_callback=self._handle_position_event
        )
    
    def create_virtual_position(self, signal) -> 'VirtualPosition':
        """å‰µå»ºè™›æ“¬å€‰ä½"""
        from src.core.data_models import VirtualPosition
        
        position = VirtualPosition(
            symbol=signal.symbol,
            direction=signal.direction,
            entry_price=signal.entry_price,
            stop_loss=signal.stop_loss,
            take_profit=signal.take_profit,
            leverage=signal.leverage,
            entry_timestamp=signal.timestamp,
            signal_id=f"{signal.symbol}_{int(signal.timestamp)}"
        )
        
        # ğŸ”¥ æ·»åŠ åˆ°ç”Ÿå‘½é€±æœŸç›£æ§
        self.lifecycle_monitor.add_position(position)
        
        # ä¿æŒç¾æœ‰åˆ—è¡¨å…¼å®¹æ€§
        self.positions.append(position)
        
        logger.debug(f"å‰µå»ºè™›æ“¬å€‰ä½: {position}")
        return position
    
    def _handle_position_event(self, event_payload):
        """è™•ç†å€‰ä½äº‹ä»¶"""
        # é€™è£¡å¯ä»¥å¯¦ç¾äº‹ä»¶è™•ç†é‚è¼¯
        if event_payload.event_type == VirtualPositionEvent.CLOSED:
            # å€‰ä½é—œé–‰æ™‚æ­¸æª”æ•¸æ“š
            self._archive_closed_position(event_payload)
        elif event_payload.event_type in [
            VirtualPositionEvent.TP_APPROACHING,
            VirtualPositionEvent.SL_APPROACHING
        ]:
            # æ¥è¿‘æ­¢ç›ˆæ­¢ææ™‚ç™¼é€é€šçŸ¥
            self._send_approach_notification(event_payload)
    
    def _archive_closed_position(self, event_payload):
        """æ­¸æª”é—œé–‰çš„å€‰ä½"""
        # å¯¦ç¾ ML è¨“ç·´æ•¸æ“šæ­¸æª”é‚è¼¯
        position_data = {
            'symbol': event_payload.symbol,
            'direction': 1 if event_payload.metadata.get('direction') == 'LONG' else -1,
            'entry_price': event_payload.metadata.get('entry_price', 0),
            'exit_price': event_payload.current_price,
            'pnl_pct': event_payload.pnl_pct,
            'hold_duration': event_payload.timestamp - event_payload.metadata.get('entry_timestamp', event_payload.timestamp),
            'close_reason': event_payload.metadata.get('close_reason', 'unknown'),
            'max_pnl': event_payload.max_pnl,
            'min_pnl': event_payload.min_pnl
        }
        # ä¿å­˜åˆ° ML è¨“ç·´æ•¸æ“š
        # self.data_archiver.archive_position(position_data)
    
    def _send_approach_notification(self, event_payload):
        """ç™¼é€æ¥è¿‘é€šçŸ¥"""
        reason = "æ­¢ç›ˆ" if event_payload.event_type == VirtualPositionEvent.TP_APPROACHING else "æ­¢æ"
        logger.info(f"ã€æé†’ã€‘{event_payload.symbol} æ¥è¿‘{reason}ï¼Œç•¶å‰PnL: {event_payload.pnl_pct:.2f}%")
    
    async def update_all_prices_async(self, binance_client):
        """æ‰¹é‡æ›´æ–°åƒ¹æ ¼"""
        # ... ç¾æœ‰é‚è¼¯ ...
        
        # æ›´æ–°ç”Ÿå‘½é€±æœŸç›£æ§å™¨ä¸­çš„åƒ¹æ ¼
        for pos in self.lifecycle_monitor.active_positions.values():
            if pos.symbol in prices:
                pos.current_price = prices[pos.symbol]
                # PnL æœƒåœ¨ç›£æ§å¾ªç’°ä¸­è‡ªå‹•æ›´æ–°
        
        return []  # å·²ç”±ç”Ÿå‘½é€±æœŸç›£æ§å™¨è™•ç†é—œé–‰é‚è¼¯
    
    def get_active_positions(self) -> List:
        """ç²å–æ´»èºå€‰ä½ï¼ˆå…¼å®¹æ€§ï¼‰"""
        return list(self.lifecycle_monitor.active_positions.values())
    
    def cleanup_expired_positions(self, max_age_hours: int = 100):
        """æ¸…ç†éæœŸå€‰ä½ï¼ˆå…¼å®¹æ€§ï¼‰"""
        # ç”Ÿå‘½é€±æœŸç›£æ§å™¨æœƒè‡ªå‹•è™•ç†éæœŸ
        pass
```

---

## ğŸ”¥ **4. äº‹ä»¶è™•ç†å›èª¿ç¯„ä¾‹**

```python
# src/managers/virtual_position_events.py - æ–°å¢å›èª¿ç¯„ä¾‹
async def default_event_handler(event_payload: VirtualPositionEventPayload):
    """é»˜èªäº‹ä»¶è™•ç†å™¨"""
    from src.integrations.discord_bot import DiscordBot
    
    if event_payload.event_type == VirtualPositionEvent.TP_TRIGGERED:
        message = f"ğŸ¯ **æ­¢ç›ˆè§¸ç™¼**\n{event_payload.symbol} ç›ˆåˆ© {event_payload.pnl_pct:.2f}%"
        await DiscordBot.send_notification(message)
        
    elif event_payload.event_type == VirtualPositionEvent.SL_TRIGGERED:
        message = f"âš ï¸ **æ­¢æè§¸ç™¼**\n{event_payload.symbol} è™§æ {abs(event_payload.pnl_pct):.2f}%"
        await DiscordBot.send_notification(message)
        
    elif event_payload.event_type == VirtualPositionEvent.EXPIRED:
        message = f"â° **å€‰ä½éæœŸ**\n{event_payload.symbol} PnL: {event_payload.pnl_pct:.2f}%"
        await DiscordBot.send_notification(message)
        
    elif event_payload.event_type == VirtualPositionEvent.TP_APPROACHING:
        distance = event_payload.metadata.get('distance_to_tp', 0)
        message = f"ğŸš€ **æ¥è¿‘æ­¢ç›ˆ**\n{event_payload.symbol} è·é›¢æ­¢ç›ˆ {(1-distance)*100:.1f}%"
        await DiscordBot.send_notification(message)
```

---

## ğŸ“Š **ä½¿ç”¨ç¯„ä¾‹**

```python
# åœ¨ä¸»ç¨‹åºä¸­ä½¿ç”¨
async def main():
    # å‰µå»ºç›£æ§å™¨
    monitor = VirtualPositionLifecycleMonitor(
        event_callback=default_event_handler
    )
    
    # å‰µå»ºå€‰ä½
    position = VirtualPosition(
        symbol="BTCUSDT",
        direction=1,
        entry_price=60000,
        stop_loss=59000,
        take_profit=63000,
        leverage=10,
        entry_timestamp=time.time(),
        signal_id="BTCUSDT_1730000000"
    )
    
    # æ·»åŠ ç›£æ§
    monitor.add_position(position)
    
    # ç²å–å€‰ä½æ‘˜è¦
    summary = monitor.get_position_summary("BTCUSDT_1730000000")
    print(f"å€‰ä½æ‘˜è¦: {summary}")
    
    # ç²å–äº‹ä»¶æ­·å²
    events = monitor.get_position_events("BTCUSDT_1730000000")
    print(f"äº‹ä»¶æ•¸é‡: {len(events)}")
```

---