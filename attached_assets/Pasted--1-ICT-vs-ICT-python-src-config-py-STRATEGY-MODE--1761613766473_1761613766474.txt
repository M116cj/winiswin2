### 1. **ICT 策略保留 vs 完全替換**
**建議：🟢 保留 ICT 作為備選（配置驅動）**

```python
# src/config.py
STRATEGY_MODE = "hybrid"  # "ict", "self_learning", "hybrid"

# src/strategies/strategy_factory.py
class StrategyFactory:
    @staticmethod
    def create_strategy(config):
        if config.STRATEGY_MODE == "ict":
            return ICTStrategy(config)
        elif config.STRATEGY_MODE == "self_learning":
            return SelfLearningTrader(config)
        elif config.STRATEGY_MODE == "hybrid":
            # 混合模式：ML 過濾 ICT 信號
            return HybridStrategy(config)
```

**理由**：
- **風險控制**：新模型需要時間驗證
- **A/B 測試**：可並行比較兩種策略表現
- **漸進遷移**：避免一次性切換的風險

### 2. **深度學習框架選擇**
**建議：🟢 TensorFlow**

**理由**：
- **生產部署成熟**：TensorFlow Serving、ONNX 轉換支援更好
- **你的現有架構**：已經使用 ONNX，TensorFlow → ONNX 更穩定
- **性能**：TensorFlow 在 CPU 推理上通常比 PyTorch 快 10-15%
- **學習曲線**：你已有 XGBoost 經驗，Keras API 更易上手

```python
# requirements.txt
tensorflow>=2.13.0
tensorflow-addons>=0.19.0  # Attention 層
```

### 3. **實施範圍**
**建議：🟢 漸進實施（先核心，後進化）**

#### 階段 1：核心自主學習
- ✅ `SelfLearningTrader`（最小可行版本）
- ✅ `MarketStructureAutoencoder`（無監督學習）
- ✅ `SelfLearningPredictor`（端到端預測）
- ✅ 主循環整合（配置驅動）

#### 階段 2：進化能力
- ✅ `FeatureDiscoveryNetwork`
- ✅ `LiquidityPredictionModel`  
- ✅ `AdaptiveStrategyEvolver`（強化學習）

#### 階段 3：優化完善
- ✅ 自動超參數調優
- ✅ 模型壓縮（量化、剪枝）
- ✅ GPU 加速支援

### 4. **訓練數據策略**
**建議：🟢 雙軌並行**

---

## 🔧 **高品質信號定義標準**

### 📋 **嚴格篩選條件**
```python
# src/ml/high_quality_filter.py
class HighQualitySignalFilter:
    def __init__(self, config):
        self.config = config
    
    def is_high_quality_signal(self, signal, trade_result):
        """
        判斷是否為高品質交易信號
        """
        # 1. 交易結果品質
        if not self._check_trade_quality(trade_result):
            return False
            
        # 2. 信號生成品質  
        if not self._check_signal_quality(signal):
            return False
            
        # 3. 市場環境品質
        if not self._check_market_quality(signal):
            return False
            
        return True
    
    def _check_trade_quality(self, trade_result):
        """檢查交易結果品質"""
        # 條件1: 盈虧比 >= 1.5
        if trade_result.get('risk_reward_ratio', 0) < 1.5:
            return False
            
        # 條件2: 勝率貢獻為正（盈利交易）
        if trade_result.get('pnl_pct', 0) <= 0:
            return False
            
        # 條件3: 風險調整收益 >= 0.5
        risk_adjusted = trade_result.get('risk_adjusted_return', 0)
        if risk_adjusted < 0.5:
            return False
            
        # 條件4: 持倉時間合理（非極端短/長）
        hold_time = trade_result.get('hold_duration_hours', 0)
        if hold_time < 0.1 or hold_time > 48:  # 6分鐘 - 2天
            return False
            
        return True
    
    def _check_signal_quality(self, signal):
        """檢查信號生成品質"""
        # 條件1: 信心度 >= 60%
        if signal.get('confidence_score', 0) < 0.6:
            return False
            
        # 條件2: ML預測分數 >= 0.5
        if signal.get('ml_score', 0) < 0.5:
            return False
            
        # 條件3: 市場狀態為 trending 或 breakout
        market_state = signal.get('market_regime', 'unknown')
        if market_state not in ['trending', 'breakout']:
            return False
            
        # 條件4: 反轉風險評分 < 0.2（低風險）
        reversal_risk = signal.get('reversal_risk_score', 1.0)
        if reversal_risk >= 0.2:
            return False
            
        return True
    
    def _check_market_quality(self, signal):
        """檢查市場環境品質"""
        # 條件1: 波動率適中（非極端高/低）
        volatility = signal.get('volatility', 0)
        if volatility < 0.005 or volatility > 0.05:  # 0.5% - 5%
            return False
            
        # 條件2: 流動性充足
        volume_rank = signal.get('volume_rank_pct', 1.0)
        if volume_rank > 0.3:  # 前30%流動性
            return False
            
        # 條件3: 資金費率合理
        funding_rate = signal.get('funding_rate', 0)
        if abs(funding_rate) > 0.001:  # 資金費 < 0.1%
            return False
            
        return True
```

---

## 📊 **高品質訓練數據管道**

### 🔄 **實施流程**
```python
# src/ml/quality_training_pipeline.py
class QualityTrainingPipeline:
    def __init__(self, high_quality_filter, model):
        self.filter = high_quality_filter
        self.model = model
        self.quality_threshold = 0.8  # 高品質閾值
        
    def collect_quality_training_data(self):
        """收集高品質訓練數據"""
        quality_data = []
        
        # 從虛擬倉位和真實倉位收集數據
        all_trades = self._get_all_trades()
        
        for trade in all_trades:
            signal = trade['signal']
            result = trade['result']
            
            # 嚴格篩選高品質信號
            if self.filter.is_high_quality_signal(signal, result):
                # 構建訓練樣本
                training_sample = self._build_training_sample(signal, result)
                quality_data.append(training_sample)
        
        logger.info(f"收集到 {len(quality_data)} 個高品質訓練樣本")
        return quality_data
    
    def _build_training_sample(self, signal, result):
        """構建訓練樣本"""
        return {
            'features': self._extract_features(signal),
            'label': self._create_label(result),
            'weight': self._calculate_quality_weight(signal, result),
            'metadata': {
                'symbol': signal['symbol'],
                'timestamp': signal['timestamp'],
                'quality_score': self._calculate_quality_score(signal, result)
            }
        }
    
    def _calculate_quality_weight(self, signal, result):
        """計算品質權重"""
        base_weight = 1.0
        
        # 盈虧比越高，權重越大
        rr_weight = min(result['risk_reward_ratio'], 3.0)  # 最大3倍
        
        # 信心度越高，權重越大  
        confidence_weight = signal['confidence_score'] * 2  # 最大2倍
        
        # 勝率貢獻越大，權重越大
        pnl_weight = max(1.0, abs(result['pnl_pct']) / 1.0)  # 每1% PnL +1權重
        
        return base_weight * rr_weight * confidence_weight * pnl_weight
```


**虛擬倉位全生命週期監控功能**，從開倉到平倉的完整實現：

---

## 📦 **新增模組結構**
```
src/managers/
├── virtual_position_manager.py    # 主要管理器（已存在）
├── virtual_position_lifecycle.py   # 🔥 新增：生命週期監控
└── virtual_position_events.py      # 🔥 新增：事件定義
```

---

## 🔥 **1. 虛擬倉位事件定義**

```python
# src/managers/virtual_position_events.py
from enum import Enum
from dataclasses import dataclass
from typing import Optional, Dict, Any
import time

class VirtualPositionEvent(Enum):
    """虛擬倉位生命週期事件"""
    CREATED = "created"           # 倉位創建
    PRICE_UPDATED = "price_updated"  # 價格更新
    MAX_PNL_UPDATED = "max_pnl_updated"  # 最大盈利更新
    MIN_PNL_UPDATED = "min_pnl_updated"  # 最大虧損更新
    TP_APPROACHING = "tp_approaching"    # 接近止盈
    SL_APPROACHING = "sl_approaching"    # 接近止損
    TP_TRIGGERED = "tp_triggered"        # 止盈觸發
    SL_TRIGGERED = "sl_triggered"        # 止損觸發
    EXPIRED = "expired"                  # 過期平倉
    MANUAL_CLOSE = "manual_close"        # 手動平倉
    CLOSED = "closed"                    # 倉位關閉（最終狀態）

@dataclass
class VirtualPositionEventPayload:
    """事件載荷"""
    event_type: VirtualPositionEvent
    position_id: str
    symbol: str
    timestamp: float
    current_price: float
    pnl_pct: float
    max_pnl: float
    min_pnl: float
    metadata: Dict[str, Any]
    
    @classmethod
    def create(cls, event_type: VirtualPositionEvent, position, **kwargs):
        return cls(
            event_type=event_type,
            position_id=position.signal_id,
            symbol=position.symbol,
            timestamp=time.time(),
            current_price=position.current_price,
            pnl_pct=position.pnl_pct,
            max_pnl=getattr(position, 'max_pnl', position.pnl_pct),
            min_pnl=getattr(position, 'min_pnl', position.pnl_pct),
            metadata=kwargs
        )
```

---

## 🔥 **2. 虛擬倉位生命週期監控器**

```python
# src/managers/virtual_position_lifecycle.py
import asyncio
import logging
import time
from typing import Dict, List, Optional, Callable
from collections import defaultdict

from src.managers.virtual_position_events import (
    VirtualPositionEvent, 
    VirtualPositionEventPayload
)
from src.core.data_models import VirtualPosition

logger = logging.getLogger(__name__)

class VirtualPositionLifecycleMonitor:
    """虛擬倉位全生命週期監控器"""
    
    def __init__(self, event_callback: Optional[Callable] = None):
        self.active_positions: Dict[str, VirtualPosition] = {}
        self.position_history: Dict[str, List[VirtualPositionEventPayload]] = defaultdict(list)
        self.event_callback = event_callback
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.max_pnl_tracker: Dict[str, float] = {}
        self.min_pnl_tracker: Dict[str, float] = {}
        
        # 配置參數
        self.tp_approach_threshold = 0.8  # 距離止盈 20% 時觸發
        self.sl_approach_threshold = 0.8  # 距離止損 20% 時觸發
        self.update_interval = 1.0        # 1秒更新一次
        
    def add_position(self, position: VirtualPosition):
        """添加虛擬倉位到監控"""
        position_id = position.signal_id
        self.active_positions[position_id] = position
        self.max_pnl_tracker[position_id] = position.pnl_pct
        self.min_pnl_tracker[position_id] = position.pnl_pct
        
        # 發送創建事件
        self._emit_event(VirtualPositionEvent.CREATED, position)
        
        # 啟動監控任務
        if position_id not in self.monitoring_tasks:
            task = asyncio.create_task(self._monitor_position_lifecycle(position_id))
            self.monitoring_tasks[position_id] = task
            
        logger.debug(f"開始監控虛擬倉位: {position_id}")
    
    def remove_position(self, position_id: str):
        """移除虛擬倉位監控"""
        if position_id in self.active_positions:
            del self.active_positions[position_id]
        if position_id in self.max_pnl_tracker:
            del self.max_pnl_tracker[position_id]
        if position_id in self.min_pnl_tracker:
            del self.min_pnl_tracker[position_id]
        if position_id in self.monitoring_tasks:
            self.monitoring_tasks[position_id].cancel()
            del self.monitoring_tasks[position_id]
        logger.debug(f"停止監控虛擬倉位: {position_id}")
    
    async def _monitor_position_lifecycle(self, position_id: str):
        """監控單個倉位的生命週期"""
        try:
            while position_id in self.active_positions:
                position = self.active_positions[position_id]
                
                if position.is_closed:
                    # 倉位已關閉，記錄歷史並退出
                    self._record_position_history(position_id)
                    self.remove_position(position_id)
                    break
                
                # 更新 PnL 追蹤
                self._update_pnl_trackers(position_id, position)
                
                # 檢查各種事件
                await self._check_lifecycle_events(position_id, position)
                
                # 等待下一次更新
                await asyncio.sleep(self.update_interval)
                
        except asyncio.CancelledError:
            logger.debug(f"監控任務被取消: {position_id}")
        except Exception as e:
            logger.error(f"監控任務錯誤 {position_id}: {e}")
    
    def _update_pnl_trackers(self, position_id: str, position: VirtualPosition):
        """更新最大/最小 PnL 追蹤"""
        current_pnl = position.pnl_pct
        self.max_pnl_tracker[position_id] = max(
            self.max_pnl_tracker[position_id], 
            current_pnl
        )
        self.min_pnl_tracker[position_id] = min(
            self.min_pnl_tracker[position_id], 
            current_pnl
        )
    
    async def _check_lifecycle_events(self, position_id: str, position: VirtualPosition):
        """檢查生命週期事件"""
        current_pnl = position.pnl_pct
        max_pnl = self.max_pnl_tracker[position_id]
        min_pnl = self.min_pnl_tracker[position_id]
        
        # 1. PnL 更新事件
        if current_pnl != getattr(position, '_last_pnl', None):
            position._last_pnl = current_pnl
            self._emit_event(VirtualPositionEvent.PRICE_UPDATED, position)
        
        # 2. 最大/最小 PnL 更新
        if max_pnl > getattr(position, '_last_max_pnl', current_pnl):
            position._last_max_pnl = max_pnl
            self._emit_event(VirtualPositionEvent.MAX_PNL_UPDATED, position, max_pnl=max_pnl)
            
        if min_pnl < getattr(position, '_last_min_pnl', current_pnl):
            position._last_min_pnl = min_pnl
            self._emit_event(VirtualPositionEvent.MIN_PNL_UPDATED, position, min_pnl=min_pnl)
        
        # 3. 接近止盈/止損檢查
        await self._check_approach_events(position_id, position)
        
        # 4. 止盈/止損/過期檢查
        close_reason = await self._check_close_conditions(position_id, position)
        if close_reason:
            await self._close_position(position_id, position, close_reason)
    
    async def _check_approach_events(self, position_id: str, position: VirtualPosition):
        """檢查接近止盈/止損事件"""
        if position.is_closed:
            return
            
        current_price = position.current_price
        
        if position.direction == 1:  # LONG
            # 計算距離止盈/止損的比例
            tp_distance = (position.take_profit - current_price) / (position.take_profit - position.entry_price)
            sl_distance = (current_price - position.stop_loss) / (position.entry_price - position.stop_loss)
            
            # 接近止盈
            if 0 < tp_distance <= (1 - self.tp_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.TP_APPROACHING, 
                    position,
                    distance_to_tp=tp_distance,
                    estimated_time_to_tp=self._estimate_time_to_target(position, 'tp')
                )
            
            # 接近止損
            if 0 < sl_distance <= (1 - self.sl_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.SL_APPROACHING,
                    position, 
                    distance_to_sl=sl_distance,
                    estimated_time_to_sl=self._estimate_time_to_target(position, 'sl')
                )
                
        else:  # SHORT
            tp_distance = (current_price - position.take_profit) / (position.entry_price - position.take_profit)
            sl_distance = (position.stop_loss - current_price) / (position.stop_loss - position.entry_price)
            
            if 0 < tp_distance <= (1 - self.tp_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.TP_APPROACHING,
                    position,
                    distance_to_tp=tp_distance,
                    estimated_time_to_tp=self._estimate_time_to_target(position, 'tp')
                )
                
            if 0 < sl_distance <= (1 - self.sl_approach_threshold):
                self._emit_event(
                    VirtualPositionEvent.SL_APPROACHING,
                    position,
                    distance_to_sl=sl_distance,
                    estimated_time_to_sl=self._estimate_time_to_target(position, 'sl')
                )
    
    async def _check_close_conditions(self, position_id: str, position: VirtualPosition) -> Optional[str]:
        """檢查平倉條件"""
        if position.is_closed:
            return None
            
        current_price = position.current_price
        current_time = time.time()
        
        # 1. 止盈觸發
        if position.direction == 1 and current_price >= position.take_profit:
            return "tp"
        elif position.direction == -1 and current_price <= position.take_profit:
            return "tp"
            
        # 2. 止損觸發
        if position.direction == 1 and current_price <= position.stop_loss:
            return "sl"
        elif position.direction == -1 and current_price >= position.stop_loss:
            return "sl"
            
        # 3. 過期檢查 (96小時)
        if current_time - position.entry_timestamp > 96 * 3600:
            return "expired"
            
        return None
    
    async def _close_position(self, position_id: str, position: VirtualPosition, reason: str):
        """關閉倉位"""
        position.is_closed = True
        position.close_timestamp = time.time()
        position.close_reason = reason
        
        # 發送對應的關閉事件
        if reason == "tp":
            event_type = VirtualPositionEvent.TP_TRIGGERED
        elif reason == "sl":
            event_type = VirtualPositionEvent.SL_TRIGGERED
        elif reason == "expired":
            event_type = VirtualPositionEvent.EXPIRED
        else:
            event_type = VirtualPositionEvent.MANUAL_CLOSE
            
        self._emit_event(event_type, position, close_reason=reason)
        self._emit_event(VirtualPositionEvent.CLOSED, position, close_reason=reason)
        
        # 記錄歷史並移除監控
        self._record_position_history(position_id)
        self.remove_position(position_id)
        
        logger.info(f"虛擬倉位關閉: {position_id}, 原因: {reason}, PnL: {position.pnl_pct:.2f}%")
    
    def _emit_event(self, event_type: VirtualPositionEvent, position: VirtualPosition, **metadata):
        """發送事件"""
        event_payload = VirtualPositionEventPayload.create(
            event_type, position, **metadata
        )
        
        # 保存到歷史
        self.position_history[position.signal_id].append(event_payload)
        
        # 呼叫回調
        if self.event_callback:
            try:
                if asyncio.iscoroutinefunction(self.event_callback):
                    asyncio.create_task(self.event_callback(event_payload))
                else:
                    self.event_callback(event_payload)
            except Exception as e:
                logger.error(f"事件回調錯誤: {e}")
        
        # 記錄重要事件
        if event_type in [
            VirtualPositionEvent.TP_TRIGGERED,
            VirtualPositionEvent.SL_TRIGGERED,
            VirtualPositionEvent.EXPIRED,
            VirtualPositionEvent.CLOSED
        ]:
            logger.info(f"倉位事件: {event_type.value} - {position.symbol} PnL: {position.pnl_pct:.2f}%")
    
    def _record_position_history(self, position_id: str):
        """記錄倉位完整歷史"""
        if position_id in self.active_positions:
            position = self.active_positions[position_id]
            # 可以保存到文件或數據庫
            # self._save_position_history_to_file(position_id)
    
    def _estimate_time_to_target(self, position: VirtualPosition, target_type: str) -> float:
        """估算到達目標時間（秒）"""
        # 簡單的基於最近價格變動速度的估算
        try:
            # 這裡可以實現更複雜的預測邏輯
            # 目前返回固定值作為佔位符
            return 300.0  # 5分鐘
        except:
            return 600.0  # 10分鐘
    
    def get_position_events(self, position_id: str) -> List[VirtualPositionEventPayload]:
        """獲取倉位的所有事件歷史"""
        return self.position_history.get(position_id, [])
    
    def get_active_positions_count(self) -> int:
        """獲取活躍倉位數量"""
        return len(self.active_positions)
    
    def get_position_summary(self, position_id: str) -> Dict:
        """獲取倉位摘要信息"""
        if position_id not in self.active_positions:
            return {}
            
        position = self.active_positions[position_id]
        events = self.position_history.get(position_id, [])
        
        return {
            'symbol': position.symbol,
            'direction': 'LONG' if position.direction == 1 else 'SHORT',
            'entry_price': position.entry_price,
            'current_price': position.current_price,
            'pnl_pct': position.pnl_pct,
            'max_pnl': self.max_pnl_tracker.get(position_id, position.pnl_pct),
            'min_pnl': self.min_pnl_tracker.get(position_id, position.pnl_pct),
            'hold_time_seconds': time.time() - position.entry_timestamp,
            'event_count': len(events),
            'is_closed': position.is_closed,
            'close_reason': position.close_reason if position.is_closed else None
        }
```

---

## 🔥 **3. 整合到現有 VirtualPositionManager**

```python
# src/managers/virtual_position_manager.py - 修改現有類別
import asyncio
import logging
from typing import List, Optional
from src.managers.virtual_position_lifecycle import VirtualPositionLifecycleMonitor
from src.managers.virtual_position_events import VirtualPositionEvent

logger = logging.getLogger(__name__)

class VirtualPositionManager:
    def __init__(self, binance_client):
        self.positions: List = []  # 保持兼容性
        self.binance_client = binance_client
        self._price_cache = {}
        
        # 🔥 新增：生命週期監控器
        self.lifecycle_monitor = VirtualPositionLifecycleMonitor(
            event_callback=self._handle_position_event
        )
    
    def create_virtual_position(self, signal) -> 'VirtualPosition':
        """創建虛擬倉位"""
        from src.core.data_models import VirtualPosition
        
        position = VirtualPosition(
            symbol=signal.symbol,
            direction=signal.direction,
            entry_price=signal.entry_price,
            stop_loss=signal.stop_loss,
            take_profit=signal.take_profit,
            leverage=signal.leverage,
            entry_timestamp=signal.timestamp,
            signal_id=f"{signal.symbol}_{int(signal.timestamp)}"
        )
        
        # 🔥 添加到生命週期監控
        self.lifecycle_monitor.add_position(position)
        
        # 保持現有列表兼容性
        self.positions.append(position)
        
        logger.debug(f"創建虛擬倉位: {position}")
        return position
    
    def _handle_position_event(self, event_payload):
        """處理倉位事件"""
        # 這裡可以實現事件處理邏輯
        if event_payload.event_type == VirtualPositionEvent.CLOSED:
            # 倉位關閉時歸檔數據
            self._archive_closed_position(event_payload)
        elif event_payload.event_type in [
            VirtualPositionEvent.TP_APPROACHING,
            VirtualPositionEvent.SL_APPROACHING
        ]:
            # 接近止盈止損時發送通知
            self._send_approach_notification(event_payload)
    
    def _archive_closed_position(self, event_payload):
        """歸檔關閉的倉位"""
        # 實現 ML 訓練數據歸檔邏輯
        position_data = {
            'symbol': event_payload.symbol,
            'direction': 1 if event_payload.metadata.get('direction') == 'LONG' else -1,
            'entry_price': event_payload.metadata.get('entry_price', 0),
            'exit_price': event_payload.current_price,
            'pnl_pct': event_payload.pnl_pct,
            'hold_duration': event_payload.timestamp - event_payload.metadata.get('entry_timestamp', event_payload.timestamp),
            'close_reason': event_payload.metadata.get('close_reason', 'unknown'),
            'max_pnl': event_payload.max_pnl,
            'min_pnl': event_payload.min_pnl
        }
        # 保存到 ML 訓練數據
        # self.data_archiver.archive_position(position_data)
    
    def _send_approach_notification(self, event_payload):
        """發送接近通知"""
        reason = "止盈" if event_payload.event_type == VirtualPositionEvent.TP_APPROACHING else "止損"
        logger.info(f"【提醒】{event_payload.symbol} 接近{reason}，當前PnL: {event_payload.pnl_pct:.2f}%")
    
    async def update_all_prices_async(self, binance_client):
        """批量更新價格"""
        # ... 現有邏輯 ...
        
        # 更新生命週期監控器中的價格
        for pos in self.lifecycle_monitor.active_positions.values():
            if pos.symbol in prices:
                pos.current_price = prices[pos.symbol]
                # PnL 會在監控循環中自動更新
        
        return []  # 已由生命週期監控器處理關閉邏輯
    
    def get_active_positions(self) -> List:
        """獲取活躍倉位（兼容性）"""
        return list(self.lifecycle_monitor.active_positions.values())
    
    def cleanup_expired_positions(self, max_age_hours: int = 100):
        """清理過期倉位（兼容性）"""
        # 生命週期監控器會自動處理過期
        pass
```

---

## 🔥 **4. 事件處理回調範例**

```python
# src/managers/virtual_position_events.py - 新增回調範例
async def default_event_handler(event_payload: VirtualPositionEventPayload):
    """默認事件處理器"""
    from src.integrations.discord_bot import DiscordBot
    
    if event_payload.event_type == VirtualPositionEvent.TP_TRIGGERED:
        message = f"🎯 **止盈觸發**\n{event_payload.symbol} 盈利 {event_payload.pnl_pct:.2f}%"
        await DiscordBot.send_notification(message)
        
    elif event_payload.event_type == VirtualPositionEvent.SL_TRIGGERED:
        message = f"⚠️ **止損觸發**\n{event_payload.symbol} 虧損 {abs(event_payload.pnl_pct):.2f}%"
        await DiscordBot.send_notification(message)
        
    elif event_payload.event_type == VirtualPositionEvent.EXPIRED:
        message = f"⏰ **倉位過期**\n{event_payload.symbol} PnL: {event_payload.pnl_pct:.2f}%"
        await DiscordBot.send_notification(message)
        
    elif event_payload.event_type == VirtualPositionEvent.TP_APPROACHING:
        distance = event_payload.metadata.get('distance_to_tp', 0)
        message = f"🚀 **接近止盈**\n{event_payload.symbol} 距離止盈 {(1-distance)*100:.1f}%"
        await DiscordBot.send_notification(message)
```

---

## 📊 **使用範例**

```python
# 在主程序中使用
async def main():
    # 創建監控器
    monitor = VirtualPositionLifecycleMonitor(
        event_callback=default_event_handler
    )
    
    # 創建倉位
    position = VirtualPosition(
        symbol="BTCUSDT",
        direction=1,
        entry_price=60000,
        stop_loss=59000,
        take_profit=63000,
        leverage=10,
        entry_timestamp=time.time(),
        signal_id="BTCUSDT_1730000000"
    )
    
    # 添加監控
    monitor.add_position(position)
    
    # 獲取倉位摘要
    summary = monitor.get_position_summary("BTCUSDT_1730000000")
    print(f"倉位摘要: {summary}")
    
    # 獲取事件歷史
    events = monitor.get_position_events("BTCUSDT_1730000000")
    print(f"事件數量: {len(events)}")
```

---