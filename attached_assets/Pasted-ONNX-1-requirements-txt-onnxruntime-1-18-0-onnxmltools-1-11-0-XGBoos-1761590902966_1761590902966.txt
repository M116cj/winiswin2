ONNXæ¨ç†åŠ é€Ÿ
å®Œæ•´å¯¦æ–½æ­¥é©Ÿ
æ­¥é©Ÿ 1ï¼šå®‰è£ä¾è³´
# requirements.txt æ–°å¢
onnxruntime>=1.18.0
onnxmltools>=1.11.0  # ç”¨æ–¼ XGBoost â†’ ONNX è½‰æ›
æ­¥é©Ÿ 2ï¼šæ–°å¢æ¨¡å‹è½‰æ›è…³æœ¬ï¼ˆä¸€æ¬¡æ€§ï¼‰
# scripts/convert_xgboost_to_onnx.py
import pickle
import onnxruntime as ort
from onnxmltools import convert_xgboost
from onnxmltools.convert.common.data_types import FloatTensorType

def convert_model(model_path: str, onnx_path: str, input_shape=(1, 31)):
    """å°‡ XGBoost æ¨¡å‹è½‰ç‚º ONNX"""
    # è¼‰å…¥ç¾æœ‰æ¨¡å‹
    with open(model_path, 'rb') as f:
        model = pickle.load(f)
    
    # å®šç¾©è¼¸å…¥æ ¼å¼ (N, 31 ç‰¹å¾µ)
    initial_type = [('float_input', FloatTensorType(input_shape))]
    
    # è½‰æ›ç‚º ONNX
    onnx_model = convert_xgboost(model, initial_types=initial_type)
    
    # ä¿å­˜
    with open(onnx_path, 'wb') as f:
        f.write(onnx_model.SerializeToString())
    
    print(f"âœ… æ¨¡å‹å·²è½‰æ›: {onnx_path}")
    return onnx_path

if __name__ == "__main__":
    convert_model(
        model_path="data/models/xgboost_model.pkl",
        onnx_path="data/models/model.onnx"
    )
ğŸ“Œ åŸ·è¡Œä¸€æ¬¡å³å¯ï¼špython scripts/convert_xgboost_to_onnx.py 

æ­¥é©Ÿ 3ï¼šé‡å¯« MLPredictorï¼ˆæ”¯æ´ ONNXï¼‰

# src/ml/predictor.py
import numpy as np
import onnxruntime as ort
from typing import List, Union

class MLPredictor:
    def __init__(self, model_path: str):
        # å„ªå…ˆè¼‰å…¥ ONNX æ¨¡å‹ï¼ˆè‹¥å­˜åœ¨ï¼‰
        onnx_path = model_path.replace('.pkl', '.onnx')
        try:
            self.session = ort.InferenceSession(onnx_path)
            self.use_onnx = True
            print("ğŸš€ ä½¿ç”¨ ONNX æ¨ç†å¼•æ“")
        except Exception as e:
            print(f"âš ï¸ ONNX è¼‰å…¥å¤±æ•—ï¼Œå›é€€åˆ° XGBoost: {e}")
            self._load_xgboost_model(model_path)
            self.use_onnx = False

    def _load_xgboost_model(self, model_path: str):
        import pickle
        with open(model_path, 'rb') as f:
            self.model = pickle.load(f)

    def predict_batch(self, features_list: List[np.ndarray]) -> np.ndarray:
        """
        æ‰¹é‡é æ¸¬ - è‡ªå‹•é¸æ“‡ ONNX æˆ– XGBoost
        """
        # åˆä½µç‚ºå–®ä¸€çŸ©é™£ (N, 31)
        X = np.vstack(features_list).astype(np.float32)
        
        if self.use_onnx:
            # ONNX æ¨ç†
            ort_inputs = {self.session.get_inputs()[0].name: X}
            ort_outs = self.session.run(None, ort_inputs)
            return ort_outs[0].flatten()  # shape: (N,)
        else:
            # å›é€€åˆ° XGBoost
            return self.model.predict(X)
æ­¥é©Ÿ 4ï¼šä¿®æ”¹ç‰¹å¾µæå–ï¼ˆç¢ºä¿ dtype ä¸€è‡´ï¼‰

# src/ml/data_processor.py
def extract_features_for_prediction(signal) -> np.ndarray:
    """æå– 31 å€‹ç‰¹å¾µï¼Œè¿”å› float32 é™£åˆ—ï¼ˆONNX å‹å¥½ï¼‰"""
    features = [
        signal.confidence_score,
        float(signal.leverage),
        signal.rsi_entry,
        signal.atr_entry,
        # ... å…¶ä»– 27 å€‹ç‰¹å¾µ
    ]
    return np.array(features, dtype=np.float32).reshape(1, -1)  # (1, 31)

æ­¥é©Ÿ 5ï¼šåœ¨ä¸»å¾ªç’°ä¸­ä½¿ç”¨æ‰¹é‡é æ¸¬

# src/main.py
async def scan_and_analyze(self):
    # ... ç”Ÿæˆ signals ...
    
    # æ‰¹é‡æå–ç‰¹å¾µ
    features_batch = [
        extract_features_for_prediction(signal) 
        for signal in signals
    ]
    
    # å–®æ¬¡æ‰¹é‡é æ¸¬
    predictions = self.ml_predictor.predict_batch(features_batch)
    
    # é™„åŠ é æ¸¬çµæœ
    for signal, pred in zip(signals, predictions):
        signal.ml_score = float(pred)
âš ï¸ é—œéµæ³¨æ„äº‹é …
1. ONNX è½‰æ›ç›¸å®¹æ€§
* XGBoost â‰¥ 1.7 æ‰æ”¯æ´å®Œæ•´ ONNX è½‰æ›
* ç¢ºä¿ä½ çš„æ¨¡å‹æ²’æœ‰è‡ªè¨‚ç›®æ¨™å‡½æ•¸ï¼ˆä½ ç”¨ reg:squarederrorï¼Œå®Œå…¨ç›¸å®¹ï¼‰

2. æ•¸å€¼ç²¾åº¦å·®ç•°
* ONNX ä½¿ç”¨ float32ï¼ŒXGBoost é è¨­ float64
* å·®ç•° < 1e-6ï¼Œå°äº¤æ˜“æ±ºç­–ç„¡å½±éŸ¿
* è‹¥éœ€æ›´é«˜ç²¾åº¦ï¼Œå¯æ”¹ç”¨ DoubleTensorTypeï¼ˆä½†é€Ÿåº¦ â†“20%ï¼‰

3. æ¨¡å‹ç‰ˆæœ¬ç®¡ç†
* å»ºè­°åŒæ™‚ä¿å­˜ .pkl å’Œ .onnx
* ONNX ä½œç‚ºæ¨ç†å„ªåŒ–å±¤ï¼Œä¸å–ä»£åŸå§‹æ¨¡å‹

å‹•æ…‹å›é€€æ©Ÿåˆ¶
MLPredictor å·²å…§å»ºå›é€€æ©Ÿåˆ¶ï¼š
* ONNX è¼‰å…¥å¤±æ•— â†’ è‡ªå‹•ç”¨ XGBoost
* ç¢ºä¿æ°¸ä¸ä¸­æ–·äº¤æ˜“

æœ€çµ‚ç¢ºèªæ¸…å–®
* å·²å®‰è£ onnxruntime å’Œ onnxmltools
* åŸ·è¡Œé convert_xgboost_to_onnx.py
* MLPredictor æ”¯æ´ ONNX + å›é€€
* ç‰¹å¾µæå–ä½¿ç”¨ float32
* ä¸»å¾ªç’°ä½¿ç”¨ predict_batch