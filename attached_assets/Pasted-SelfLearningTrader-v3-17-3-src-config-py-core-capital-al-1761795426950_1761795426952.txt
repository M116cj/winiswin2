SelfLearningTrader v3.17.3 — 動態預算池 + 質量加權分配
📁 檔案結構

src/
├── config.py
├── core/
│   └── capital_allocator.py
└── strategies/
    └── self_learning_trader.py

🔧 1. 配置參數（src/config.py）

from dataclasses import dataclass
import os

@dataclass(frozen=True)
class Config:
    # ... 其他參數 ...
    
    # 💰 資金分配配置（統一標準化來源）
    MIN_WIN_PROBABILITY: float = 0.55      # 勝率下限
    MIN_CONFIDENCE: float = 0.50           # 信心值下限
    MIN_RR_RATIO: float = 1.0              # 報酬率下限
    MAX_RR_RATIO: float = 3.0              # 報酬率上限
    
    SIGNAL_QUALITY_THRESHOLD: float = 0.6  # 最低質量門檻
    MAX_TOTAL_BUDGET_RATIO: float = 0.8    # 總預算 = 80% 可用保證金
    MAX_SINGLE_POSITION_RATIO: float = 0.5 # 單倉 ≤ 50% 帳戶權益

💰 2. 資金分配器（src/core/capital_allocator.py）

import logging
from typing import List, Tuple
from dataclasses import dataclass

from src.config import Config
from src.core.models.trade_signal import TradeSignal

logger = logging.getLogger(__name__)

@dataclass
class AllocatedSignal:
    signal: TradeSignal
    allocated_budget: float
    allocation_ratio: float

def calculate_signal_score(signal: TradeSignal, config: Config) -> float:
    """
    質量分數 = 勝率^0.4 × 信心值^0.4 × 報酬率^0.2
    所有參數均來自 Config，確保一致性
    """
    win_rate = max(config.MIN_WIN_PROBABILITY, signal.win_probability)
    confidence = max(config.MIN_CONFIDENCE, signal.confidence)
    rr_ratio = max(
        config.MIN_RR_RATIO,
        min(config.MAX_RR_RATIO, signal.risk_reward_ratio)
    )
    return (win_rate ** 0.4) * (confidence ** 0.4) * (rr_ratio ** 0.2)

class CapitalAllocator:
    def __init__(self, config: Config, total_account_equity: float):
        self.config = config
        self.total_account_equity = total_account_equity  # 用於單倉上限檢查
    
    def allocate_capital(self, signals: List[TradeSignal], available_margin: float) -> List[AllocatedSignal]:
        """
        動態預算池分配（修正版）：
        1. 計算質量分數 + 過濾低質量
        2. 按分數降序排序
        3. 動態扣減預算（高分優先，低分拒絕）
        4. 強制執行單倉上限
        """
        if not signals:
            return []
        
        # 1. 計算質量分數並過濾
        scored_signals: List[Tuple[TradeSignal, float]] = []
        for signal in signals:
            score = calculate_signal_score(signal, self.config)
            if score >= self.config.SIGNAL_QUALITY_THRESHOLD:
                scored_signals.append((signal, score))
        
        if not scored_signals:
            return []
        
        # 2. 按分數降序排序（競價排名）
        scored_signals.sort(key=lambda x: x[1], reverse=True)
        
        # 3. 初始化預算
        total_budget = available_margin * self.config.MAX_TOTAL_BUDGET_RATIO
        remaining_budget = total_budget
        max_single_budget = self.total_account_equity * self.config.MAX_SINGLE_POSITION_RATIO
        allocated_signals = []
        
        # 4. 動態分配（修正版：預算池扣減）
        total_score = sum(score for _, score in scored_signals)
        for signal, score in scored_signals:
            if remaining_budget <= 0:
                break
            
            # 計算理論分配
            allocation_ratio = score / total_score
            theoretical_budget = total_budget * allocation_ratio
            
            # 應用單倉上限
            actual_budget = min(theoretical_budget, max_single_budget, remaining_budget)
            
            if actual_budget > 0:
                allocated_signals.append(AllocatedSignal(
                    signal=signal,
                    allocated_budget=actual_budget,
                    allocation_ratio=allocation_ratio
                ))
                remaining_budget -= actual_budget
            else:
                logger.debug(f"💰 預算不足或單倉超限，拒絕信號 {signal.symbol}")
        
        logger.info(
            f"✅ 資金分配完成：{len(allocated_signals)}/{len(scored_signals)} 信號獲批，"
            f"總分配 ${sum(a.allocated_budget for a in allocated_signals):.2f}/"
            f"${total_budget:.2f}"
        )
        return allocated_signals

🤖 3. 整合到 SelfLearningTrader（src/strategies/self_learning_trader.py）
# src/strategies/self_learning_trader.py
import asyncio
from typing import List

from src.config import CONFIG
from src.core.capital_allocator import CapitalAllocator, AllocatedSignal
from src.core.models.position import Position
from src.core.models.trade_signal import TradeSignal

class SelfLearningTrader:
    def __init__(self, config, binance_client):
        self.config = config
        self.binance_client = binance_client
    
    async def execute_best_trades(self, signals: List[TradeSignal]) -> List[Position]:
        """執行多信號資金分配（修正版）"""
        # 1. 獲取帳戶狀態
        account_info = await self.binance_client.get_account()
        available_margin = float(account_info['availableBalance'])
        total_equity = float(account_info['totalWalletBalance'])
        
        # 2. 動態分配資金
        allocator = CapitalAllocator(self.config, total_equity)
        allocated_signals = allocator.allocate_capital(signals, available_margin)
        
        # 3. 執行已分配信號
        positions = []
        for alloc in allocated_signals:
            position_size = self._calculate_position_size_from_budget(
                alloc.allocated_budget,
                alloc.signal.entry,
                alloc.signal.sl,
                alloc.signal.leverage
            )
            position = await self._place_order(alloc.signal, position_size)
            if position:
                positions.append(position)
        
        return positions
    
    def _calculate_position_size_from_budget(self, budget: float, entry: float, sl: float, leverage: float) -> float:
        """基於分配的保證金計算倉位大小"""
        # 名義價值 = 保證金 × 槓桿
        notional_value = budget * leverage
        return notional_value / entry
    
    async def _place_order(self, signal: TradeSignal, size: float) -> Position:
        # ... [下單邏輯] ...
        pass

運作流程總結
競價邏輯
1. 所有信號計算 質量分數 = 勝率⁰·⁴ × 信心值⁰·⁴ × 報酬率⁰·²
2. 按分數 降序排列 → 排名第 1 = 質量最高

保證金分配邏輯
1. 總預算 = 可用保證金 × 80%
2. 單倉上限 = 帳戶總權益 × 50%
3. 分配順序：高分 → 低分
4. 分配方式：
    * 理論分配 = 總預算 × (分數 / 總分數)
    * 實際分配 = min(理論分配, 單倉上限, 剩餘預算)
5. 
6. 預算耗盡 → 拒絕剩餘信號
