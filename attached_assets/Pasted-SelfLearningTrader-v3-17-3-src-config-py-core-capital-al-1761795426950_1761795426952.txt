SelfLearningTrader v3.17.3 â€” å‹•æ…‹é ç®—æ±  + è³ªé‡åŠ æ¬Šåˆ†é…
ğŸ“ æª”æ¡ˆçµæ§‹

src/
â”œâ”€â”€ config.py
â”œâ”€â”€ core/
â”‚   â””â”€â”€ capital_allocator.py
â””â”€â”€ strategies/
    â””â”€â”€ self_learning_trader.py

ğŸ”§ 1. é…ç½®åƒæ•¸ï¼ˆsrc/config.pyï¼‰

from dataclasses import dataclass
import os

@dataclass(frozen=True)
class Config:
    # ... å…¶ä»–åƒæ•¸ ...
    
    # ğŸ’° è³‡é‡‘åˆ†é…é…ç½®ï¼ˆçµ±ä¸€æ¨™æº–åŒ–ä¾†æºï¼‰
    MIN_WIN_PROBABILITY: float = 0.55      # å‹ç‡ä¸‹é™
    MIN_CONFIDENCE: float = 0.50           # ä¿¡å¿ƒå€¼ä¸‹é™
    MIN_RR_RATIO: float = 1.0              # å ±é…¬ç‡ä¸‹é™
    MAX_RR_RATIO: float = 3.0              # å ±é…¬ç‡ä¸Šé™
    
    SIGNAL_QUALITY_THRESHOLD: float = 0.6  # æœ€ä½è³ªé‡é–€æª»
    MAX_TOTAL_BUDGET_RATIO: float = 0.8    # ç¸½é ç®— = 80% å¯ç”¨ä¿è­‰é‡‘
    MAX_SINGLE_POSITION_RATIO: float = 0.5 # å–®å€‰ â‰¤ 50% å¸³æˆ¶æ¬Šç›Š

ğŸ’° 2. è³‡é‡‘åˆ†é…å™¨ï¼ˆsrc/core/capital_allocator.pyï¼‰

import logging
from typing import List, Tuple
from dataclasses import dataclass

from src.config import Config
from src.core.models.trade_signal import TradeSignal

logger = logging.getLogger(__name__)

@dataclass
class AllocatedSignal:
    signal: TradeSignal
    allocated_budget: float
    allocation_ratio: float

def calculate_signal_score(signal: TradeSignal, config: Config) -> float:
    """
    è³ªé‡åˆ†æ•¸ = å‹ç‡^0.4 Ã— ä¿¡å¿ƒå€¼^0.4 Ã— å ±é…¬ç‡^0.2
    æ‰€æœ‰åƒæ•¸å‡ä¾†è‡ª Configï¼Œç¢ºä¿ä¸€è‡´æ€§
    """
    win_rate = max(config.MIN_WIN_PROBABILITY, signal.win_probability)
    confidence = max(config.MIN_CONFIDENCE, signal.confidence)
    rr_ratio = max(
        config.MIN_RR_RATIO,
        min(config.MAX_RR_RATIO, signal.risk_reward_ratio)
    )
    return (win_rate ** 0.4) * (confidence ** 0.4) * (rr_ratio ** 0.2)

class CapitalAllocator:
    def __init__(self, config: Config, total_account_equity: float):
        self.config = config
        self.total_account_equity = total_account_equity  # ç”¨æ–¼å–®å€‰ä¸Šé™æª¢æŸ¥
    
    def allocate_capital(self, signals: List[TradeSignal], available_margin: float) -> List[AllocatedSignal]:
        """
        å‹•æ…‹é ç®—æ± åˆ†é…ï¼ˆä¿®æ­£ç‰ˆï¼‰ï¼š
        1. è¨ˆç®—è³ªé‡åˆ†æ•¸ + éæ¿¾ä½è³ªé‡
        2. æŒ‰åˆ†æ•¸é™åºæ’åº
        3. å‹•æ…‹æ‰£æ¸›é ç®—ï¼ˆé«˜åˆ†å„ªå…ˆï¼Œä½åˆ†æ‹’çµ•ï¼‰
        4. å¼·åˆ¶åŸ·è¡Œå–®å€‰ä¸Šé™
        """
        if not signals:
            return []
        
        # 1. è¨ˆç®—è³ªé‡åˆ†æ•¸ä¸¦éæ¿¾
        scored_signals: List[Tuple[TradeSignal, float]] = []
        for signal in signals:
            score = calculate_signal_score(signal, self.config)
            if score >= self.config.SIGNAL_QUALITY_THRESHOLD:
                scored_signals.append((signal, score))
        
        if not scored_signals:
            return []
        
        # 2. æŒ‰åˆ†æ•¸é™åºæ’åºï¼ˆç«¶åƒ¹æ’åï¼‰
        scored_signals.sort(key=lambda x: x[1], reverse=True)
        
        # 3. åˆå§‹åŒ–é ç®—
        total_budget = available_margin * self.config.MAX_TOTAL_BUDGET_RATIO
        remaining_budget = total_budget
        max_single_budget = self.total_account_equity * self.config.MAX_SINGLE_POSITION_RATIO
        allocated_signals = []
        
        # 4. å‹•æ…‹åˆ†é…ï¼ˆä¿®æ­£ç‰ˆï¼šé ç®—æ± æ‰£æ¸›ï¼‰
        total_score = sum(score for _, score in scored_signals)
        for signal, score in scored_signals:
            if remaining_budget <= 0:
                break
            
            # è¨ˆç®—ç†è«–åˆ†é…
            allocation_ratio = score / total_score
            theoretical_budget = total_budget * allocation_ratio
            
            # æ‡‰ç”¨å–®å€‰ä¸Šé™
            actual_budget = min(theoretical_budget, max_single_budget, remaining_budget)
            
            if actual_budget > 0:
                allocated_signals.append(AllocatedSignal(
                    signal=signal,
                    allocated_budget=actual_budget,
                    allocation_ratio=allocation_ratio
                ))
                remaining_budget -= actual_budget
            else:
                logger.debug(f"ğŸ’° é ç®—ä¸è¶³æˆ–å–®å€‰è¶…é™ï¼Œæ‹’çµ•ä¿¡è™Ÿ {signal.symbol}")
        
        logger.info(
            f"âœ… è³‡é‡‘åˆ†é…å®Œæˆï¼š{len(allocated_signals)}/{len(scored_signals)} ä¿¡è™Ÿç²æ‰¹ï¼Œ"
            f"ç¸½åˆ†é… ${sum(a.allocated_budget for a in allocated_signals):.2f}/"
            f"${total_budget:.2f}"
        )
        return allocated_signals

ğŸ¤– 3. æ•´åˆåˆ° SelfLearningTraderï¼ˆsrc/strategies/self_learning_trader.pyï¼‰
# src/strategies/self_learning_trader.py
import asyncio
from typing import List

from src.config import CONFIG
from src.core.capital_allocator import CapitalAllocator, AllocatedSignal
from src.core.models.position import Position
from src.core.models.trade_signal import TradeSignal

class SelfLearningTrader:
    def __init__(self, config, binance_client):
        self.config = config
        self.binance_client = binance_client
    
    async def execute_best_trades(self, signals: List[TradeSignal]) -> List[Position]:
        """åŸ·è¡Œå¤šä¿¡è™Ÿè³‡é‡‘åˆ†é…ï¼ˆä¿®æ­£ç‰ˆï¼‰"""
        # 1. ç²å–å¸³æˆ¶ç‹€æ…‹
        account_info = await self.binance_client.get_account()
        available_margin = float(account_info['availableBalance'])
        total_equity = float(account_info['totalWalletBalance'])
        
        # 2. å‹•æ…‹åˆ†é…è³‡é‡‘
        allocator = CapitalAllocator(self.config, total_equity)
        allocated_signals = allocator.allocate_capital(signals, available_margin)
        
        # 3. åŸ·è¡Œå·²åˆ†é…ä¿¡è™Ÿ
        positions = []
        for alloc in allocated_signals:
            position_size = self._calculate_position_size_from_budget(
                alloc.allocated_budget,
                alloc.signal.entry,
                alloc.signal.sl,
                alloc.signal.leverage
            )
            position = await self._place_order(alloc.signal, position_size)
            if position:
                positions.append(position)
        
        return positions
    
    def _calculate_position_size_from_budget(self, budget: float, entry: float, sl: float, leverage: float) -> float:
        """åŸºæ–¼åˆ†é…çš„ä¿è­‰é‡‘è¨ˆç®—å€‰ä½å¤§å°"""
        # åç¾©åƒ¹å€¼ = ä¿è­‰é‡‘ Ã— æ§“æ¡¿
        notional_value = budget * leverage
        return notional_value / entry
    
    async def _place_order(self, signal: TradeSignal, size: float) -> Position:
        # ... [ä¸‹å–®é‚è¼¯] ...
        pass

é‹ä½œæµç¨‹ç¸½çµ
ç«¶åƒ¹é‚è¼¯
1. æ‰€æœ‰ä¿¡è™Ÿè¨ˆç®— è³ªé‡åˆ†æ•¸ = å‹ç‡â°Â·â´ Ã— ä¿¡å¿ƒå€¼â°Â·â´ Ã— å ±é…¬ç‡â°Â·Â²
2. æŒ‰åˆ†æ•¸ é™åºæ’åˆ— â†’ æ’åç¬¬ 1 = è³ªé‡æœ€é«˜

ä¿è­‰é‡‘åˆ†é…é‚è¼¯
1. ç¸½é ç®— = å¯ç”¨ä¿è­‰é‡‘ Ã— 80%
2. å–®å€‰ä¸Šé™ = å¸³æˆ¶ç¸½æ¬Šç›Š Ã— 50%
3. åˆ†é…é †åºï¼šé«˜åˆ† â†’ ä½åˆ†
4. åˆ†é…æ–¹å¼ï¼š
    * ç†è«–åˆ†é… = ç¸½é ç®— Ã— (åˆ†æ•¸ / ç¸½åˆ†æ•¸)
    * å¯¦éš›åˆ†é… = min(ç†è«–åˆ†é…, å–®å€‰ä¸Šé™, å‰©é¤˜é ç®—)
5. 
6. é ç®—è€—ç›¡ â†’ æ‹’çµ•å‰©é¤˜ä¿¡è™Ÿ
