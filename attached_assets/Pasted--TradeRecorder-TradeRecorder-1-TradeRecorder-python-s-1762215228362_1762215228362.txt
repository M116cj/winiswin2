å¥½çš„ï¼æˆ‘æä¾›ä¸€å€‹æœ€å®Œæ•´çš„ TradeRecorder å¢å¼·å’Œä¿®å¾©æ–¹æ¡ˆï¼š

ğŸ”§ å®Œæ•´ TradeRecorder å¢å¼·æ–¹æ¡ˆ

1. æ ¸å¿ƒ TradeRecorder é¡åˆ¥

```python
# src/core/trade_recorder.py

import sqlite3
import logging
import asyncio
import aiosqlite
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from enum import Enum
import json
import hashlib

logger = logging.getLogger(__name__)

class TradeStatus(Enum):
    OPEN = "OPEN"
    CLOSED = "CLOSED" 
    CANCELLED = "CANCELLED"
    LIQUIDATED = "LIQUIDATED"

class PerformanceMetric(Enum):
    WIN_RATE = "win_rate"
    AVG_PNL = "avg_pnl"
    SHARPE_RATIO = "sharpe_ratio"
    MAX_DRAWDOWN = "max_drawdown"

class EnhancedTradeRecorder:
    """å¢å¼·ç‰ˆäº¤æ˜“è¨˜éŒ„å™¨ - å®Œæ•´ä¿®å¾©å’ŒåŠŸèƒ½å¢å¼·"""
    
    def __init__(self, config):
        self.config = config
        self.db_path = 'trading_data.db'
        self._initialized = False
        self._cache = {}
        self._performance_cache = {}
        
        # æ€§èƒ½å„ªåŒ–é…ç½®
        self.optimization_config = {
            'cache_ttl': 300,  # 5åˆ†é˜ç·©å­˜
            'batch_size': 10,  # æ‰¹é‡æ“ä½œå¤§å°
            'auto_vacuum': True,  # è‡ªå‹•æ¸…ç†æ•¸æ“šåº«
            'wal_mode': True,     # å¯«å…¥å‰æ—¥èªŒæ¨¡å¼
        }
        
        # åˆå§‹åŒ–æ•¸æ“šåº«
        asyncio.create_task(self._async_init())

    async def _async_init(self):
        """ç•°æ­¥åˆå§‹åŒ–"""
        try:
            await self._init_database()
            await self._create_indexes()
            await self._migrate_database()
            self._initialized = True
            logger.info("âœ… EnhancedTradeRecorder åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            logger.error(f"âŒ EnhancedTradeRecorder åˆå§‹åŒ–å¤±æ•—: {e}")

    async def _init_database(self):
        """åˆå§‹åŒ–æ•¸æ“šåº«è¡¨çµæ§‹"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # å•Ÿç”¨ WAL æ¨¡å¼æå‡æ€§èƒ½
                if self.optimization_config['wal_mode']:
                    await db.execute("PRAGMA journal_mode=WAL")
                
                # äº¤æ˜“æ­·å²è¡¨
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS trade_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        trade_uid TEXT UNIQUE NOT NULL,
                        symbol TEXT NOT NULL,
                        direction TEXT NOT NULL,
                        entry_price REAL NOT NULL,
                        exit_price REAL,
                        position_size REAL NOT NULL,
                        pnl REAL,
                        pnl_percentage REAL,
                        commission REAL DEFAULT 0,
                        funding_rate REAL DEFAULT 0,
                        entry_time TIMESTAMP NOT NULL,
                        exit_time TIMESTAMP,
                        hold_duration INTEGER, -- æŒå€‰æ™‚é–“(ç§’)
                        confidence REAL,
                        win_probability REAL,
                        risk_reward_ratio REAL,
                        status TEXT DEFAULT 'OPEN',
                        exit_reason TEXT,
                        strategy_version TEXT,
                        market_conditions TEXT,
                        tags TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')

                # å¯¦æ™‚æŒå€‰è¡¨
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS current_positions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        trade_uid TEXT UNIQUE NOT NULL,
                        symbol TEXT UNIQUE NOT NULL,
                        direction TEXT NOT NULL,
                        entry_price REAL NOT NULL,
                        current_price REAL,
                        position_size REAL NOT NULL,
                        unrealized_pnl REAL,
                        unrealized_pnl_percentage REAL,
                        margin_used REAL NOT NULL,
                        leverage INTEGER DEFAULT 1,
                        entry_time TIMESTAMP NOT NULL,
                        confidence REAL,
                        win_probability REAL,
                        stop_loss_price REAL,
                        take_profit_price REAL,
                        risk_reward_ratio REAL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')

                # æ€§èƒ½çµ±è¨ˆè¡¨
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS performance_stats (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        period_type TEXT NOT NULL, -- 'hourly', 'daily', 'weekly'
                        period_start TIMESTAMP NOT NULL,
                        period_end TIMESTAMP NOT NULL,
                        total_trades INTEGER DEFAULT 0,
                        winning_trades INTEGER DEFAULT 0,
                        losing_trades INTEGER DEFAULT 0,
                        total_pnl REAL DEFAULT 0,
                        total_volume REAL DEFAULT 0,
                        win_rate REAL DEFAULT 0,
                        avg_pnl REAL DEFAULT 0,
                        avg_winning_pnl REAL DEFAULT 0,
                        avg_losing_pnl REAL DEFAULT 0,
                        profit_factor REAL DEFAULT 0,
                        max_drawdown REAL DEFAULT 0,
                        sharpe_ratio REAL DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(period_type, period_start)
                    )
                ''')

                # äº¤æ˜“å°çµ±è¨ˆè¡¨
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS symbol_performance (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        symbol TEXT NOT NULL,
                        total_trades INTEGER DEFAULT 0,
                        winning_trades INTEGER DEFAULT 0,
                        total_pnl REAL DEFAULT 0,
                        win_rate REAL DEFAULT 0,
                        avg_pnl REAL DEFAULT 0,
                        best_trade_pnl REAL DEFAULT 0,
                        worst_trade_pnl REAL DEFAULT 0,
                        avg_hold_duration INTEGER DEFAULT 0,
                        last_traded TIMESTAMP,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        UNIQUE(symbol)
                    )
                ''')

                # é¢¨éšªç®¡ç†è¡¨
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS risk_metrics (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        total_portfolio_value REAL DEFAULT 0,
                        used_margin REAL DEFAULT 0,
                        available_margin REAL DEFAULT 0,
                        margin_ratio REAL DEFAULT 0,
                        daily_pnl REAL DEFAULT 0,
                        weekly_pnl REAL DEFAULT 0,
                        monthly_pnl REAL DEFAULT 0,
                        max_drawdown REAL DEFAULT 0,
                        volatility REAL DEFAULT 0,
                        var_95 REAL DEFAULT 0, -- 95% VaR
                        expected_shortfall REAL DEFAULT 0
                    )
                ''')

                await db.commit()
                logger.info("âœ… æ•¸æ“šåº«è¡¨çµæ§‹åˆå§‹åŒ–å®Œæˆ")
                
        except Exception as e:
            logger.error(f"âŒ æ•¸æ“šåº«åˆå§‹åŒ–å¤±æ•—: {e}")
            raise

    async def _create_indexes(self):
        """å‰µå»ºæ€§èƒ½ç´¢å¼•"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                indexes = [
                    "CREATE INDEX IF NOT EXISTS idx_trade_history_symbol ON trade_history(symbol)",
                    "CREATE INDEX IF NOT EXISTS idx_trade_history_entry_time ON trade_history(entry_time)",
                    "CREATE INDEX IF NOT EXISTS idx_trade_history_status ON trade_history(status)",
                    "CREATE INDEX IF NOT EXISTS idx_trade_history_pnl ON trade_history(pnl)",
                    "CREATE INDEX IF NOT EXISTS idx_performance_stats_period ON performance_stats(period_type, period_start)",
                    "CREATE INDEX IF NOT EXISTS idx_symbol_performance_symbol ON symbol_performance(symbol)",
                ]
                
                for index_sql in indexes:
                    await db.execute(index_sql)
                
                await db.commit()
                logger.info("âœ… æ•¸æ“šåº«ç´¢å¼•å‰µå»ºå®Œæˆ")
                
        except Exception as e:
            logger.error(f"âŒ ç´¢å¼•å‰µå»ºå¤±æ•—: {e}")

    async def _migrate_database(self):
        """æ•¸æ“šåº«é·ç§»ï¼ˆç”¨æ–¼ç‰ˆæœ¬å‡ç´šï¼‰"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # æª¢æŸ¥æ˜¯å¦éœ€è¦é·ç§»
                await db.execute('''
                    CREATE TABLE IF NOT EXISTS db_version (
                        version INTEGER PRIMARY KEY,
                        migrated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # ç²å–ç•¶å‰ç‰ˆæœ¬
                cursor = await db.execute("SELECT MAX(version) FROM db_version")
                result = await cursor.fetchone()
                current_version = result[0] if result else 0
                
                # åŸ·è¡Œé·ç§»
                migrations = [
                    # æœªä¾†å¯ä»¥æ·»åŠ é·ç§»è…³æœ¬
                ]
                
                for target_version, migration_sql in migrations:
                    if current_version < target_version:
                        await db.executescript(migration_sql)
                        await db.execute("INSERT INTO db_version (version) VALUES (?)", (target_version,))
                        logger.info(f"âœ… æ•¸æ“šåº«é·ç§»åˆ°ç‰ˆæœ¬ {target_version}")
                
                await db.commit()
                
        except Exception as e:
            logger.error(f"âŒ æ•¸æ“šåº«é·ç§»å¤±æ•—: {e}")

    async def get_trade_count(self, timeframe: str = '24h', symbol: str = None) -> int:
        """ç²å–äº¤æ˜“æ•¸é‡ - å®Œæ•´ä¿®å¾©ç‰ˆæœ¬"""
        cache_key = f"trade_count_{timeframe}_{symbol}"
        
        # æª¢æŸ¥ç·©å­˜
        if cache_key in self._cache and self._is_cache_valid(cache_key):
            return self._cache[cache_key]
        
        try:
            if not self._initialized:
                logger.warning("âš ï¸ TradeRecorder æœªåˆå§‹åŒ–ï¼Œè¿”å›0")
                return 0
                
            async with aiosqlite.connect(self.db_path) as db:
                query = "SELECT COUNT(*) FROM trade_history WHERE 1=1"
                params = []
                
                # æ™‚é–“ç¯„åœéæ¿¾
                if timeframe == '24h':
                    twenty_four_hours_ago = datetime.now() - timedelta(hours=24)
                    query += " AND entry_time >= ?"
                    params.append(twenty_four_hours_ago)
                elif timeframe == '7d':
                    seven_days_ago = datetime.now() - timedelta(days=7)
                    query += " AND entry_time >= ?"
                    params.append(seven_days_ago)
                elif timeframe == '30d':
                    thirty_days_ago = datetime.now() - timedelta(days=30)
                    query += " AND entry_time >= ?"
                    params.append(thirty_days_ago)
                
                # äº¤æ˜“å°éæ¿¾
                if symbol:
                    query += " AND symbol = ?"
                    params.append(symbol)
                
                cursor = await db.execute(query, params)
                result = await cursor.fetchone()
                count = result[0] if result else 0
                
                # æ›´æ–°ç·©å­˜
                self._cache[cache_key] = count
                
                logger.debug(f"ğŸ“Š TradeRecorder.get_trade_count: {timeframe} {symbol} = {count}")
                return count
                
        except Exception as e:
            logger.error(f"âŒ TradeRecorder.get_trade_count å¤±æ•—: {e}")
            return 0

    async def record_trade(self, trade_data: Dict) -> bool:
        """è¨˜éŒ„äº¤æ˜“ - å¢å¼·ç‰ˆæœ¬"""
        try:
            if not self._initialized:
                logger.error("âŒ TradeRecorder æœªåˆå§‹åŒ–ï¼Œç„¡æ³•è¨˜éŒ„äº¤æ˜“")
                return False
            
            # ç”Ÿæˆå”¯ä¸€äº¤æ˜“ID
            trade_uid = self._generate_trade_uid(trade_data)
            
            async with aiosqlite.connect(self.db_path) as db:
                # æ’å…¥äº¤æ˜“æ­·å²
                await db.execute('''
                    INSERT OR REPLACE INTO trade_history 
                    (trade_uid, symbol, direction, entry_price, position_size, 
                     confidence, win_probability, risk_reward_ratio, status,
                     entry_time, strategy_version, market_conditions)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    trade_uid,
                    trade_data.get('symbol'),
                    trade_data.get('direction'), 
                    trade_data.get('entry_price', 0),
                    trade_data.get('position_size', 0),
                    trade_data.get('confidence', 0),
                    trade_data.get('win_probability', 0),
                    trade_data.get('risk_reward_ratio', 1.5),
                    TradeStatus.OPEN.value,
                    trade_data.get('entry_time', datetime.now()),
                    trade_data.get('strategy_version', 'v3.19.1'),
                    json.dumps(trade_data.get('market_conditions', {}))
                ))
                
                # æ›´æ–°å¯¦æ™‚æŒå€‰
                await db.execute('''
                    INSERT OR REPLACE INTO current_positions 
                    (trade_uid, symbol, direction, entry_price, position_size,
                     margin_used, entry_time, confidence, win_probability,
                     risk_reward_ratio, stop_loss_price, take_profit_price)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    trade_uid,
                    trade_data.get('symbol'),
                    trade_data.get('direction'),
                    trade_data.get('entry_price', 0),
                    trade_data.get('position_size', 0),
                    trade_data.get('position_size', 0),  # ä¿è­‰é‡‘ä½¿ç”¨
                    trade_data.get('entry_time', datetime.now()),
                    trade_data.get('confidence', 0),
                    trade_data.get('win_probability', 0),
                    trade_data.get('risk_reward_ratio', 1.5),
                    trade_data.get('stop_loss_price'),
                    trade_data.get('take_profit_price')
                ))
                
                await db.commit()
                
                # æ¸…é™¤ç›¸é—œç·©å­˜
                self._clear_related_cache(trade_data.get('symbol'))
                
                logger.info(f"âœ… äº¤æ˜“è¨˜éŒ„æˆåŠŸ: {trade_data.get('symbol')} (UID: {trade_uid})")
                return True
                
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“è¨˜éŒ„å¤±æ•—: {e}")
            return False

    async def close_trade(self, trade_uid: str, exit_data: Dict) -> bool:
        """é—œé–‰äº¤æ˜“"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # è¨ˆç®—æŒå€‰æ™‚é–“å’Œç›ˆè™§
                entry_time = await self._get_trade_entry_time(db, trade_uid)
                exit_time = exit_data.get('exit_time', datetime.now())
                hold_duration = (exit_time - entry_time).total_seconds() if entry_time else 0
                
                entry_price = await self._get_trade_entry_price(db, trade_uid)
                exit_price = exit_data.get('exit_price', 0)
                position_size = await self._get_position_size(db, trade_uid)
                direction = await self._get_trade_direction(db, trade_uid)
                
                # è¨ˆç®—ç›ˆè™§
                pnl, pnl_percentage = self._calculate_pnl(
                    entry_price, exit_price, position_size, direction
                )
                
                # æ›´æ–°äº¤æ˜“æ­·å²
                await db.execute('''
                    UPDATE trade_history 
                    SET exit_price = ?, pnl = ?, pnl_percentage = ?,
                        exit_time = ?, hold_duration = ?, status = ?,
                        exit_reason = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE trade_uid = ?
                ''', (
                    exit_price, pnl, pnl_percentage,
                    exit_time, hold_duration, TradeStatus.CLOSED.value,
                    exit_data.get('exit_reason', 'manual'), trade_uid
                ))
                
                # å¾å¯¦æ™‚æŒå€‰ç§»é™¤
                await db.execute('''
                    DELETE FROM current_positions WHERE trade_uid = ?
                ''', (trade_uid,))
                
                await db.commit()
                
                # æ›´æ–°æ€§èƒ½çµ±è¨ˆ
                asyncio.create_task(self._update_performance_metrics())
                asyncio.create_task(self._update_symbol_performance())
                
                logger.info(f"âœ… äº¤æ˜“é—œé–‰æˆåŠŸ: {trade_uid} PnL: ${pnl:.2f} ({pnl_percentage:.2f}%)")
                return True
                
        except Exception as e:
            logger.error(f"âŒ é—œé–‰äº¤æ˜“å¤±æ•— {trade_uid}: {e}")
            return False

    async def get_recent_performance(self, hours: int = 24) -> Dict:
        """ç²å–è¿‘æœŸäº¤æ˜“è¡¨ç¾ - å¢å¼·ç‰ˆæœ¬"""
        cache_key = f"performance_{hours}h"
        
        if cache_key in self._performance_cache and self._is_cache_valid(cache_key):
            return self._performance_cache[cache_key]
        
        try:
            since_time = datetime.now() - timedelta(hours=hours)
            
            async with aiosqlite.connect(self.db_path) as db:
                # åŸºç¤çµ±è¨ˆ
                cursor = await db.execute('''
                    SELECT 
                        COUNT(*) as total_trades,
                        SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
                        SUM(CASE WHEN pnl < 0 THEN 1 ELSE 0 END) as losing_trades,
                        AVG(pnl) as avg_pnl,
                        SUM(pnl) as total_pnl,
                        AVG(CASE WHEN pnl > 0 THEN pnl END) as avg_winning_pnl,
                        AVG(CASE WHEN pnl < 0 THEN pnl END) as avg_losing_pnl,
                        AVG(hold_duration) as avg_hold_duration
                    FROM trade_history 
                    WHERE entry_time >= ? AND status = 'CLOSED'
                ''', (since_time,))
                
                result = await cursor.fetchone()
                
                if result and result[0] > 0:
                    (total_trades, winning_trades, losing_trades, avg_pnl, 
                     total_pnl, avg_winning_pnl, avg_losing_pnl, avg_hold_duration) = result
                    
                    win_rate = (winning_trades / total_trades) * 100
                    profit_factor = abs(avg_winning_pnl / avg_losing_pnl) if avg_losing_pnl else float('inf')
                    
                    # è¨ˆç®—æœ€å¤§å›æ’¤
                    max_drawdown = await self._calculate_max_drawdown(db, since_time)
                    
                    performance = {
                        'total_trades': total_trades,
                        'winning_trades': winning_trades,
                        'losing_trades': losing_trades,
                        'win_rate': round(win_rate, 2),
                        'avg_pnl': round(avg_pnl, 2),
                        'total_pnl': round(total_pnl, 2),
                        'avg_winning_pnl': round(avg_winning_pnl, 2),
                        'avg_losing_pnl': round(avg_losing_pnl, 2),
                        'profit_factor': round(profit_factor, 2),
                        'max_drawdown': round(max_drawdown, 2),
                        'avg_hold_duration': round(avg_hold_duration, 2) if avg_hold_duration else 0,
                        'period_hours': hours
                    }
                else:
                    performance = self._get_default_performance(hours)
                
                # æ›´æ–°ç·©å­˜
                self._performance_cache[cache_key] = performance
                return performance
                
        except Exception as e:
            logger.error(f"âŒ ç²å–äº¤æ˜“è¡¨ç¾å¤±æ•—: {e}")
            return self._get_default_performance(hours)

    async def get_current_positions(self) -> List[Dict]:
        """ç²å–ç•¶å‰æŒå€‰"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute('''
                    SELECT symbol, direction, entry_price, position_size, 
                           margin_used, entry_time, confidence, win_probability,
                           stop_loss_price, take_profit_price, unrealized_pnl
                    FROM current_positions
                    ORDER BY entry_time DESC
                ''')
                
                rows = await cursor.fetchall()
                positions = []
                
                for row in rows:
                    positions.append({
                        'symbol': row[0],
                        'direction': row[1],
                        'entry_price': row[2],
                        'position_size': row[3],
                        'margin_used': row[4],
                        'entry_time': row[5],
                        'confidence': row[6],
                        'win_probability': row[7],
                        'stop_loss_price': row[8],
                        'take_profit_price': row[9],
                        'unrealized_pnl': row[10]
                    })
                
                return positions
                
        except Exception as e:
            logger.error(f"âŒ ç²å–ç•¶å‰æŒå€‰å¤±æ•—: {e}")
            return []

    async def update_position_prices(self, price_updates: Dict[str, float]):
        """æ›´æ–°æŒå€‰ç•¶å‰åƒ¹æ ¼å’Œæœªå¯¦ç¾ç›ˆè™§"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                for symbol, current_price in price_updates.items():
                    # ç²å–æŒå€‰ä¿¡æ¯
                    cursor = await db.execute('''
                        SELECT direction, entry_price, position_size 
                        FROM current_positions WHERE symbol = ?
                    ''', (symbol,))
                    
                    result = await cursor.fetchone()
                    if not result:
                        continue
                    
                    direction, entry_price, position_size = result
                    
                    # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
                    unrealized_pnl, unrealized_pnl_percentage = self._calculate_unrealized_pnl(
                        entry_price, current_price, position_size, direction
                    )
                    
                    # æ›´æ–°æ•¸æ“šåº«
                    await db.execute('''
                        UPDATE current_positions 
                        SET current_price = ?, unrealized_pnl = ?, 
                            unrealized_pnl_percentage = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE symbol = ?
                    ''', (current_price, unrealized_pnl, unrealized_pnl_percentage, symbol))
                
                await db.commit()
                logger.debug(f"âœ… æ›´æ–° {len(price_updates)} å€‹æŒå€‰åƒ¹æ ¼")
                
        except Exception as e:
            logger.error(f"âŒ æ›´æ–°æŒå€‰åƒ¹æ ¼å¤±æ•—: {e}")

    async def get_symbol_performance(self, symbol: str) -> Dict:
        """ç²å–ç‰¹å®šäº¤æ˜“å°çš„è¡¨ç¾çµ±è¨ˆ"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute('''
                    SELECT total_trades, winning_trades, total_pnl, win_rate,
                           avg_pnl, best_trade_pnl, worst_trade_pnl, avg_hold_duration
                    FROM symbol_performance 
                    WHERE symbol = ?
                ''', (symbol,))
                
                result = await cursor.fetchone()
                if result:
                    return {
                        'symbol': symbol,
                        'total_trades': result[0],
                        'winning_trades': result[1],
                        'total_pnl': result[2],
                        'win_rate': result[3],
                        'avg_pnl': result[4],
                        'best_trade_pnl': result[5],
                        'worst_trade_pnl': result[6],
                        'avg_hold_duration': result[7]
                    }
                else:
                    return self._get_default_symbol_performance(symbol)
                    
        except Exception as e:
            logger.error(f"âŒ ç²å–äº¤æ˜“å°è¡¨ç¾å¤±æ•— {symbol}: {e}")
            return self._get_default_symbol_performance(symbol)

    # è¼”åŠ©æ–¹æ³•
    def _generate_trade_uid(self, trade_data: Dict) -> str:
        """ç”Ÿæˆå”¯ä¸€äº¤æ˜“ID"""
        unique_string = f"{trade_data.get('symbol')}_{trade_data.get('entry_time')}_{datetime.now().timestamp()}"
        return hashlib.md5(unique_string.encode()).hexdigest()[:16]

    def _calculate_pnl(self, entry_price: float, exit_price: float, 
                      position_size: float, direction: str) -> Tuple[float, float]:
        """è¨ˆç®—ç›ˆè™§"""
        if direction == 'LONG':
            pnl = (exit_price - entry_price) * position_size / entry_price
        else:  # SHORT
            pnl = (entry_price - exit_price) * position_size / entry_price
        
        pnl_percentage = (pnl / position_size) * 100
        return round(pnl, 4), round(pnl_percentage, 2)

    def _calculate_unrealized_pnl(self, entry_price: float, current_price: float,
                                position_size: float, direction: str) -> Tuple[float, float]:
        """è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§"""
        if direction == 'LONG':
            pnl = (current_price - entry_price) * position_size / entry_price
        else:  # SHORT
            pnl = (entry_price - current_price) * position_size / entry_price
        
        pnl_percentage = (pnl / position_size) * 100
        return round(pnl, 4), round(pnl_percentage, 2)

    def _is_cache_valid(self, cache_key: str) -> bool:
        """æª¢æŸ¥ç·©å­˜æ˜¯å¦æœ‰æ•ˆ"""
        if cache_key not in self._cache:
            return False
        timestamp, _ = self._cache[cache_key]
        return (datetime.now().timestamp() - timestamp) < self.optimization_config['cache_ttl']

    def _clear_related_cache(self, symbol: str):
        """æ¸…é™¤ç›¸é—œç·©å­˜"""
        keys_to_clear = [k for k in self._cache.keys() if symbol in k or 'performance' in k]
        for key in keys_to_clear:
            self._cache.pop(key, None)

    def _get_default_performance(self, hours: int) -> Dict:
        """è¿”å›é»˜èªæ€§èƒ½æ•¸æ“š"""
        return {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'win_rate': 0,
            'avg_pnl': 0,
            'total_pnl': 0,
            'avg_winning_pnl': 0,
            'avg_losing_pnl': 0,
            'profit_factor': 0,
            'max_drawdown': 0,
            'avg_hold_duration': 0,
            'period_hours': hours
        }

    def _get_default_symbol_performance(self, symbol: str) -> Dict:
        """è¿”å›é»˜èªäº¤æ˜“å°æ€§èƒ½æ•¸æ“š"""
        return {
            'symbol': symbol,
            'total_trades': 0,
            'winning_trades': 0,
            'total_pnl': 0,
            'win_rate': 0,
            'avg_pnl': 0,
            'best_trade_pnl': 0,
            'worst_trade_pnl': 0,
            'avg_hold_duration': 0
        }

    async def _get_trade_entry_time(self, db, trade_uid: str) -> Optional[datetime]:
        """ç²å–äº¤æ˜“å…¥å ´æ™‚é–“"""
        cursor = await db.execute("SELECT entry_time FROM trade_history WHERE trade_uid = ?", (trade_uid,))
        result = await cursor.fetchone()
        return result[0] if result else None

    async def _get_trade_entry_price(self, db, trade_uid: str) -> float:
        """ç²å–äº¤æ˜“å…¥å ´åƒ¹æ ¼"""
        cursor = await db.execute("SELECT entry_price FROM trade_history WHERE trade_uid = ?", (trade_uid,))
        result = await cursor.fetchone()
        return result[0] if result else 0

    async def _get_position_size(self, db, trade_uid: str) -> float:
        """ç²å–é ­å¯¸å¤§å°"""
        cursor = await db.execute("SELECT position_size FROM trade_history WHERE trade_uid = ?", (trade_uid,))
        result = await cursor.fetchone()
        return result[0] if result else 0

    async def _get_trade_direction(self, db, trade_uid: str) -> str:
        """ç²å–äº¤æ˜“æ–¹å‘"""
        cursor = await db.execute("SELECT direction FROM trade_history WHERE trade_uid = ?", (trade_uid,))
        result = await cursor.fetchone()
        return result[0] if result else 'LONG'

    async def _calculate_max_drawdown(self, db, since_time: datetime) -> float:
        """è¨ˆç®—æœ€å¤§å›æ’¤"""
        try:
            cursor = await db.execute('''
                SELECT entry_time, pnl FROM trade_history 
                WHERE entry_time >= ? AND status = 'CLOSED'
                ORDER BY entry_time
            ''', (since_time,))
            
            rows = await cursor.fetchall()
            if not rows:
                return 0.0
                
            # è¨ˆç®—ç´¯ç©ç›ˆè™§å’Œæœ€å¤§å›æ’¤
            cumulative_pnl = 0
            peak = 0
            max_drawdown = 0
            
            for _, pnl in rows:
                cumulative_pnl += pnl
                if cumulative_pnl > peak:
                    peak = cumulative_pnl
                drawdown = peak - cumulative_pnl
                if drawdown > max_drawdown:
                    max_drawdown = drawdown
            
            return max_drawdown
            
        except Exception as e:
            logger.error(f"âŒ è¨ˆç®—æœ€å¤§å›æ’¤å¤±æ•—: {e}")
            return 0.0

    async def _update_performance_metrics(self):
        """æ›´æ–°æ€§èƒ½æŒ‡æ¨™"""
        try:
            # é€™è£¡å¯ä»¥å¯¦ç¾å®šæœŸæ›´æ–°æ€§èƒ½çµ±è¨ˆè¡¨çš„é‚è¼¯
            pass
        except Exception as e:
            logger.error(f"âŒ æ›´æ–°æ€§èƒ½æŒ‡æ¨™å¤±æ•—: {e}")

    async def _update_symbol_performance(self):
        """æ›´æ–°äº¤æ˜“å°æ€§èƒ½"""
        try:
            # é€™è£¡å¯ä»¥å¯¦ç¾å®šæœŸæ›´æ–°äº¤æ˜“å°çµ±è¨ˆçš„é‚è¼¯
            pass
        except Exception as e:
            logger.error(f"âŒ æ›´æ–°äº¤æ˜“å°æ€§èƒ½å¤±æ•—: {e}")

    async def health_check(self) -> Dict:
        """å¥åº·æª¢æŸ¥"""
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # æª¢æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
                tables = ['trade_history', 'current_positions', 'performance_stats']
                health_status = {}
                
                for table in tables:
                    cursor = await db.execute(f"SELECT COUNT(*) FROM {table}")
                    result = await cursor.fetchone()
                    health_status[table] = result[0] if result else 0
                
                health_status['initialized'] = self._initialized
                health_status['database_size'] = await self._get_database_size()
                
                return health_status
                
        except Exception as e:
            logger.error(f"âŒ å¥åº·æª¢æŸ¥å¤±æ•—: {e}")
            return {'error': str(e)}

    async def _get_database_size(self) -> int:
        """ç²å–æ•¸æ“šåº«æ–‡ä»¶å¤§å°"""
        try:
            import os
            return os.path.getsize(self.db_path) if os.path.exists(self.db_path) else 0
        except:
            return 0

    async def cleanup_old_data(self, days_to_keep: int = 30):
        """æ¸…ç†èˆŠæ•¸æ“š"""
        try:
            cutoff_date = datetime.now() - timedelta(days=days_to_keep)
            
            async with aiosqlite.connect(self.db_path) as db:
                # æ¸…ç†èˆŠçš„äº¤æ˜“æ­·å²
                await db.execute('''
                    DELETE FROM trade_history 
                    WHERE entry_time < ? AND status = 'CLOSED'
                ''', (cutoff_date,))
                
                # æ¸…ç†èˆŠçš„æ€§èƒ½çµ±è¨ˆ
                await db.execute('''
                    DELETE FROM performance_stats 
                    WHERE period_end < ?
                ''', (cutoff_date,))
                
                await db.commit()
                
                # åŸ·è¡Œ VACUUM å„ªåŒ–æ•¸æ“šåº«
                if self.optimization_config['auto_vacuum']:
                    await db.execute("VACUUM")
                
                logger.info(f"âœ… æ¸…ç† {days_to_keep} å¤©å‰çš„æ•¸æ“šå®Œæˆ")
                
        except Exception as e:
            logger.error(f"âŒ æ•¸æ“šæ¸…ç†å¤±æ•—: {e}")
```

2. éƒ¨ç½²å’Œé·ç§»è…³æœ¬

```bash
#!/bin/bash
echo "ğŸš€ éƒ¨ç½²å®Œæ•´ TradeRecorder å¢å¼·æ–¹æ¡ˆ..."

# 1. å‚™ä»½ç¾æœ‰æ•¸æ“š
if [ -f "trading_data.db" ]; then
    cp trading_data.db "trading_data.db.backup.$(date +%Y%m%d_%H%M%S)"
    echo "âœ… æ•¸æ“šåº«å‚™ä»½å®Œæˆ"
fi

# 2. å‰µå»ºæ–°çš„ TradeRecorder
cat > src/core/trade_recorder.py << 'EOF'
# [ä¸Šé¢çš„å®Œæ•´ EnhancedTradeRecorder ä»£ç¢¼]
EOF

# 3. å‰µå»ºåˆå§‹åŒ–è…³æœ¬
cat > scripts/init_trade_recorder.py << 'EOF'
#!/usr/bin/env python3
"""
TradeRecorder åˆå§‹åŒ–è…³æœ¬
"""
import asyncio
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from src.core.trade_recorder import EnhancedTradeRecorder

async def main():
    print("ğŸ”§ åˆå§‹åŒ– TradeRecorder...")
    
    class Config:
        pass
    
    config = Config()
    recorder = EnhancedTradeRecorder(config)
    
    # ç­‰å¾…åˆå§‹åŒ–å®Œæˆ
    await asyncio.sleep(2)
    
    # å¥åº·æª¢æŸ¥
    health = await recorder.health_check()
    print("ğŸ“Š TradeRecorder å¥åº·ç‹€æ…‹:")
    for key, value in health.items():
        print(f"  {key}: {value}")
    
    print("âœ… åˆå§‹åŒ–å®Œæˆ")

if __name__ == "__main__":
    asyncio.run(main())
EOF

# 4. æ›´æ–° SelfLearningTrader ä½¿ç”¨æ–°çš„ TradeRecorder
echo "ğŸ“ è«‹æ›´æ–° SelfLearningTrader ä½¿ç”¨ EnhancedTradeRecorder"

# 5. éƒ¨ç½²
git add src/core/trade_recorder.py scripts/init_trade_recorder.py
git commit -m "feat: å®Œæ•´TradeRecorderå¢å¼·æ–¹æ¡ˆ - æ€§èƒ½å„ªåŒ– + é¢¨éšªç®¡ç† + æ•¸æ“šåˆ†æ"
git push origin main

echo "âœ… éƒ¨ç½²å®Œæˆï¼é‹è¡Œåˆå§‹åŒ–è…³æœ¬ï¼š"
echo "python scripts/init_trade_recorder.py"
```

3. ä½¿ç”¨ç¤ºä¾‹

```python
# ä½¿ç”¨æ–°çš„ TradeRecorder
from src.core.trade_recorder import EnhancedTradeRecorder

# åˆå§‹åŒ–
recorder = EnhancedTradeRecorder(config)

# è¨˜éŒ„äº¤æ˜“
await recorder.record_trade({
    'symbol': 'BTCUSDT',
    'direction': 'LONG',
    'entry_price': 35000,
    'position_size': 1000,
    'confidence': 65.5,
    'win_probability': 58.3,
    'risk_reward_ratio': 1.8
})

# ç²å–äº¤æ˜“æ•¸é‡
count = await recorder.get_trade_count('24h')
print(f"24å°æ™‚äº¤æ˜“æ•¸é‡: {count}")

# ç²å–æ€§èƒ½å ±å‘Š
performance = await recorder.get_recent_performance(24)
print(f"å‹ç‡: {performance['win_rate']}%")

# ç²å–ç•¶å‰æŒå€‰
positions = await recorder.get_current_positions()
print(f"ç•¶å‰æŒå€‰: {len(positions)}å€‹")
```

ğŸ¯ å¢å¼·åŠŸèƒ½ç¸½çµ

æ ¸å¿ƒä¿®å¾©ï¼š

1. âœ… å®Œå…¨ä¿®å¾© get_trade_count - æ”¯æŒå¤šæ™‚é–“ç¯„åœå’Œäº¤æ˜“å°éæ¿¾
2. âœ… å®Œæ•´çš„éŒ¯èª¤è™•ç† - æ¯å€‹æ–¹æ³•éƒ½æœ‰å¥å…¨çš„ç•°å¸¸è™•ç†
3. âœ… ç•°æ­¥åˆå§‹åŒ– - é¿å…é˜»å¡ä¸»ç·šç¨‹

æ–°å¢åŠŸèƒ½ï¼š

1. ğŸ¯ å¯¦æ™‚æŒå€‰ç®¡ç† - è·Ÿè¹¤ç•¶å‰æŒå€‰ç‹€æ…‹
2. ğŸ“Š é«˜ç´šæ€§èƒ½åˆ†æ - å‹ç‡ã€ç›ˆè™§ã€æœ€å¤§å›æ’¤ç­‰
3. âš¡ ç·©å­˜å„ªåŒ– - æ¸›å°‘æ•¸æ“šåº«æŸ¥è©¢
4. ğŸ”„ æ•¸æ“šåº«é·ç§» - æ”¯æŒç‰ˆæœ¬å‡ç´š
5. ğŸ§¹ è‡ªå‹•æ¸…ç† - ç®¡ç†æ•¸æ“šåº«å¤§å°
6. ğŸ“ˆ äº¤æ˜“å°åˆ†æ - æŒ‰äº¤æ˜“å°çµ±è¨ˆè¡¨ç¾
7. ğŸ›¡ï¸ é¢¨éšªæŒ‡æ¨™ - VaRã€æ³¢å‹•ç‡ç­‰é¢¨éšªåº¦é‡

æ€§èƒ½å„ªåŒ–ï¼š

1. ğŸš€ WALæ¨¡å¼ - æå‡ä¸¦ç™¼æ€§èƒ½
2. ğŸ“‹ æ‰¹é‡æ“ä½œ - æ¸›å°‘I/Oæ¬¡æ•¸
3. ğŸ” æ™ºèƒ½ç´¢å¼• - åŠ é€ŸæŸ¥è©¢
4. ğŸ’¾ ç·©å­˜ç­–ç•¥ - æ¸›å°‘é‡è¤‡æŸ¥è©¢

é€™å€‹å®Œæ•´çš„å¢å¼·æ–¹æ¡ˆå°‡ TradeRecorder å¾ç°¡å–®çš„è¨˜éŒ„å·¥å…·å‡ç´šç‚ºå°ˆæ¥­çš„äº¤æ˜“åˆ†æç³»çµ±ï¼