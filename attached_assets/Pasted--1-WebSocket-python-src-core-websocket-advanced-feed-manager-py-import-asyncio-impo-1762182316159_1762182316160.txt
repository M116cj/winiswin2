å®Œæ•´æ•´åˆæ–¹æ¡ˆ
1. æ ¸å¿ƒ WebSocket ç®¡ç†å™¨
python
# src/core/websocket/advanced_feed_manager.py

import asyncio
import websockets
import logging
import json
import time
from typing import Set, Callable, Dict, List, Optional
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class AdvancedWebSocketManager:
    """é«˜ç´š WebSocket ç®¡ç†å™¨ - æ•´åˆæ‰€æœ‰ä¿®å¾©æ–¹æ¡ˆ"""
    
    def __init__(self, config):
        self.config = config
        self.feeds = {}
        self.data_buffers = {}
        self.quality_monitor = DataQualityMonitor()
        self.gap_handler = DataGapHandler()
        
        # Railway å„ªåŒ–é…ç½®
        self.ws_config = {
            'max_symbols_per_connection': 150,
            'ping_interval': 20,
            'ping_timeout': 10, 
            'reconnect_base_delay': 1,
            'max_reconnect_delay': 30,
            'connection_timeout': 180,
            'health_check_interval': 30,
            'heartbeat_interval': 180,
        }
        
        # çµ±è¨ˆä¿¡æ¯
        self.stats = {
            'total_messages': 0,
            'successful_reconnects': 0,
            'data_gaps_fixed': 0,
            'quality_issues': 0
        }

    async def initialize_feeds(self, all_symbols: Set[str]):
        """åˆå§‹åŒ–æ‰€æœ‰ WebSocket é¥‹é€"""
        try:
            logger.info("ğŸš€ åˆå§‹åŒ–é«˜ç´š WebSocket ç®¡ç†å™¨")
            
            # åˆ†æ‰¹äº¤æ˜“å°
            symbol_batches = self._create_optimized_batches(all_symbols)
            
            for i, batch in enumerate(symbol_batches):
                feed_name = f"PriceFeed-Shard{i}"
                feed = RobustPriceFeed(feed_name, batch, self.ws_config)
                self.feeds[feed_name] = feed
                
                # åˆå§‹åŒ–æ•¸æ“šç·©è¡å€
                for symbol in batch:
                    self.data_buffers[symbol] = {
                        'kline_1m': [],
                        'kline_5m': [], 
                        'kline_15m': [],
                        'kline_1h': [],
                        'last_update': None,
                        'message_count': 0
                    }
                
                logger.info(f"ğŸ“¡ å‰µå»º {feed_name}: {len(batch)}å€‹äº¤æ˜“å°")
            
            logger.info(f"âœ… WebSocket åˆå§‹åŒ–å®Œæˆ: {len(self.feeds)}å€‹åˆ†ç‰‡")
            
        except Exception as e:
            logger.error(f"âŒ WebSocket åˆå§‹åŒ–å¤±æ•—: {e}")
            raise

    def _create_optimized_batches(self, symbols: Set[str]) -> List[Set[str]]:
        """å‰µå»ºå„ªåŒ–çš„äº¤æ˜“å°æ‰¹æ¬¡"""
        symbol_list = list(symbols)
        batches = []
        
        # æŒ‰äº¤æ˜“å°æ´»èºåº¦æ’åºï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
        # æš«æ™‚ç°¡å–®åˆ†æ‰¹
        for i in range(0, len(symbol_list), self.ws_config['max_symbols_per_connection']):
            batch = set(symbol_list[i:i + self.ws_config['max_symbols_per_connection']])
            batches.append(batch)
            
        return batches

    async def start_all_feeds(self, message_callback: Callable):
        """å•Ÿå‹•æ‰€æœ‰é¥‹é€"""
        try:
            logger.info("ğŸ¯ å•Ÿå‹•æ‰€æœ‰ WebSocket é¥‹é€")
            
            tasks = []
            for feed_name, feed in self.feeds.items():
                # åŒ…è£å›èª¿å‡½æ•¸ï¼ŒåŠ å…¥æ•¸æ“šè™•ç†é‚è¼¯
                wrapped_callback = self._create_wrapped_callback(message_callback)
                task = asyncio.create_task(feed.listen(wrapped_callback))
                tasks.append(task)
                
            # å•Ÿå‹•ç›£æ§ä»»å‹™
            monitor_task = asyncio.create_task(self._start_monitoring_tasks())
            tasks.append(monitor_task)
            
            logger.info("âœ… æ‰€æœ‰é¥‹é€å’Œç›£æ§ä»»å‹™å·²å•Ÿå‹•")
            
            # ç­‰å¾…æ‰€æœ‰ä»»å‹™
            await asyncio.gather(*tasks, return_exceptions=True)
            
        except Exception as e:
            logger.error(f"âŒ å•Ÿå‹•é¥‹é€å¤±æ•—: {e}")

    def _create_wrapped_callback(self, original_callback: Callable) -> Callable:
        """å‰µå»ºåŒ…è£çš„å›èª¿å‡½æ•¸ï¼Œæ•´åˆæ•¸æ“šè™•ç†é‚è¼¯"""
        async def wrapped_callback(data: Dict):
            try:
                # 1. æ•¸æ“šè³ªé‡æª¢æŸ¥
                if not self.quality_monitor.validate_message(data):
                    self.stats['quality_issues'] += 1
                    return
                
                # 2. æ›´æ–°æ•¸æ“šç·©è¡å€
                symbol = self._extract_symbol(data)
                if symbol:
                    await self._update_data_buffers(symbol, data)
                
                # 3. é€£çºŒæ€§æª¢æŸ¥
                self.quality_monitor.check_continuity(symbol, data)
                
                # 4. èª¿ç”¨åŸå§‹å›èª¿
                await original_callback(data)
                
                # 5. æ›´æ–°çµ±è¨ˆ
                self.stats['total_messages'] += 1
                
            except Exception as e:
                logger.error(f"âŒ å›èª¿è™•ç†å¤±æ•—: {e}")
                
        return wrapped_callback

    async def _update_data_buffers(self, symbol: str, data: Dict):
        """æ›´æ–°æ•¸æ“šç·©è¡å€"""
        try:
            if symbol not in self.data_buffers:
                return
                
            buffer = self.data_buffers[symbol]
            buffer['last_update'] = datetime.now()
            buffer['message_count'] += 1
            
            # æ ¹æ“šæ•¸æ“šé¡å‹å­˜å„²åˆ°ç›¸æ‡‰ç·©è¡å€
            stream_type = data.get('stream', '')
            if 'kline_1m' in stream_type:
                self._add_to_kline_buffer(buffer['kline_1m'], data)
            elif 'kline_5m' in stream_type:
                self._add_to_kline_buffer(buffer['kline_5m'], data)
            elif 'kline_15m' in stream_type:
                self._add_to_kline_buffer(buffer['kline_15m'], data)
            elif 'kline_1h' in stream_type:
                self._add_to_kline_buffer(buffer['kline_1h'], data)
                
            # é™åˆ¶ç·©è¡å€å¤§å°
            self._trim_buffers(buffer)
            
        except Exception as e:
            logger.error(f"âŒ æ›´æ–°æ•¸æ“šç·©è¡å€å¤±æ•— {symbol}: {e}")

    def _add_to_kline_buffer(self, buffer: List, data: Dict):
        """æ·»åŠ æ•¸æ“šåˆ°Kç·šç·©è¡å€"""
        try:
            kline_data = data.get('data', {})
            kline = kline_data.get('k', {})
            
            if not kline:
                return
                
            buffer.append({
                'timestamp': kline_data.get('t'),
                'open': float(kline.get('o', 0)),
                'high': float(kline.get('h', 0)),
                'low': float(kline.get('l', 0)),
                'close': float(kline.get('c', 0)),
                'volume': float(kline.get('v', 0)),
                'is_final': kline.get('x', False)
            })
            
        except Exception as e:
            logger.error(f"âŒ æ·»åŠ Kç·šæ•¸æ“šå¤±æ•—: {e}")

    async def _start_monitoring_tasks(self):
        """å•Ÿå‹•ç›£æ§ä»»å‹™"""
        try:
            while True:
                # 1. å¥åº·æª¢æŸ¥
                await self._perform_health_checks()
                
                # 2. æ•¸æ“šè³ªé‡å ±å‘Š
                await self._log_quality_report()
                
                # 3. æª¢æŸ¥æ•¸æ“šç¼ºå£
                await self._check_data_gaps()
                
                await asyncio.sleep(60)  # æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
                
        except Exception as e:
            logger.error(f"âŒ ç›£æ§ä»»å‹™å¤±æ•—: {e}")

    async def _perform_health_checks(self):
        """åŸ·è¡Œå¥åº·æª¢æŸ¥"""
        try:
            healthy_feeds = 0
            for feed_name, feed in self.feeds.items():
                if feed.is_connected and not feed.ws.closed:
                    healthy_feeds += 1
                else:
                    logger.warning(f"âš ï¸ {feed_name} ä¸å¥åº·ï¼Œè§¸ç™¼é‡é€£")
                    asyncio.create_task(feed._handle_reconnect())
            
            logger.debug(f"ğŸ“Š WebSocket å¥åº·ç‹€æ…‹: {healthy_feeds}/{len(self.feeds)} æ­£å¸¸")
            
        except Exception as e:
            logger.error(f"âŒ å¥åº·æª¢æŸ¥å¤±æ•—: {e}")

    async def _log_quality_report(self):
        """è¨˜éŒ„è³ªé‡å ±å‘Š"""
        try:
            active_symbols = sum(1 for buf in self.data_buffers.values() 
                               if buf['last_update'] and 
                               (datetime.now() - buf['last_update']).total_seconds() < 300)
            
            logger.info(
                f"ğŸ“ˆ WebSocket è³ªé‡å ±å‘Š: "
                f"æ¶ˆæ¯={self.stats['total_messages']}, "
                f"æ´»èºäº¤æ˜“å°={active_symbols}/{len(self.data_buffers)}, "
                f"é‡é€£æˆåŠŸ={self.stats['successful_reconnects']}, "
                fæ•¸æ“šç¼ºå£ä¿®å¾©={self.stats['data_gaps_fixed']}, "
                f"è³ªé‡å•é¡Œ={self.stats['quality_issues']}"
            )
            
        except Exception as e:
            logger.error(f"âŒ è³ªé‡å ±å‘Šå¤±æ•—: {e}")

    async def _check_data_gaps(self):
        """æª¢æŸ¥æ•¸æ“šç¼ºå£"""
        try:
            current_time = datetime.now()
            for symbol, buffer in self.data_buffers.items():
                if not buffer['last_update']:
                    continue
                    
                time_since_update = (current_time - buffer['last_update']).total_seconds()
                
                if time_since_update > 120:  # 2åˆ†é˜ç„¡æ•¸æ“š
                    logger.warning(f"âš ï¸ {symbol} æ•¸æ“šç¼ºå£: {time_since_update:.1f}ç§’ç„¡æ›´æ–°")
                    await self.gap_handler.handle_gap(symbol, buffer)
                    self.stats['data_gaps_fixed'] += 1
                    
        except Exception as e:
            logger.error(f"âŒ æ•¸æ“šç¼ºå£æª¢æŸ¥å¤±æ•—: {e}")

    def _extract_symbol(self, data: Dict) -> Optional[str]:
        """å¾æ•¸æ“šä¸­æå–äº¤æ˜“å°"""
        try:
            stream = data.get('stream', '')
            if not stream:
                return None
                
            # æ ¼å¼: btcusdt@kline_1m
            return stream.split('@')[0].upper()
        except:
            return None

    def _trim_buffers(self, buffer: Dict):
        """ä¿®å‰ªç·©è¡å€å¤§å°"""
        for key in ['kline_1m', 'kline_5m', 'kline_15m', 'kline_1h']:
            if len(buffer[key]) > 1000:  # ä¿ç•™æœ€è¿‘1000æ¢
                buffer[key] = buffer[key][-1000:]

    def get_symbol_data(self, symbol: str, timeframe: str) -> List:
        """ç²å–æŒ‡å®šäº¤æ˜“å°å’Œæ™‚é–“æ¡†æ¶çš„æ•¸æ“š"""
        try:
            if symbol not in self.data_buffers:
                return []
                
            buffer_key = f'kline_{timeframe}'
            return self.data_buffers[symbol].get(buffer_key, [])
            
        except Exception as e:
            logger.error(f"âŒ ç²å–äº¤æ˜“å°æ•¸æ“šå¤±æ•— {symbol}: {e}")
            return []