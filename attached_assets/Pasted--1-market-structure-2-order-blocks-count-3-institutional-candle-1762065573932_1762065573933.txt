模型特徵修改方案
1. market_structure       # 市场结构
2. order_blocks_count     # 订单块
3. institutional_candle   # 机构K线
4. liquidity_grab         # 流动性抓取
5. order_flow            # 订单流
6. fvg_count             # FVG
7. trend_alignment       # 多时间框架对齐
8. swing_high_distance   # 价格位置上下文
基础8个 + 
structure_integrity       # 结构完整性
institutional_participation # 机构参与度  
timeframe_convergence     # 时间框架收敛
liquidity_context         # 流动性情境

一、基础特征定义与计算（8个）
1. market_structure（市场结构）
定义：识别市场趋势方向（多头、空头、中性），基于价格摆动点（Swing High/Low）的变化。参考市场结构破坏（MSB）和转换（MSS）概念。

计算方式：

数据源：Binance K线流（如 btcusdt@kline_1h、btcusdt@kline_15m）。

步骤：

在滚动窗口（例如100根K线）中识别摆动点：

摆动高点：某根K线的最高价 > 前N根和后N根K线的最高价（N=5）。

摆动低点：某根K线的最低价 < 前N根和后N根K线的最低价。

判断趋势：

若连续摆动高点和低点 上移，标记为 1（多头）。

若连续摆动高点和低点 下移，标记为 -1（空头）。

否则标记为 0（中性）。

输出：整数（1, -1, 0）。

2. order_blocks_count（订单块数量）
定义：订单块是机构集中买入/卖出导致价格反转的区域。看涨订单块出现在下跌趋势末端（突破前最后一根阴线），看跌订单块出现在上涨趋势末端（突破前最后一根阳线）。

计算方式：

数据源：Binance K线流（如 btcusdt@kline_15m）。

步骤：

识别订单块条件：

看涨订单块：价格创新低后，出现一根阴线（收盘<开盘），随后一根K线突破该阴线高点。

看跌订单块：价格创新高后，出现一根阳线（收盘>开盘），随后一根K线跌破该阳线低点。

在滚动窗口（例如50根K线）内统计已验证的订单块数量（价格回测订单块区域并反转）。

输出：整数（≥0）。

3. institutional_candle（机构K线）
定义：反映大资金进场的K线，通常具有大实体、小影线和高成交量。

计算方式：

数据源：Binance K线流（如 btcusdt@kline_5m）和交易流（btcusdt@trade）。

步骤：

计算K线实体比率：实体大小 = |收盘价 - 开盘价| / (最高价 - 最低价)。

计算成交量Z值：成交量Z = (当前成交量 - 过去20根K线平均成交量) / 标准差。

识别条件：

实体比率 > 0.7（实体主导）。

成交量Z > 2（异常放量）。

影线比率 < 0.3（影线短于实体）。

满足条件时标记为1，否则为0。

输出：二进制（0或1）。

4. liquidity_grab（流动性抓取）
定义：价格快速突破支撑/阻力位以触发止损单，随后迅速反转。

计算方式：

数据源：Binance K线流（如 btcusdt@kline_5m）。

步骤：

识别流动性池：

支撑区：最近摆动低点价格区域。

阻力区：最近摆动高点价格区域。

检测突破与反转：

价格在1根K线内突破支撑/阻力位（超过ATR的0.5倍）。

下一根K线收盘价回归原区间并形成反转形态（如锤子线、吞没）。

满足条件时标记为1，否则为0。

输出：二进制（0或1）。

5. order_flow（订单流）
定义：实时买卖压力平衡，通过主动买入/卖出量衡量。

计算方式：

数据源：Binance逐笔交易流（btcusdt@trade）。

步骤：

解析交易数据中的m字段：

m = true：主动卖出（做市方卖出）。

m = false：主动买入（做市方买入）。

在时间窗口（例如1分钟）内计算：

主动买入量 = SUM(交易量 WHERE m = false)。

主动卖出量 = SUM(交易量 WHERE m = true)。

订单流 = (主动买入量 - 主动卖出量) / (主动买入量 + 主动卖出量)。

输出：标准化值（-1到1）。

6. fvg_count（FVG数量）
定义：公允价值缺口，是价格跳空形成的未交易区域，通常被回填。

计算方式：

数据源：Binance K线流（如 btcusdt@kline_5m）。

步骤：

识别FVG条件（基于连续3根K线）：

看涨FVG：第一根K线最低价 > 第三根K线最高价。

看跌FVG：第一根K线最高价 < 第三根K线最低价。

在滚动窗口（例如30根K线）内统计未回填的FVG数量（价格未重新进入缺口区间）。

输出：整数（≥0）。

7. trend_alignment（趋势对齐度）
定义：多时间框架趋势的一致性，越高表示趋势动能越强。

计算方式：

数据源：Binance多时间框架K线流（如1h、15m、5m）。

步骤：

分别计算1小时、15分钟、5分钟K线的market_structure（方法同特征1）。

计算对齐度得分：

若三个时间框架趋势相同（全为1或全为-1），得分为1.0。

若两个相同，得分为0.5。

若全部不同，得分为0。

输出：连续值（0到1）。

8. swing_high_distance（摆动高点距离）
定义：当前价格与最近摆动高点的距离，反映价格相对位置。

计算方式：

数据源：Binance K线流（如 btcusdt@kline_15m）。

步骤：

识别最近摆动高点（方法同特征1）。

计算标准化距离：

距离 = (当前价格 - 摆动高点价格) / ATR(14)。

使用ATR标准化以消除波动性影响。

输出：标准化值（负值表示当前价格低于摆动高点）。

二、合成特征定义与计算（4个）
1. structure_integrity（结构完整性）
定义：市场结构的健康程度，基于订单块、FVG和市场趋势的稳定性。

计算方式：

公式：

text
structure_integrity = 0.4 * I(market_structure ≠ 0) + 0.3 * (1 - min(1, fvg_count / 5)) + 0.3 * tanh(order_blocks_count / 3)
I(·)为指示函数（结构明确时取1）。

tanh用于将订单块数量压缩到0-1。

逻辑：趋势明确、FVG少、订单块多时得分高。

输出：连续值（0到1）。

2. institutional_participation（机构参与度）
定义：机构资金活跃度，结合机构K线、订单流和流动性抓取。

计算方式：

公式：

text
institutional_participation = 0.5 * institutional_candle + 0.3 * abs(order_flow) + 0.2 * liquidity_grab
order_flow取绝对值（强调买卖压力强度）。

逻辑：机构K线出现、订单流失衡、流动性抓取发生时得分高。

输出：连续值（0到1）。

3. timeframe_convergence（时间框架收敛）
定义：多时间框架趋势的动态收敛程度，基于短期趋势与长期趋势的相关性。

计算方式：

数据源：1小时、15分钟、5分钟K线的market_structure。

步骤：

计算趋势向量：T = [trend_1h, trend_15m, trend_5m]。

计算收敛度：

收敛度 = 1 - (标准差(T) / 2)，其中趋势值映射为数值（1, -1, 0）。

输出：连续值（0到1）。

4. liquidity_context（流动性情境）
定义：市场流动性的综合状态，结合订单簿深度和流动性抓取事件。

计算方式：

数据源：Binance深度流（btcusdt@depth）和K线流。

步骤：

从深度流获取最佳买卖价和数量：

深度 = (最佳买价数量 + 最佳卖价数量) / 2。

价差 = (最佳卖价 - 最佳买价) / 最佳买价。

计算流动性得分：

流动性得分 = 0.6 * tanh(深度 / 100) + 0.4 * (1 - min(1, 价差 / 0.001))。

结合流动性抓取：liquidity_context = 0.7 * 流动性得分 + 0.3 * liquidity_grab。

输出：连续值（0到1）。

三、Binance WebSocket实施指南
关键数据流订阅
K线流：用于大多数特征（如市场结构、订单块）。

示例：订阅btcusdt@kline_1h、btcusdt@kline_15m、btcusdt@kline_5m。

数据字段：k.t（开盘时间）、k.o（开盘价）、k.h（最高价）、k.l（最低价）、k.c（收盘价）、k.v（成交量）。

交易流：用于订单流。

示例：订阅btcusdt@trade。

数据字段：p（价格）、q（数量）、m（是否主动卖出）。

深度流：用于流动性情境。

示例：订阅btcusdt@depth。

数据字段：b（买单数组[价格,数量]）、a（卖单数组[价格,数量]）。

实时计算引擎设计
数据缓冲：

维护滚动窗口的K线数据（例如100根），用于计算摆动点和趋势。

缓存最近的交易数据（例如1分钟），用于订单流。

事件驱动更新：

当收到新K线时，更新market_structure、order_blocks_count等。

当收到交易流时，实时更新order_flow。

频率控制：

特征计算频率与K线间隔同步（例如每5分钟更新一次）。

订单流和流动性情境可每秒更新。

示例代码逻辑（Python伪代码）
python
import websocket
import json
from collections import deque

# 数据缓冲
kline_buffer = deque(maxlen=100)
trade_buffer = deque(maxlen=1000)

def on_message(ws, message):
    data = json.loads(message)
    if 'k' in data:  # K线流
        kline = data['k']
        kline_buffer.append(kline)
        update_market_structure()
        update_order_blocks()
    elif 'e' in data and data['e'] == 'trade':  # 交易流
        trade_buffer.append(data)
        update_order_flow()

def update_market_structure():
    # 基于kline_buffer计算摆动点和趋势
    swings = find_swing_highs_lows(kline_buffer)
    trend = determine_trend(swings)
    # 更新特征值...

# 类似实现其他特征...
四、注意事项
滞后性控制：

优先使用短期K线（如5分钟）和实时交易流。

避免依赖移动平均等滞后指标，改用价格行为（如摆动点、订单块）。

标准化处理：

所有连续特征使用ATR或Z-score标准化，确保跨资产可比性。

验证与回测：

通过历史K线数据验证订单块和FVG的识别准确性。

回测特征与交易绩效的相关性（如胜率、盈亏比）