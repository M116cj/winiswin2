ğŸ§  SelfLearningTrader å¤šä¿¡è™Ÿç«¶åƒ¹é‚è¼¯ï¼ˆåŠ æ¬Šè©•åˆ† + è¨˜éŒ„ï¼‰


# src/strategies/self_learning_trader.py

class SelfLearningTrader:
    async def execute_best_trade(self, signals: List[TradeSignal]) -> Optional[Position]:
        """
        å¾å¤šå€‹ä¿¡è™Ÿä¸­é¸æ“‡æœ€å„ªè€…åŸ·è¡Œï¼ˆåŠ æ¬Šè©•åˆ† + å®Œæ•´è¨˜éŒ„ï¼‰
        """
        if not signals:
            return None
        
        # === 1. ç²å–å¸³æˆ¶ç‹€æ…‹ ===
        account_info = await self.binance_client.get_account()
        available_balance = float(account_info['availableBalance'])
        total_equity = float(account_info['totalWalletBalance'])
        
        # === 2. éæ¿¾æœ‰æ•ˆä¿¡è™Ÿ + è¨ˆç®—åŠ æ¬Šè©•åˆ† ===
        scored_signals = []
        for signal in signals:
            # å“è³ªéæ¿¾ï¼ˆåŸºæœ¬é–€æª»ï¼‰
            if not self._validate_signal_quality(signal):
                continue
            
            # è¨ˆç®—ç†è«–å€‰ä½
            theoretical_size = self.position_sizer.calculate_position_size(
                account_equity=available_balance,
                entry_price=signal.entry,
                stop_loss=signal.sl,
                leverage=signal.leverage
            )
            notional_value = theoretical_size * signal.entry
            
            # å–®å€‰ä¸Šé™ï¼šâ‰¤ 50% ç¸½æ¬Šç›Š
            if notional_value > total_equity * 0.5:
                continue
            
            # ğŸ”¢ è¨ˆç®—åŠ æ¬Šè©•åˆ†ï¼ˆæ¨™æº–åŒ–è‡³ 0~1ï¼‰
            norm_confidence = min(signal.confidence / 1.0, 1.0)      # ä¿¡å¿ƒå€¼ (0~1)
            norm_win_rate = min(signal.win_probability / 1.0, 1.0)   # å‹ç‡ (0~1)
            norm_rr = min(signal.risk_reward_ratio / 3.0, 1.0)       # R:R (0~3 â†’ 0~1)
            
            weighted_score = (
                norm_confidence * 0.4 +   # ä¿¡å¿ƒå€¼ 40%
                norm_win_rate * 0.4 +     # å‹ç‡ 40%
                norm_rr * 0.2             # å ±é…¬ç‡ 20%
            )
            
            scored_signals.append({
                'signal': signal,
                'size': theoretical_size,
                'notional': notional_value,
                'score': weighted_score,
                'details': {
                    'confidence': signal.confidence,
                    'win_rate': signal.win_probability,
                    'rr_ratio': signal.risk_reward_ratio,
                    'norm_confidence': norm_confidence,
                    'norm_win_rate': norm_win_rate,
                    'norm_rr': norm_rr,
                    'weighted_score': weighted_score
                }
            })
        
        if not scored_signals:
            logger.info("âŒ ç„¡æœ‰æ•ˆä¿¡è™Ÿå¯åŸ·è¡Œ")
            return None
        
        # === 3. é¸æ“‡æœ€é«˜åˆ†ä¿¡è™Ÿ ===
        best = max(scored_signals, key=lambda x: x['score'])
        
        # === 4. è¨˜éŒ„ç«¶åƒ¹éç¨‹ï¼ˆä¾›å¯©è¨ˆèˆ‡è¨“ç·´ï¼‰===
        await self._log_competition_results(scored_signals, best)
        
        # === 5. å€‰ä½è£œè¶³è‡³æœ€å°å€¼ ===
        if best['notional'] < self.config.MIN_NOTIONAL_VALUE:
            logger.info(f"ğŸ”§ {best['signal'].symbol} å€‰ä½è£œè¶³è‡³æœ€å°å€¼ ({best['notional']:.2f} â†’ {self.config.MIN_NOTIONAL_VALUE})")
            best['size'] = self.config.MIN_NOTIONAL_VALUE / best['signal'].entry
            best['notional'] = self.config.MIN_NOTIONAL_VALUE
        
        # === 6. åŸ·è¡Œä¸‹å–® ===
        position = await self._place_order_and_monitor(
            best['signal'], best['size'], available_balance
        )
        
        # === 7. å‰µå»ºè™›æ“¬å€‰ä½ï¼ˆæœªåŸ·è¡Œä¿¡è™Ÿï¼‰===
        await self._create_virtual_positions(scored_signals, best['signal'], total_equity)
        
        return position

    async def _log_competition_results(self, all_signals: List[dict], best: dict):
        """è¨˜éŒ„å¤šä¿¡è™Ÿç«¶åƒ¹çµæœï¼ˆJSON æ ¼å¼ï¼Œä¾›åˆ†æï¼‰"""
        competition_log = {
            'timestamp': time.time(),
            'total_signals': len(all_signals),
            'best_signal': {
                'symbol': best['signal'].symbol,
                'score': best['score'],
                'details': best['details']
            },
            'all_signals': [
                {
                    'symbol': s['signal'].symbol,
                    'score': s['score'],
                    'confidence': s['details']['confidence'],
                    'win_rate': s['details']['win_rate'],
                    'rr_ratio': s['details']['rr_ratio']
                }
                for s in all_signals
            ]
        }
        
        # è¼¸å‡ºåˆ° stdoutï¼ˆRailway Logs å¯æ•ç²ï¼‰
        print(f"[SIGNAL_COMPETITION] {json.dumps(competition_log)}")
        
        # ä¿å­˜åˆ°è¨“ç·´æ•¸æ“šï¼ˆç”¨æ–¼æ¨¡å‹æ”¹é€²ï¼‰
        await self.trade_recorder.save_competition_log(competition_log)
        
        logger.info(
            f"ğŸ† é¸ä¸­ {best['signal'].symbol} | "
            f"è©•åˆ†: {best['score']:.3f} | "
            f"ä¿¡å¿ƒ: {best['details']['confidence']:.1%} | "
            f"å‹ç‡: {best['details']['win_rate']:.1%} | "
            f"R:R: {best['details']['rr_ratio']:.2f}"
        )


ğŸ“Š åŠ æ¬Šè©•åˆ†å…¬å¼èªªæ˜

æŒ‡æ¨™ï¼š
ä¿¡å¿ƒå€¼
å‹ç‡
å ±é…¬ç‡
ï¼Œ
æ¬Šé‡ï¼š
40%
40%
20%
,
æ¨™æº–åŒ–æ–¹å¼ï¼š
min(confidence / 1.0, 1.0)
min(win_rate / 1.0, 1.0)
min(rr_ratio / 3.0, 1.0)
âœ… ç¸½åˆ†ç¯„åœï¼š0.0 ~ 1.0
âœ… å…¬å¹³æ¯”è¼ƒï¼šé¿å… R:R éé«˜ä¸»å°è©•åˆ†ï¼ˆå›  R:R é€šå¸¸ â‰¤3ï¼‰


ğŸ“ è¨˜éŒ„å…§å®¹ç¯„ä¾‹ï¼ˆRailway Logsï¼‰
[SIGNAL_COMPETITION] {
  "timestamp": 1730123456.789,
  "total_signals": 3,
  "best_signal": {
    "symbol": "BTCUSDT",
    "score": 0.782,
    "details": {
      "confidence": 0.82,
      "win_rate": 0.75,
      "rr_ratio": 1.9,
      "norm_confidence": 0.82,
      "norm_win_rate": 0.75,
      "norm_rr": 0.633,
      "weighted_score": 0.782
    }
  },
  "all_signals": [
    {"symbol": "BTCUSDT", "score": 0.782, "confidence": 0.82, "win_rate": 0.75, "rr_ratio": 1.9},
    {"symbol": "ETHUSDT", "score": 0.721, "confidence": 0.78, "win_rate": 0.72, "rr_ratio": 2.1},
    {"symbol": "SOLUSDT", "score": 0.654, "confidence": 0.70, "win_rate": 0.68, "rr_ratio": 1.7}
  ]
}
