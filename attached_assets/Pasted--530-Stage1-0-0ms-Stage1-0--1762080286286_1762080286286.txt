çœ‹åˆ°æ—¥å¿—åï¼Œé—®é¢˜éå¸¸æ˜ç¡®äº†ï¼æ‰€æœ‰530ä¸ªäº¤æ˜“å¯¹éƒ½åœ¨Stage1éªŒè¯é˜¶æ®µè¢«æ‹’ç»ï¼Œå¯¼è‡´å¹³å‡åˆ†ææ—¶é—´ä¸º0.0msã€‚

ğŸš¨ æ ¹æœ¬åŸå› ç¡®è®¤

ä»æ—¥å¿—å¯ä»¥çœ‹åˆ°ï¼š

```
Stage1é©—è­‰: æœ‰æ•ˆ=0, æ‹’çµ•=530
Stage3æ–¹å‘: æœ‰=0, ç„¡=0
å¹³å‡åˆ†ææ™‚é–“: 0.0ms
```

é—®é¢˜å®šä½ï¼š_validate_klines_data æ–¹æ³•è¿‡äºä¸¥æ ¼ï¼Œæ‰€æœ‰äº¤æ˜“å¯¹çš„æ•°æ®éªŒè¯éƒ½å¤±è´¥äº†ã€‚

ğŸ”§ ç«‹å³ä¿®å¤æ–¹æ¡ˆ

æ­¥éª¤1ï¼šæ”¾å®½æ•°æ®éªŒè¯æ¡ä»¶

åœ¨rule_based_signal_generator.pyä¸­ä¿®æ”¹_validate_klines_dataæ–¹æ³•ï¼š

```python
def _validate_klines_data(self, multi_tf_data):
    """æ”¾å®½çš„æ•°æ®éªŒè¯ - åªæ£€æŸ¥æœ€åŸºæœ¬çš„æ•°æ®å®Œæ•´æ€§"""
    logger.info("ğŸ” æ•°æ®éªŒè¯å¼€å§‹ (æ”¾å®½ç‰ˆæœ¬)")
    
    required_tfs = ['1h', '15m', '5m']
    
    for tf in required_tfs:
        logger.info(f"ğŸ“Š æ£€æŸ¥æ—¶é—´æ¡†æ¶: {tf}")
        
        if tf not in multi_tf_data:
            logger.warning(f"âš ï¸ ç¼ºå¤±æ—¶é—´æ¡†æ¶: {tf}")
            logger.warning(f"   å¯ç”¨æ—¶é—´æ¡†æ¶: {list(multi_tf_data.keys())}")
            return False
        
        df = multi_tf_data[tf]
        logger.info(f"   DataFrameç±»å‹: {type(df)}, è¡Œæ•°: {len(df) if df is not None else 'None'}")
        
        if df is None:
            logger.warning(f"âš ï¸ {tf} æ•°æ®ä¸ºNone")
            return False
            
        # å¤§å¹…æ”¾å®½æ•°æ®é•¿åº¦è¦æ±‚ï¼šä»50é™ä½åˆ°5
        if len(df) < 5:
            logger.warning(f"âš ï¸ {tf} æ•°æ®è¡Œæ•°ä¸è¶³: {len(df)}è¡Œ (<5)")
            return False
            
        # æ£€æŸ¥åŸºæœ¬åˆ—
        required_cols = ['open', 'high', 'low', 'close']
        missing_cols = [col for col in required_cols if col not in df.columns]
        
        if missing_cols:
            logger.warning(f"âš ï¸ {tf} ç¼ºå¤±åŸºæœ¬åˆ—: {missing_cols}")
            logger.warning(f"   ç°æœ‰åˆ—: {list(df.columns)}")
            return False
        
        logger.info(f"âœ… {tf} æ•°æ®éªŒè¯é€šè¿‡")
    
    logger.info("ğŸ‰ æ‰€æœ‰æ—¶é—´æ¡†æ¶æ•°æ®éªŒè¯é€šè¿‡!")
    return True
```

æ­¥éª¤2ï¼šæ·»åŠ æ•°æ®æ ·æœ¬æ£€æŸ¥

åœ¨éªŒè¯é€šè¿‡åæ·»åŠ æ•°æ®æ ·æœ¬æ£€æŸ¥ï¼š

```python
def _debug_data_samples(self, multi_tf_data):
    """è°ƒè¯•æ•°æ®æ ·æœ¬"""
    logger.info("ğŸ” æ•°æ®æ ·æœ¬æ£€æŸ¥:")
    
    for tf, df in multi_tf_data.items():
        if df is not None and len(df) > 0:
            sample = df[['open', 'high', 'low', 'close']].head(3).to_dict('records')
            logger.info(f"   {tf} å‰3è¡Œæ ·æœ¬: {sample}")
            
            # æ£€æŸ¥æ•°æ®å€¼èŒƒå›´
            latest_close = df.iloc[-1]['close']
            logger.info(f"   {tf} æœ€æ–°æ”¶ç›˜ä»·: {latest_close}")
```

æ­¥éª¤3ï¼šå¼ºåˆ¶é€šè¿‡éªŒè¯è¿›è¡Œæµ‹è¯•

å¦‚æœæ”¾å®½åä»ç„¶å¤±è´¥ï¼Œä¸´æ—¶å¼ºåˆ¶é€šè¿‡éªŒè¯ï¼š

```python
def _validate_klines_data(self, multi_tf_data):
    """ä¸´æ—¶å¼ºåˆ¶é€šè¿‡éªŒè¯è¿›è¡Œæµ‹è¯•"""
    logger.warning("ğŸ§ª ä¸´æ—¶å¼ºåˆ¶é€šè¿‡æ•°æ®éªŒè¯è¿›è¡Œæµ‹è¯•!")
    
    # åŸºæœ¬æ£€æŸ¥
    required_tfs = ['1h', '15m', '5m']
    for tf in required_tfs:
        if tf not in multi_tf_data:
            logger.error(f"âŒ ç¼ºå¤±å…³é”®æ—¶é—´æ¡†æ¶: {tf}")
            return False
        
        df = multi_tf_data[tf]
        if df is None or len(df) == 0:
            logger.error(f"âŒ {tf} æ•°æ®ä¸ºç©º")
            return False
    
    # è°ƒè¯•æ•°æ®
    self._debug_data_samples(multi_tf_data)
    
    logger.info("ğŸ‰ å¼ºåˆ¶éªŒè¯é€šè¿‡ï¼Œç»§ç»­åˆ†ææµç¨‹")
    return True
```

æ­¥éª¤4ï¼šä¿®æ”¹æ‰«æé€»è¾‘ç»•è¿‡éªŒè¯

åœ¨unified_scheduler.pyä¸­æ·»åŠ ç»•è¿‡éªŒè¯çš„é€‰é¡¹ï¼š

```python
def scan_symbols(self):
    # ä¸´æ—¶ç»•è¿‡éªŒè¯è¿›è¡Œæµ‹è¯•
    bypass_validation = True  # è®¾ç½®ä¸ºTrueè¿›è¡Œæµ‹è¯•
    
    for symbol in self.symbols:
        multi_tf_data = self.data_service.get_multi_timeframe_klines(symbol, self.timeframes)
        if not multi_tf_data:
            continue
            
        if bypass_validation:
            logger.info(f"ğŸ§ª ç»•è¿‡éªŒè¯ï¼Œå¼ºåˆ¶åˆ†æ {symbol}")
            # ç›´æ¥è°ƒç”¨åˆ†ææ–¹æ³•ï¼Œè·³è¿‡éªŒè¯
            signal, confidence, win_prob = self._force_analyze_bypass_validation(symbol, multi_tf_data)
        else:
            signal, confidence, win_prob = self.self_learning_trader.analyze(symbol, multi_tf_data)
        
        # æ”¶é›†ç»“æœ...

def _force_analyze_bypass_validation(self, symbol, multi_tf_data):
    """å¼ºåˆ¶ç»•è¿‡éªŒè¯çš„åˆ†ææ–¹æ³•"""
    try:
        # ç›´æ¥è°ƒç”¨ä¿¡å·ç”Ÿæˆå™¨çš„å†…éƒ¨æ–¹æ³•
        signal_generator = self.self_learning_trader.signal_generator
        
        # å¼ºåˆ¶è®¾ç½®æ–¹å‘è¿›è¡Œæµ‹è¯•
        direction = "LONG"
        
        if hasattr(signal_generator, 'use_pure_ict') and signal_generator.use_pure_ict:
            # çº¯ICTæ¨¡å¼
            ict_features = signal_generator.feature_engine._build_ict_smc_features(
                signal={'symbol': symbol, 'direction': direction},
                klines_data=multi_tf_data
            )
            
            current_price = multi_tf_data['1h'].iloc[-1]['close']
            confidence, sub_scores = signal_generator._calculate_confidence_pure_ict(
                ict_features, direction, "NEUTRAL", [], current_price
            )
            win_prob = signal_generator._calculate_win_probability_pure_ict(
                confidence, ict_features, direction, [], current_price
            )
        else:
            # ä¼ ç»Ÿæ¨¡å¼
            confidence, sub_scores = signal_generator._calculate_confidence(multi_tf_data, direction, "NEUTRAL", [])
            win_prob = signal_generator._calculate_ema_based_win_probability(confidence, multi_tf_data, direction, [])
        
        logger.info(f"ğŸ§ª å¼ºåˆ¶åˆ†æç»“æœ: {symbol} - ä¿¡å¿ƒ={confidence}, èƒœç‡={win_prob}")
        return None, confidence, win_prob * 100
        
    except Exception as e:
        logger.error(f"âŒ å¼ºåˆ¶åˆ†æå¤±è´¥: {e}")
        return None, 0.0, 0.0
```

ğŸ¯ å®æ–½ä¼˜å…ˆçº§

ç«‹å³æ‰§è¡Œï¼ˆ5åˆ†é’Ÿï¼‰ï¼š

1. æ”¾å®½æ•°æ®éªŒè¯ - å°†é•¿åº¦è¦æ±‚ä»50é™ä½åˆ°5
2. æ·»åŠ è¯¦ç»†æ—¥å¿— - æ˜¾ç¤ºå…·ä½“å¤±è´¥åŸå› 
3. éƒ¨ç½²æµ‹è¯• - è§‚å¯Ÿæ˜¯å¦è¿˜æœ‰äº¤æ˜“å¯¹è¢«æ‹’ç»

å¦‚æœä»ç„¶å¤±è´¥ï¼ˆ5åˆ†é’Ÿï¼‰ï¼š

1. å¼ºåˆ¶é€šè¿‡éªŒè¯ - ä¸´æ—¶ç»•è¿‡éªŒè¯é€»è¾‘
2. ç›´æ¥è°ƒç”¨åˆ†ææ–¹æ³• - æµ‹è¯•ä¿¡å·ç”Ÿæˆæ ¸å¿ƒé€»è¾‘
3. æ£€æŸ¥æ•°æ®æ ¼å¼ - ç¡®è®¤WebSocketæ•°æ®æ ¼å¼

ğŸ“Š é¢„æœŸä¿®å¤ç»“æœ

ä¿®å¤ååº”è¯¥çœ‹åˆ°ï¼š

```
ğŸ” æ•°æ®éªŒè¯å¼€å§‹ (æ”¾å®½ç‰ˆæœ¬)
ğŸ“Š æ£€æŸ¥æ—¶é—´æ¡†æ¶: 1h
   DataFrameç±»å‹: <class 'pandas.core.frame.DataFrame'>, è¡Œæ•°: 100
âœ… 1h æ•°æ®éªŒè¯é€šè¿‡
...
ğŸ‰ æ‰€æœ‰æ—¶é—´æ¡†æ¶æ•°æ®éªŒè¯é€šè¿‡!
Stage1é©—è­‰: æœ‰æ•ˆ=530, æ‹’çµ•=0
å¹³å‡åˆ†ææ™‚é–“: 45.2ms
```

è¯·ç«‹å³å®æ–½æ”¾å®½æ•°æ®éªŒè¯æ–¹æ¡ˆï¼Œè¿™åº”è¯¥èƒ½ç«‹å³è§£å†³å¿«é€Ÿè·³è¿‡é—®é¢˜ï¼