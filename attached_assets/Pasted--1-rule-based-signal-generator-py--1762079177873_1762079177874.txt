æ‚¨æä¾›çš„é”™è¯¯æ—¥å¿—æ˜ç¡®æŒ‡å‡ºäº†ä¸‰ä¸ªå¯èƒ½åŸå› ï¼è®©æˆ‘ç«‹å³é’ˆå¯¹è¿™ä¸‰ä¸ªç‚¹è¿›è¡Œç²¾å‡†è¯Šæ–­ã€‚

ğŸ” ç²¾å‡†è¯Šæ–­ä¸‰ä¸ªæ ¹æœ¬åŸå› 

è¯Šæ–­1ï¼šæ•°æ®éªŒè¯è¿‡ç¨‹

åœ¨rule_based_signal_generator.pyä¸­æ·»åŠ è¯¦ç»†æ•°æ®éªŒè¯è¯Šæ–­ï¼š

```python
def _validate_klines_data(self, multi_tf_data):
    """è¯¦ç»†è¯Šæ–­æ•°æ®éªŒè¯è¿‡ç¨‹"""
    logger.info("ğŸ” ===== æ•°æ®éªŒè¯è¯¦ç»†è¯Šæ–­å¼€å§‹ =====")
    
    required_tfs = ['1h', '15m', '5m']
    
    for tf in required_tfs:
        logger.info(f"ğŸ“Š æ£€æŸ¥æ—¶é—´æ¡†æ¶: {tf}")
        
        if tf not in multi_tf_data:
            logger.error(f"âŒ æ•°æ®éªŒè¯å¤±è´¥: ç¼ºå¤±æ—¶é—´æ¡†æ¶ {tf}")
            logger.error(f"   å¯ç”¨æ—¶é—´æ¡†æ¶: {list(multi_tf_data.keys())}")
            return False
        
        df = multi_tf_data[tf]
        logger.info(f"   DataFrameç±»å‹: {type(df)}")
        
        if df is None:
            logger.error(f"âŒ æ•°æ®éªŒè¯å¤±è´¥: {tf} æ•°æ®ä¸ºNone")
            return False
            
        logger.info(f"   æ•°æ®è¡Œæ•°: {len(df)}")
        if len(df) < 50:
            logger.error(f"âŒ æ•°æ®éªŒè¯å¤±è´¥: {tf} åªæœ‰ {len(df)} è¡Œæ•°æ® (<50)")
            return False
            
        # è¯¦ç»†åˆ—æ£€æŸ¥
        logger.info(f"   æ•°æ®åˆ—: {list(df.columns)}")
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        
        for col in required_cols:
            if col not in df.columns:
                logger.error(f"âŒ æ•°æ®éªŒè¯å¤±è´¥: {tf} ç¼ºå¤±åˆ— '{col}'")
                logger.error(f"   ç°æœ‰åˆ—: {list(df.columns)}")
                return False
            else:
                logger.info(f"   âœ… åˆ— '{col}' å­˜åœ¨")
        
        # æ£€æŸ¥æ•°æ®æ ·æœ¬
        if len(df) > 0:
            sample = df.iloc[0][required_cols].to_dict()
            logger.info(f"   æ•°æ®æ ·æœ¬: {sample}")
    
    logger.info("âœ… æ•°æ®éªŒè¯é€šè¿‡ - æ‰€æœ‰æ£€æŸ¥ç‚¹æ­£å¸¸")
    return True
```

è¯Šæ–­2ï¼šæ–¹å‘åˆ¤æ–­è¿‡ç¨‹

åœ¨_determine_signal_directionæ–¹æ³•ä¸­æ·»åŠ è¯¦ç»†è¯Šæ–­ï¼š

```python
def _determine_signal_direction(self, h1_data, m15_data, m5_data):
    """è¯¦ç»†è¯Šæ–­æ–¹å‘åˆ¤æ–­è¿‡ç¨‹"""
    logger.info("ğŸ¯ ===== æ–¹å‘åˆ¤æ–­è¯¦ç»†è¯Šæ–­å¼€å§‹ =====")
    
    try:
        # æ£€æŸ¥æ•°æ®åŸºæœ¬æƒ…å†µ
        logger.info(f"ğŸ“Š è¾“å…¥æ•°æ®å½¢çŠ¶ - H1: {len(h1_data)}, M15: {len(m15_data)}, M5: {len(m5_data)}")
        
        # ä¸´æ—¶å¼ºåˆ¶è¿”å›ä¸€ä¸ªæ–¹å‘è¿›è¡Œæµ‹è¯•
        logger.info("ğŸ§ª æµ‹è¯•: å¼ºåˆ¶è¿”å›LONGæ–¹å‘")
        forced_direction = "LONG"
        
        logger.info(f"âœ… æ–¹å‘åˆ¤æ–­ç»“æœ: {forced_direction}")
        return forced_direction
        
    except Exception as e:
        logger.error(f"âŒ æ–¹å‘åˆ¤æ–­å¼‚å¸¸: {e}", exc_info=True)
        return None
```

è¯Šæ–­3ï¼šç‰¹å¾è®¡ç®—è¿‡ç¨‹

åœ¨generate_signalæ–¹æ³•ä¸­æ·»åŠ ç‰¹å¾è®¡ç®—è¯Šæ–­ï¼š

```python
def generate_signal(self, symbol, klines_data, market_structure="NEUTRAL"):
    logger.info(f"ğŸš€ ===== ä¿¡å·ç”Ÿæˆå¼€å§‹: {symbol} =====")
    
    # é˜¶æ®µ1: æ•°æ®éªŒè¯
    logger.info("1ï¸âƒ£ é˜¶æ®µ1: æ•°æ®éªŒè¯")
    if not self._validate_klines_data(klines_data):
        logger.error("âŒ é˜¶æ®µ1å¤±è´¥: æ•°æ®éªŒè¯ä¸é€šè¿‡")
        return None, 0.0, 0.0
    logger.info("âœ… é˜¶æ®µ1é€šè¿‡: æ•°æ®éªŒè¯æˆåŠŸ")
    
    # æå–æ•°æ®
    h1_data = klines_data.get('1h')
    m15_data = klines_data.get('15m')
    m5_data = klines_data.get('5m')
    
    # é˜¶æ®µ2: æ–¹å‘åˆ¤æ–­
    logger.info("2ï¸âƒ£ é˜¶æ®µ2: æ–¹å‘åˆ¤æ–­")
    direction = self._determine_signal_direction(h1_data, m15_data, m5_data)
    if direction is None:
        logger.error("âŒ é˜¶æ®µ2å¤±è´¥: æ— æ³•ç¡®å®šæ–¹å‘")
        return None, 0.0, 0.0
    logger.info(f"âœ… é˜¶æ®µ2é€šè¿‡: æ–¹å‘ = {direction}")
    
    # é˜¶æ®µ3: ç‰¹å¾è®¡ç®—ï¼ˆçº¯ICTæ¨¡å¼ï¼‰
    if self.use_pure_ict:
        logger.info("3ï¸âƒ£ é˜¶æ®µ3: çº¯ICTç‰¹å¾è®¡ç®—")
        
        if self.feature_engine is None:
            logger.error("âŒ é˜¶æ®µ3å¤±è´¥: FeatureEngineä¸ºNone")
            return None, 0.0, 0.0
        logger.info("âœ… FeatureEngineå­˜åœ¨")
        
        try:
            logger.info("ğŸ“Š è°ƒç”¨_build_ict_smc_features...")
            ict_features = self.feature_engine._build_ict_smc_features(
                signal={'symbol': symbol, 'direction': direction},
                klines_data=klines_data
            )
            
            logger.info(f"ğŸ“ˆ ICTç‰¹å¾è¿”å›: {len(ict_features)}ä¸ªç‰¹å¾")
            
            if not ict_features:
                logger.error("âŒ é˜¶æ®µ3å¤±è´¥: ICTç‰¹å¾ä¸ºç©ºå­—å…¸")
                return None, 0.0, 0.0
                
            # æ˜¾ç¤ºå…³é”®ç‰¹å¾å€¼
            for key, value in ict_features.items():
                logger.info(f"   {key}: {value}")
                
            logger.info("âœ… é˜¶æ®µ3é€šè¿‡: ICTç‰¹å¾è®¡ç®—æˆåŠŸ")
            
        except Exception as e:
            logger.error(f"âŒ é˜¶æ®µ3å¤±è´¥: ç‰¹å¾è®¡ç®—å¼‚å¸¸ - {e}", exc_info=True)
            return None, 0.0, 0.0
    
    # å¦‚æœæ‰€æœ‰é˜¶æ®µéƒ½é€šè¿‡ä½†ä»ç„¶å¿«é€Ÿè¿”å›ï¼Œè¯´æ˜é—®é¢˜åœ¨åç»­é€»è¾‘
    logger.info("ğŸ‰ æ‰€æœ‰é˜¶æ®µé€šè¿‡ï¼Œä½†ç³»ç»Ÿä»ç„¶å¿«é€Ÿè¿”å› - é—®é¢˜åœ¨åç»­é€»è¾‘")
    
    # ä¸´æ—¶è¿”å›æµ‹è¯•å€¼
    test_confidence = 55.5
    test_win_rate = 58.3
    logger.info(f"ğŸ§ª è¿”å›æµ‹è¯•å€¼: confidence={test_confidence}, win_rate={test_win_rate}")
    
    return None, test_confidence, test_win_rate
```

ğŸ¯ ç«‹å³éƒ¨ç½²è¿™ä¸ªç²¾å‡†è¯Šæ–­

è¿™ä¸ªè¯Šæ–­ä¼šæ˜ç¡®å‘Šè¯‰æˆ‘ä»¬ï¼š

å¦‚æœçœ‹åˆ°ï¼š

```
âŒ é˜¶æ®µ1å¤±è´¥: æ•°æ®éªŒè¯ä¸é€šè¿‡
```

â†’ é—®é¢˜ï¼šæ•°æ®éªŒè¯è¿‡äºä¸¥æ ¼

å¦‚æœçœ‹åˆ°ï¼š

```
âŒ é˜¶æ®µ2å¤±è´¥: æ— æ³•ç¡®å®šæ–¹å‘  
```

â†’ é—®é¢˜ï¼šæ–¹å‘åˆ¤æ–­é€»è¾‘ç¼ºé™·

å¦‚æœçœ‹åˆ°ï¼š

```
âŒ é˜¶æ®µ3å¤±è´¥: FeatureEngineä¸ºNone
âŒ é˜¶æ®µ3å¤±è´¥: ICTç‰¹å¾ä¸ºç©ºå­—å…¸
âŒ é˜¶æ®µ3å¤±è´¥: ç‰¹å¾è®¡ç®—å¼‚å¸¸
```

â†’ é—®é¢˜ï¼šç‰¹å¾è®¡ç®—å¤±è´¥

å¦‚æœçœ‹åˆ°ï¼š

```
ğŸ‰ æ‰€æœ‰é˜¶æ®µé€šè¿‡ï¼Œä½†ç³»ç»Ÿä»ç„¶å¿«é€Ÿè¿”å›
```

â†’ é—®é¢˜ï¼šåœ¨åç»­çš„ä¿¡å¿ƒå€¼è®¡ç®—é€»è¾‘ä¸­

ğŸ“‹ å¿«é€Ÿä¿®å¤æ–¹æ¡ˆ

æ ¹æ®è¯Šæ–­ç»“æœï¼Œç«‹å³å®æ–½å¯¹åº”çš„ä¿®å¤ï¼š

ä¿®å¤æ–¹æ¡ˆAï¼šå¦‚æœæ•°æ®éªŒè¯å¤±è´¥

```python
def _validate_klines_data(self, multi_tf_data):
    """æ”¾å®½çš„æ•°æ®éªŒè¯"""
    required_tfs = ['1h', '15m', '5m']
    for tf in required_tfs:
        if tf not in multi_tf_data:
            return False
        df = multi_tf_data[tf]
        if df is None or len(df) < 10:  # ä»50é™ä½åˆ°10
            return False
        # åªæ£€æŸ¥æœ€åŸºæœ¬åˆ—
        basic_cols = ['open', 'high', 'low', 'close']
        if not all(col in df.columns for col in basic_cols):
            return False
    return True
```

ä¿®å¤æ–¹æ¡ˆBï¼šå¦‚æœæ–¹å‘åˆ¤æ–­å¤±è´¥

```python
def _determine_signal_direction(self, h1_data, m15_data, m5_data):
    """ç®€åŒ–çš„æ–¹å‘åˆ¤æ–­"""
    # å¼ºåˆ¶è¿”å›ä¸€ä¸ªæ–¹å‘è¿›è¡Œæµ‹è¯•
    return "LONG"  # æˆ– "SHORT"
```

ä¿®å¤æ–¹æ¡ˆCï¼šå¦‚æœç‰¹å¾è®¡ç®—å¤±è´¥

```python
# ä¸´æ—¶åˆ‡æ¢åˆ°ä¼ ç»Ÿæ¨¡å¼
self.use_pure_ict = False
```

ğŸš€ ç«‹å³è¡ŒåŠ¨

è¯·ç«‹å³éƒ¨ç½²è¿™ä¸ªä¸‰é˜¶æ®µç²¾å‡†è¯Šæ–­ï¼æˆ‘ä»¬å°†èƒ½åœ¨ä¸‹ä¸€ä¸ªæ‰«æå‘¨æœŸä¸­æ˜ç¡®çœ‹åˆ°ï¼š

1. å“ªä¸ªé˜¶æ®µå¤±è´¥
2. å…·ä½“å¤±è´¥åŸå› 
3. éœ€è¦å®æ–½çš„ç²¾ç¡®ä¿®å¤

è¿™æ ·æˆ‘ä»¬å°±èƒ½å½»åº•è§£å†³å¿«é€Ÿè·³è¿‡é—®é¢˜ï¼