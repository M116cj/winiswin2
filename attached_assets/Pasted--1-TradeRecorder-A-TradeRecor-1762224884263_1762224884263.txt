æˆ‘å®Œå…¨æ˜Žç™½äº†ï¼é€™æ˜¯å…©å€‹æž¶æ§‹è¡çª + ç’°å¢ƒé™åˆ¶çš„è‡´å‘½å•é¡Œã€‚è®“æˆ‘æä¾›ç²¾ç¢ºçš„ä¿®å¾©æ–¹æ¡ˆï¼š

ðŸ”§ ç²¾ç¢ºä¿®å¾©æ–¹æ¡ˆ

å•é¡Œ1: TradeRecorder æž¶æ§‹è¡çªä¿®å¾©

æ–¹æ¡ˆA: ä¿®å¾©ç¾æœ‰ TradeRecorderï¼ˆæŽ¨è–¦ï¼‰

```python
# src/managers/trade_recorder.py - åœ¨ç¾æœ‰é¡žä¸­æ·»åŠ ç¼ºå¤±æ–¹æ³•

class TradeRecorder:
    def __init__(self, model_scorer=None, model_initializer=None):
        self.model_scorer = model_scorer
        self.model_initializer = model_initializer
        self.trade_data_file = "trade_data.json"
        self._ensure_data_file()
    
    # === æ–°å¢žé—œéµæ–¹æ³• ===
    async def get_trade_count(self, timeframe: str = '24h') -> int:
        """ç²å–äº¤æ˜“æ•¸é‡ - å…¼å®¹ç¾æœ‰JSONæž¶æ§‹"""
        try:
            data = self._load_trade_data()
            
            if timeframe == '24h':
                # è¨ˆç®—éŽåŽ»24å°æ™‚çš„äº¤æ˜“æ•¸é‡
                twenty_four_hours_ago = datetime.now().timestamp() - 24 * 3600
                count = sum(1 for trade in data.get('trades', [])
                          if trade.get('entry_time', 0) >= twenty_four_hours_ago)
            else:
                # ç¸½äº¤æ˜“æ•¸é‡
                count = len(data.get('trades', []))
            
            logger.info(f"ðŸ“Š TradeRecorder.get_trade_count({timeframe}): {count}")
            return count
            
        except Exception as e:
            logger.error(f"âŒ get_trade_count å¤±æ•—: {e}")
            return 0
    
    async def record_trade(self, trade_data: Dict) -> bool:
        """è¨˜éŒ„äº¤æ˜“ - å…¼å®¹æ–¹æ³•"""
        try:
            data = self._load_trade_data()
            
            # è½‰æ›æ ¼å¼å…¼å®¹
            trade_record = {
                'symbol': trade_data.get('symbol'),
                'direction': trade_data.get('direction'),
                'entry_price': trade_data.get('entry_price'),
                'position_size': trade_data.get('position_size'),
                'entry_time': datetime.now().timestamp(),
                'confidence': trade_data.get('confidence', 0),
                'win_probability': trade_data.get('win_probability', 0),
                'status': 'OPEN'
            }
            
            data['trades'].append(trade_record)
            self._save_trade_data(data)
            
            logger.info(f"âœ… TradeRecorder.record_trade: {trade_data.get('symbol')}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ record_trade å¤±æ•—: {e}")
            return False
    
    async def get_recent_performance(self, hours: int = 24) -> Dict:
        """ç²å–è¿‘æœŸè¡¨ç¾ - å…¼å®¹æ–¹æ³•"""
        try:
            data = self._load_trade_data()
            since_time = datetime.now().timestamp() - hours * 3600
            
            recent_trades = [
                trade for trade in data.get('trades', [])
                if trade.get('entry_time', 0) >= since_time
            ]
            
            return {
                'total_trades': len(recent_trades),
                'winning_trades': 0,  # ç°¡åŒ–ç‰ˆæœ¬
                'losing_trades': 0,
                'win_rate': 0,
                'avg_pnl': 0,
                'total_pnl': 0
            }
            
        except Exception as e:
            logger.error(f"âŒ get_recent_performance å¤±æ•—: {e}")
            return {
                'total_trades': 0,
                'winning_trades': 0,
                'losing_trades': 0,
                'win_rate': 0,
                'avg_pnl': 0,
                'total_pnl': 0
            }
    
    # === ä¿æŒç¾æœ‰æ–¹æ³• ===
    def record_entry(self, symbol, direction, entry_price, quantity, strategy_info=None):
        # ä¿æŒåŽŸæœ‰é‚è¼¯
        pass
        
    def record_exit(self, symbol, exit_price, pnl, exit_reason=None):
        # ä¿æŒåŽŸæœ‰é‚è¼¯
        pass
    
    def _ensure_data_file(self):
        """ç¢ºä¿æ•¸æ“šæ–‡ä»¶å­˜åœ¨"""
        try:
            if not os.path.exists(self.trade_data_file):
                initial_data = {
                    'trades': [],
                    'performance': {},
                    'created_at': datetime.now().isoformat()
                }
                with open(self.trade_data_file, 'w') as f:
                    json.dump(initial_data, f, indent=2)
        except Exception as e:
            logger.error(f"âŒ ç¢ºä¿æ•¸æ“šæ–‡ä»¶å¤±æ•—: {e}")
    
    def _load_trade_data(self) -> Dict:
        """åŠ è¼‰äº¤æ˜“æ•¸æ“š"""
        try:
            if os.path.exists(self.trade_data_file):
                with open(self.trade_data_file, 'r') as f:
                    return json.load(f)
            return {'trades': []}
        except Exception as e:
            logger.error(f"âŒ åŠ è¼‰äº¤æ˜“æ•¸æ“šå¤±æ•—: {e}")
            return {'trades': []}
    
    def _save_trade_data(self, data: Dict):
        """ä¿å­˜äº¤æ˜“æ•¸æ“š"""
        try:
            with open(self.trade_data_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"âŒ ä¿å­˜äº¤æ˜“æ•¸æ“šå¤±æ•—: {e}")
```

æ–¹æ¡ˆB: ç·Šæ€¥ç¹žéŽæ–¹æ¡ˆ

```python
# åœ¨ src/strategies/self_learning_trader.py ä¸­æ·»åŠ ç·Šæ€¥ä¿®å¾©

class SelfLearningTrader:
    def __init__(self, config, data_fetcher, signal_generator):
        self.config = config
        self.data_fetcher = data_fetcher
        self.signal_generator = signal_generator
        
        # ç·Šæ€¥ä¿®å¾©ï¼šç¢ºä¿ trade_recorder æœ‰å¿…éœ€æ–¹æ³•
        self._patch_trade_recorder()
    
    def _patch_trade_recorder(self):
        """ä¿®è£œ TradeRecorder ç¼ºå¤±æ–¹æ³•"""
        if not hasattr(self.trade_recorder, 'get_trade_count'):
            logger.warning("ðŸ”„ æª¢æ¸¬åˆ° TradeRecorder ç¼ºå¤±æ–¹æ³•ï¼Œæ‡‰ç”¨ç·Šæ€¥ä¿®è£œ")
            
            # æ·»åŠ ç¼ºå¤±çš„æ–¹æ³•
            self.trade_recorder.get_trade_count = self._emergency_get_trade_count
            self.trade_recorder.record_trade = self._emergency_record_trade
            self.trade_recorder.get_recent_performance = self._emergency_get_performance
    
    async def _emergency_get_trade_count(self, timeframe: str = '24h') -> int:
        """ç·Šæ€¥äº¤æ˜“æ•¸é‡ç²å–"""
        logger.info("ðŸ”„ ä½¿ç”¨ç·Šæ€¥ get_trade_countï¼Œè¿”å›ž0")
        return 0  # å‡è¨­æ²’æœ‰æ­·å²äº¤æ˜“
    
    async def _emergency_record_trade(self, trade_data: Dict) -> bool:
        """ç·Šæ€¥äº¤æ˜“è¨˜éŒ„"""
        logger.info(f"ðŸ”„ ä½¿ç”¨ç·Šæ€¥ record_trade: {trade_data.get('symbol')}")
        return True  # ç¸½æ˜¯æˆåŠŸ
    
    async def _emergency_get_performance(self, hours: int = 24) -> Dict:
        """ç·Šæ€¥æ€§èƒ½ç²å–"""
        return {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'win_rate': 0,
            'avg_pnl': 0,
            'total_pnl': 0
        }
```

å•é¡Œ2: HTTP 451 åœ°ç†ä½ç½®é™åˆ¶è§£æ±ºæ–¹æ¡ˆ

æ–¹æ¡ˆA: ä½¿ç”¨ä»£ç†æœå‹™å™¨

```python
# src/core/proxy_data_fetcher.py

import aiohttp
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)

class ProxyDataFetcher:
    """ä½¿ç”¨ä»£ç†ç¹žéŽåœ°ç†ä½ç½®é™åˆ¶"""
    
    def __init__(self, config):
        self.config = config
        self.proxy_urls = [
            "https://api.allorigins.win/raw?url=",  # CORS ä»£ç†
            "https://cors-anywhere.herokuapp.com/",  # CORS ä»£ç†
            "https://api.codetabs.com/v1/proxy?quest=",  # å¦ä¸€å€‹ä»£ç†
        ]
        self.current_proxy_index = 0
    
    async def get_binance_data_via_proxy(self, url: str) -> Optional[Dict]:
        """é€šéŽä»£ç†ç²å– Binance æ•¸æ“š"""
        for attempt in range(len(self.proxy_urls)):
            try:
                proxy_url = self.proxy_urls[self.current_proxy_index] + url
                
                async with aiohttp.ClientSession() as session:
                    async with session.get(proxy_url, timeout=10) as response:
                        if response.status == 200:
                            data = await response.json()
                            logger.info(f"âœ… é€šéŽä»£ç†ç²å–æ•¸æ“šæˆåŠŸ")
                            return data
                        else:
                            logger.warning(f"âš ï¸ ä»£ç† {self.current_proxy_index} å¤±æ•—: HTTP {response.status}")
                
                # åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ä»£ç†
                self.current_proxy_index = (self.current_proxy_index + 1) % len(self.proxy_urls)
                
            except Exception as e:
                logger.error(f"âŒ ä»£ç†è«‹æ±‚å¤±æ•—: {e}")
                self.current_proxy_index = (self.current_proxy_index + 1) % len(self.proxy_urls)
        
        logger.error("âŒ æ‰€æœ‰ä»£ç†éƒ½å¤±æ•—")
        return None
    
    async def get_klines_via_proxy(self, symbol: str, interval: str, limit: int = 100) -> Optional[Dict]:
        """é€šéŽä»£ç†ç²å–Kç·šæ•¸æ“š"""
        url = f"https://api.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={limit}"
        return await self.get_binance_data_via_proxy(url)
```

æ–¹æ¡ˆB: åˆ‡æ›åˆ°å…¶ä»–äº¤æ˜“æ‰€API

```python
# src/core/multi_exchange_data_fetcher.py

class MultiExchangeDataFetcher:
    """å¤šäº¤æ˜“æ‰€æ•¸æ“šç²å– - é¿å…å–®é»žæ•…éšœ"""
    
    def __init__(self, config):
        self.config = config
        self.exchanges = {
            'bybit': 'https://api.bybit.com',
            'okx': 'https://www.okx.com',
            'kucoin': 'https://api.kucoin.com',
            'gateio': 'https://api.gateio.ws',
        }
    
    async def get_klines_fallback(self, symbol: str, interval: str, limit: int = 100) -> Optional[Dict]:
        """å‚™ç”¨äº¤æ˜“æ‰€æ•¸æ“šç²å–"""
        # å˜—è©¦ Bybit
        try:
            url = f"https://api.bybit.com/v5/market/kline?category=spot&symbol={symbol}&interval={interval}&limit={limit}"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        if data['retCode'] == 0:
                            logger.info(f"âœ… é€šéŽ Bybit ç²å–æ•¸æ“šæˆåŠŸ: {symbol}")
                            return self._convert_bybit_to_binance_format(data)
        except Exception as e:
            logger.warning(f"âš ï¸ Bybit ç²å–å¤±æ•—: {e}")
        
        # å¯ä»¥ç¹¼çºŒå˜—è©¦å…¶ä»–äº¤æ˜“æ‰€...
        logger.error("âŒ æ‰€æœ‰äº¤æ˜“æ‰€éƒ½å¤±æ•—")
        return None
    
    def _convert_bybit_to_binance_format(self, bybit_data: Dict) -> Dict:
        """è½‰æ› Bybit æ•¸æ“šæ ¼å¼ç‚º Binance æ ¼å¼"""
        # å¯¦ç¾æ ¼å¼è½‰æ›é‚è¼¯
        return bybit_data
```

ç«‹å³éƒ¨ç½²ä¿®å¾©

```bash
#!/bin/bash
echo "ðŸš€ éƒ¨ç½²ç²¾ç¢ºä¿®å¾©æ–¹æ¡ˆ..."

# 1. ä¿®å¾© TradeRecorderï¼ˆæ–¹æ¡ˆAï¼‰
echo "ðŸ”§ ä¿®å¾© TradeRecorder ç¼ºå¤±æ–¹æ³•..."
cat >> src/managers/trade_recorder.py << 'EOF'

# === æ–°å¢žå…¼å®¹æ–¹æ³• ===
async def get_trade_count(self, timeframe: str = '24h') -> int:
    """ç²å–äº¤æ˜“æ•¸é‡ - å…¼å®¹ç¾æœ‰JSONæž¶æ§‹"""
    try:
        data = self._load_trade_data()
        
        if timeframe == '24h':
            twenty_four_hours_ago = datetime.now().timestamp() - 24 * 3600
            count = sum(1 for trade in data.get('trades', [])
                      if trade.get('entry_time', 0) >= twenty_four_hours_ago)
        else:
            count = len(data.get('trades', []))
        
        logger.info(f"ðŸ“Š TradeRecorder.get_trade_count({timeframe}): {count}")
        return count
        
    except Exception as e:
        logger.error(f"âŒ get_trade_count å¤±æ•—: {e}")
        return 0

async def record_trade(self, trade_data: Dict) -> bool:
    """è¨˜éŒ„äº¤æ˜“ - å…¼å®¹æ–¹æ³•"""
    try:
        data = self._load_trade_data()
        trade_record = {
            'symbol': trade_data.get('symbol'),
            'direction': trade_data.get('direction'),
            'entry_price': trade_data.get('entry_price'),
            'position_size': trade_data.get('position_size'),
            'entry_time': datetime.now().timestamp(),
            'confidence': trade_data.get('confidence', 0),
            'win_probability': trade_data.get('win_probability', 0),
            'status': 'OPEN'
        }
        data['trades'].append(trade_record)
        self._save_trade_data(data)
        logger.info(f"âœ… TradeRecorder.record_trade: {trade_data.get('symbol')}")
        return True
    except Exception as e:
        logger.error(f"âŒ record_trade å¤±æ•—: {e}")
        return False
EOF

# 2. æ·»åŠ ä»£ç†æ•¸æ“šç²å–å™¨
echo "ðŸ”§ å‰µå»ºä»£ç†æ•¸æ“šç²å–å™¨..."
mkdir -p src/core/
cat > src/core/proxy_data_fetcher.py << 'EOF'
# [ä¸Šé¢çš„ ProxyDataFetcher ä»£ç¢¼]
EOF

# 3. éƒ¨ç½²ä¿®å¾©
git add src/managers/trade_recorder.py src/core/proxy_data_fetcher.py
git commit -m "ç·Šæ€¥ä¿®å¾©: TradeRecorderæ–¹æ³•ç¼ºå¤± + HTTP451åœ°ç†ä½ç½®é™åˆ¶"
git push origin main

echo "âœ… ä¿®å¾©éƒ¨ç½²å®Œæˆï¼"
echo "ðŸ“Š ç›£æŽ§æ—¥èªŒ: railway logs --follow | grep -E 'TradeRecorder|ä»£ç†|get_trade_count'"
```

ðŸŽ¯ ä¿®å¾©æ•ˆæžœ

ä¿®å¾©å¾Œæ‡‰è©²çœ‹åˆ°ï¼š

```
âœ… TradeRecorder.get_trade_count(24h): 0
âœ… TradeRecorder.record_trade: BTCUSDT
âœ… é€šéŽä»£ç†ç²å–æ•¸æ“šæˆåŠŸ
ðŸš€ äº¤æ˜“é€±æœŸåŸ·è¡ŒæˆåŠŸ: 2ç­†äº¤æ˜“
```

å¦‚æžœä»£ç†ä¹Ÿå¤±æ•—ï¼š

```
âš ï¸ ä»£ç† 0 å¤±æ•—: HTTP 451
ðŸ”„ åˆ‡æ›åˆ°ä»£ç† 1
âœ… é€šéŽä»£ç†ç²å–æ•¸æ“šæˆåŠŸ
```

é€™å€‹ç²¾ç¢ºä¿®å¾©æ–¹æ¡ˆç›´æŽ¥é‡å°å…©å€‹æ ¹æœ¬å•é¡Œï¼Œç¢ºä¿ç³»çµ±èƒ½å¤ æ­£å¸¸é‹è¡Œï¼