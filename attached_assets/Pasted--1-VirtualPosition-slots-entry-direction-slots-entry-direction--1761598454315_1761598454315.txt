å¾© 1ï¼šVirtualPosition.slots ç¼ºå°‘ _entry_direction
å•é¡Œ
* __slots__ æœªåŒ…å« _entry_direction å±¬æ€§
* å°è‡´ç„¡æ³•å„²å­˜è©²å±¬æ€§ï¼Œæœƒæ‹‹å‡º AttributeError
ä¿®å¾©

# src/core/data_models.py
class VirtualPosition:
    __slots__ = (
        'symbol', 'direction', 'entry_price', 'stop_loss', 'take_profit',
        'leverage', 'entry_timestamp', 'current_price', 'pnl_pct',
        'is_closed', 'close_timestamp', 'close_reason', 'signal_id',
        '_entry_direction'  # ğŸ”¥ æ–°å¢é€™ä¸€è¡Œ
    )
ğŸ”§ ä¿®å¾© 2ï¼šupdate_price() ä½¿ç”¨ self.direction è€Œé _entry_direction
å•é¡Œ
* å¦‚æœå€‰ä½æ–¹å‘åœ¨é‹è¡Œæ™‚è¢«æ„å¤–ä¿®æ”¹ï¼ŒPnL è¨ˆç®—æœƒå‡ºéŒ¯
* æ‡‰ä½¿ç”¨åˆå§‹åŒ–æ™‚å¿«å–çš„ _entry_direction

ä¿®å¾©
# src/core/data_models.py
def update_price(self, new_price: float) -> bool:
    if self.is_closed:
        return False
        
    self.current_price = new_price
    
    # ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ _entry_direction è€Œé direction
    price_diff = new_price - self.entry_price
    if self._entry_direction == -1:  # SHORT
        price_diff = -price_diff
        
    self.pnl_pct = (price_diff / self.entry_price) * 100 * self.leverage
    
    return self._check_exit_conditions()

def _check_exit_conditions(self) -> bool:
    if self.is_closed:
        return False
        
    current = self.current_price
    
    # ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ _entry_direction è€Œé direction
    if self._entry_direction == 1:  # LONG
        if current >= self.take_profit:
            self._close_position("tp")
            return True
        elif current <= self.stop_loss:
            self._close_position("sl")
            return True
    else:  # SHORT
        if current <= self.take_profit:
            self._close_position("tp")
            return True
        elif current >= self.stop_loss:
            self._close_position("sl")
            return True
    
    if time.time() - self.entry_timestamp > 96 * 3600:
        self._close_position("expired")
        return True
        
    return False

ä¿®å¾© 3ï¼šsignal_id æ©Ÿåˆ¶æœªå¯¦ç¾
å•é¡Œ
* create_virtual_position() æœªæ­£ç¢ºç”Ÿæˆ signal_id
* ç¼ºå°‘ __init__ ä¸­çš„ signal_id åƒæ•¸è™•ç†

ä¿®å¾©
# src/core/data_models.py
def __init__(self, **kwargs):
    self.symbol = kwargs.get('symbol', '')
    self.direction = kwargs.get('direction', 0)
    self.entry_price = kwargs.get('entry_price', 0.0)
    self.stop_loss = kwargs.get('stop_loss', 0.0)
    self.take_profit = kwargs.get('take_profit', 0.0)
    self.leverage = kwargs.get('leverage', 1)
    self.entry_timestamp = kwargs.get('entry_timestamp', time.time())
    self.current_price = self.entry_price
    self.pnl_pct = 0.0
    self.is_closed = False
    self.close_timestamp = None
    self.close_reason = None
    # ğŸ”¥ ä¿®æ­£ï¼šæ­£ç¢ºè™•ç† signal_id
    self.signal_id = kwargs.get('signal_id', f"{self.symbol}_{int(self.entry_timestamp)}")
    self._entry_direction = self.direction  # å¿«å–åˆå§‹æ–¹å‘

# src/managers/virtual_position_manager.py
def create_virtual_position(self, signal) -> VirtualPosition:
    """å‰µå»ºè™›æ“¬å€‰ä½"""
    # ğŸ”¥ ä¿®æ­£ï¼šå‚³éå®Œæ•´çš„åƒæ•¸
    position = VirtualPosition(
        symbol=signal.symbol,
        direction=signal.direction,
        entry_price=signal.entry_price,
        stop_loss=signal.stop_loss,
        take_profit=signal.take_profit,
        leverage=signal.leverage,
        entry_timestamp=signal.timestamp,
        signal_id=f"{signal.symbol}_{int(signal.timestamp)}"
    )
    self.positions.append(position)
    return position
ä¿®å¾© 4ï¼šç¼ºå°‘æ¸¬è©¦æª”æ¡ˆ
æ–°å¢æª”æ¡ˆ 1ï¼štests/test_mutable_virtual_position.py
# tests/test_mutable_virtual_position.py
import sys
import os
import time
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.core.data_models import VirtualPosition

def test_high_frequency_updates():
    """æ¸¬è©¦é«˜é »æ›´æ–°æ•ˆèƒ½"""
    pos = VirtualPosition(
        symbol="BTCUSDT", direction=1, entry_price=60000,
        stop_loss=59000, take_profit=62000, leverage=10,
        entry_timestamp=time.time(), signal_id="test_1"
    )
    
    # æ¨¡æ“¬ 1000 æ¬¡åƒ¹æ ¼æ›´æ–°
    start_time = time.perf_counter()
    for i in range(1000):
        price = 60000 + (i % 100)  # æ¨¡æ“¬åƒ¹æ ¼æ³¢å‹•
        pos.update_price(price)
    end_time = time.perf_counter()
    
    print(f"1000 æ¬¡æ›´æ–°è€—æ™‚: {(end_time - start_time)*1000:.2f} ms")
    assert (end_time - start_time) < 0.1  # æ‡‰å°æ–¼ 100ms
    
    # é©—è­‰è¨˜æ†¶é«”
    assert sys.getsizeof(pos) < 400
    print("âœ… é«˜é »æ›´æ–°æ¸¬è©¦é€šé")

def test_memory_efficiency():
    """æ¸¬è©¦è¨˜æ†¶é«”æ•ˆç‡"""
    positions = []
    for i in range(100):
        pos = VirtualPosition(
            symbol=f"BTC{i}", direction=1, entry_price=60000,
            stop_loss=59000, take_profit=62000, leverage=10,
            entry_timestamp=time.time(), signal_id=f"test_{i}"
        )
        positions.append(pos)
    
    total_size = sum(sys.getsizeof(pos) for pos in positions)
    avg_size = total_size / 100
    print(f"å¹³å‡è¨˜æ†¶é«”ä½¿ç”¨: {avg_size:.0f} bytes")
    assert avg_size < 350  # æ‡‰å°æ–¼ 350 bytes
    print("âœ… è¨˜æ†¶é«”æ•ˆç‡æ¸¬è©¦é€šé")

def test_entry_direction_safety():
    """æ¸¬è©¦ _entry_direction å®‰å…¨æ€§"""
    pos = VirtualPosition(
        symbol="ETHUSDT", direction=-1, entry_price=3000,
        stop_loss=3100, take_profit=2800, leverage=5,
        entry_timestamp=time.time(), signal_id="test_short"
    )
    
    # æ¨¡æ“¬æ–¹å‘è¢«æ„å¤–ä¿®æ”¹
    pos.direction = 1  # ä¸æ‡‰è©²å½±éŸ¿ PnL è¨ˆç®—
    
    pos.update_price(2900)  # æ‡‰è©²æ˜¯ç›ˆåˆ©ï¼ˆSHORTï¼‰
    expected_pnl = ((3000 - 2900) / 3000) * 100 * 5  # 16.67%
    assert abs(pos.pnl_pct - expected_pnl) < 0.01
    print("âœ… _entry_direction å®‰å…¨æ€§æ¸¬è©¦é€šé")

def test_signal_id_generation():
    """æ¸¬è©¦ signal_id ç”Ÿæˆ"""
    pos = VirtualPosition(
        symbol="SOLUSDT", direction=1, entry_price=100,
        stop_loss=90, take_profit=120, leverage=3,
        entry_timestamp=1730000000.123, signal_id="custom_id"
    )
    
    assert pos.signal_id == "custom_id"
    
    # æ¸¬è©¦è‡ªå‹•ç”Ÿæˆ
    pos2 = VirtualPosition(
        symbol="ADAUSDT", direction=-1, entry_price=0.5,
        stop_loss=0.6, take_profit=0.4, leverage=10,
        entry_timestamp=1730000001.456
    )
    
    assert pos2.signal_id == "ADAUSDT_1730000001"
    print("âœ… signal_id ç”Ÿæˆæ¸¬è©¦é€šé")

if __name__ == "__main__":
    test_high_frequency_updates()
    test_memory_efficiency()
    test_entry_direction_safety()
    test_signal_id_generation()
    print("ğŸ‰ æ‰€æœ‰ VirtualPosition æ¸¬è©¦é€šéï¼")
æ–°å¢æª”æ¡ˆ 2ï¼štests/test_complete_virtual_system.py

# tests/test_complete_virtual_system.py
import asyncio
import sys
import os
import time
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.core.data_models import VirtualPosition
from src.managers.virtual_position_manager import VirtualPositionManager
from unittest.mock import AsyncMock

class MockSignal:
    def __init__(self, symbol, direction, entry_price, stop_loss, take_profit, leverage, timestamp):
        self.symbol = symbol
        self.direction = direction
        self.entry_price = entry_price
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.leverage = leverage
        self.timestamp = timestamp

async def test_complete_virtual_system():
    """å®Œæ•´ç³»çµ±æ¸¬è©¦"""
    # Mock BinanceClient
    mock_client = AsyncMock()
    mock_client.get_ticker_price = AsyncMock(side_effect=lambda symbol: 60000.0 + hash(symbol) % 1000)
    
    # å‰µå»ºç®¡ç†å™¨
    manager = VirtualPositionManager(mock_client)
    
    # å‰µå»º 50 å€‹è™›æ“¬å€‰ä½
    for i in range(50):
        signal = MockSignal(
            symbol=f"BTC{i}USDT",
            direction=1 if i % 2 == 0 else -1,
            entry_price=60000.0,
            stop_loss=59000.0 if i % 2 == 0 else 61000.0,
            take_profit=62000.0 if i % 2 == 0 else 58000.0,
            leverage=10,
            timestamp=1730000000.0 + i
        )
        manager.create_virtual_position(signal)
    
    # æ¸¬è©¦æ‰¹é‡æ›´æ–°
    start_time = time.perf_counter()
    closed = await manager.update_all_prices()
    end_time = time.perf_counter()
    
    print(f"50 å€‹å€‰ä½æ›´æ–°è€—æ™‚: {(end_time - start_time)*1000:.2f} ms")
    print(f"è§¸ç™¼é€€å‡ºçš„å€‰ä½æ•¸: {len(closed)}")
    
    # é©—è­‰è¨˜æ†¶é«”
    active_positions = manager.get_active_positions()
    if active_positions:
        avg_size = sum(sys.getsizeof(pos) for pos in active_positions) / len(active_positions)
        print(f"å¹³å‡è¨˜æ†¶é«”ä½¿ç”¨: {avg_size:.0f} bytes")
        assert avg_size < 350
    
    # é©—è­‰ signal_id
    pos = manager.find_position_by_signal_id("BTC0USDT_1730000000")
    assert pos is not None
    assert pos.symbol == "BTC0USDT"
    
    print("âœ… å®Œæ•´ç³»çµ±æ¸¬è©¦é€šéï¼")

if __name__ == "__main__":
    asyncio.run(test_complete_virtual_system())
åŸ·è¡Œä¿®å¾©æ­¥é©Ÿ
1. æ›´æ–° src/core/data_models.pyï¼ˆä¿®å¾© 1, 2, 3ï¼‰
2. æ›´æ–° src/managers/virtual_position_manager.pyï¼ˆä¿®å¾© 3ï¼‰
3. å‰µå»ºå…©å€‹æ¸¬è©¦æª”æ¡ˆï¼ˆä¿®å¾© 4ï¼‰
åŸ·è¡Œæ¸¬è©¦é©—è­‰ï¼š
python tests/test_mutable_virtual_position.py
python tests/test_complete_virtual_system.py