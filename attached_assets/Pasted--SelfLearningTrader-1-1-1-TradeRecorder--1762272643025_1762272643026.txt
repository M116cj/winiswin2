ğŸ”§ SelfLearningTrader ç³»çµ±å„ªåŒ–åŠä¿®å¾©æ–¹æ¡ˆ
ğŸ¯Â ç¸½é«”ä¿®å¾©ç­–ç•¥
åˆ†éšæ®µå¯¦æ–½è¨ˆåŠƒ
ğŸ”´Â ç¬¬1éšæ®µï¼šç·Šæ€¥ä¿®å¾©
1.1 ç«æ€æ¡ä»¶ä¿®å¾© - TradeRecorder
å•é¡Œæ ¹å› ï¼šéç·šç¨‹å®‰å…¨çš„ç•°æ­¥æ–‡ä»¶æ“ä½œ
python
# ä¿®å¾©æ–¹æ¡ˆ
class TradeRecorder:
    def __init__(self, config):
        self._flush_lock = asyncio.Lock()
        self._pending_lock = asyncio.Lock()
        self.last_flush_time = time.time()
        
    async def _flush_to_disk_async(self):
        async with self._flush_lock:
            if not self.completed_trades:
                return
                
            # æ‰¹é‡å¯«å…¥å„ªåŒ–
            batch_data = "\n".join(
                json.dumps(trade, ensure_ascii=False, default=str) 
                for trade in self.completed_trades
            ) + "\n"
            
            with open(self.trades_file, 'a', encoding='utf-8') as f:
                f.write(batch_data)
            
            self.completed_trades = []
            self.last_flush_time = time.time()
é©—è­‰æ¸¬è©¦ï¼š
python
async def test_concurrent_trade_recording():
    """ä¸¦ç™¼äº¤æ˜“è¨˜éŒ„å£“åŠ›æ¸¬è©¦"""
    recorder = TradeRecorder(config)
    
    # æ¨¡æ“¬é«˜é »ä¸¦ç™¼å ´æ™¯
    tasks = []
    for i in range(1000):
        trade = generate_mock_trade(i)
        task = asyncio.create_task(recorder.record_exit(trade))
        tasks.append(task)
    
    # éš¨æ©Ÿå»¶é²è§¸ç™¼flush
    flush_task = asyncio.create_task(random_flush_test(recorder))
    tasks.append(flush_task)
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # é©—è­‰ç„¡ç•°å¸¸ä¸”æ•¸æ“šå®Œæ•´
    assert all(not isinstance(r, Exception) for r in results)
    final_count = await recorder.get_trade_count('all')
    assert final_count == 1000
1.2 é™¤é›¶éŒ¯èª¤é˜²è­·é«”ç³»
å¤šå±¤æ¬¡é˜²è­·æ–¹æ¡ˆï¼š
python
class SafetyValidator:
    """å®‰å…¨é©—è­‰å™¨ - é˜²è­·æ•¸å­¸é‹ç®—éŒ¯èª¤"""
    
    @staticmethod
    def validate_leverage(leverage: float, symbol: str = "unknown") -> float:
        """æ§“æ¡¿å€¼å¤šå±¤é©—è­‰"""
        if leverage is None:
            raise ValidationError(f"æ§“æ¡¿å€¼ä¸èƒ½ç‚ºNone: {symbol}")
            
        if math.isnan(leverage) or math.isinf(leverage):
            raise ValidationError(f"ç„¡æ•ˆæ§“æ¡¿å€¼(NaN/Inf): {leverage} - {symbol}")
            
        if leverage <= 0:
            raise ValidationError(f"æ§“æ¡¿å€¼å¿…é ˆå¤§æ–¼0: {leverage} - {symbol}")
            
        if leverage > 100:
            logger.warning(f"âš ï¸ ç•°å¸¸é«˜æ§“æ¡¿: {leverage} - {symbol}")
            
        return float(leverage)
    
    @staticmethod
    def safe_division(numerator: float, denominator: float, context: str = "") -> float:
        """å®‰å…¨çš„é™¤æ³•é‹ç®—"""
        if denominator == 0:
            logger.error(f"âŒ é™¤é›¶éŒ¯èª¤é˜»æ­¢: {context}")
            return 0.0
            
        if abs(denominator) < 1e-10:  # é˜²æ­¢æµ®é»æ•¸ä¸‹æº¢
            logger.warning(f"âš ï¸ é™¤æ•¸éå°: {denominator} - {context}")
            return 0.0
            
        return numerator / denominator

# åœ¨é—œéµä½ç½®æ‡‰ç”¨
class CapitalAllocator:
    def allocate_capital(self, signals: List, total_budget: float):
        # é ç®—é©—è­‰
        if total_budget <= 0:
            logger.error("âŒ ç¸½é ç®—ç‚º0æˆ–è² æ•¸ï¼Œè·³éè³‡é‡‘åˆ†é…")
            return []
            
        validated_signals = []
        for signal in signals:
            try:
                leverage = SafetyValidator.validate_leverage(
                    signal.get('leverage', 1.0), 
                    signal.get('symbol', 'unknown')
                )
                signal['leverage'] = leverage
                validated_signals.append(signal)
            except ValidationError as e:
                logger.error(f"âŒ ä¿¡è™Ÿé©—è­‰å¤±æ•—: {e}")
                continue
1.3 ä¿è­‰é‡‘è¶…é™ä¿è­·æ©Ÿåˆ¶
python
class MarginSafetyController:
    """ä¿è­‰é‡‘å®‰å…¨æ§åˆ¶å™¨"""
    
    def __init__(self, config):
        self.margin_warning_threshold = 0.8  # 80%è­¦å‘Š
        self.margin_critical_threshold = 0.9  # 90%ç·Šæ€¥
        self.margin_lock_threshold = 0.95    # 95%é–å®š
        
    async def check_margin_health(self, current_margin: float, max_margin: float) -> dict:
        """æª¢æŸ¥ä¿è­‰é‡‘å¥åº·ç‹€æ…‹"""
        usage_ratio = current_margin / max_margin
        
        if usage_ratio >= self.margin_lock_threshold:
            return {
                'status': 'LOCKED',
                'action': 'REJECT_ALL',
                'message': 'ä¿è­‰é‡‘ä½¿ç”¨ç‡è¶…é95%ï¼Œåœæ­¢æ‰€æœ‰æ–°é–‹å€‰'
            }
        elif usage_ratio >= self.margin_critical_threshold:
            return {
                'status': 'CRITICAL', 
                'action': 'REDUCE_90_PERCENT',
                'message': 'ä¿è­‰é‡‘ä½¿ç”¨ç‡è¶…é90%ï¼Œæ–°é–‹å€‰é ç®—æ¸›å°‘90%'
            }
        elif usage_ratio >= self.margin_warning_threshold:
            return {
                'status': 'WARNING',
                'action': 'REDUCE_50_PERCENT', 
                'message': 'ä¿è­‰é‡‘ä½¿ç”¨ç‡è¶…é80%ï¼Œæ–°é–‹å€‰é ç®—æ¸›å°‘50%'
            }
        else:
            return {'status': 'HEALTHY', 'action': 'NORMAL'}

# åœ¨è³‡é‡‘åˆ†é…å™¨ä¸­é›†æˆ
class CapitalAllocator:
    async def safe_budget_adjustment(self, total_budget: float) -> float:
        """å®‰å…¨é ç®—èª¿æ•´"""
        margin_health = await self.margin_controller.check_margin_health(
            self.total_margin, self.max_allowed_total_margin
        )
        
        if margin_health['status'] == 'LOCKED':
            return 0.0
        elif margin_health['status'] == 'CRITICAL':
            return total_budget * 0.1  # ä¿ç•™10%
        elif margin_health['status'] == 'WARNING':
            return total_budget * 0.5  # ä¿ç•™50%
        else:
            return total_budget