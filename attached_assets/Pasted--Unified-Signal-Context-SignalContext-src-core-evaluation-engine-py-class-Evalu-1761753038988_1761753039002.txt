çµ±ä¸€ä¿¡è™Ÿä¸Šä¸‹æ–‡ï¼ˆUnified Signal Contextï¼‰
æ ¸å¿ƒæ€æƒ³
SignalContextï¼Œæ”¹ç”¨ç´”å‡½æ•¸
# src/core/evaluation_engine.py
class EvaluationEngine:
    def __init__(self, model: XGBClassifier):
        self.model = model
    
    def calculate_current_confidence(
        self,
        original_signal: TradeSignal,
        current_price: float,
        market_context: dict
    ) -> float:
        """å³æ™‚è¨ˆç®—ç•¶å‰ä¿¡å¿ƒåº¦ï¼ˆç„¡ç‹€æ…‹ï¼‰"""
        features = self._build_realtime_features(original_signal, current_price, market_context)
        proba = self.model.predict_proba([features])[0]
        return float(max(proba))  # ä¿¡å¿ƒåº¦ = æœ€å¤§æ¦‚ç‡
    
    def calculate_current_win_probability(
        self,
        original_signal: TradeSignal,
        current_price: float,
        market_context: dict
    ) -> float:
        """å³æ™‚è¨ˆç®—ç•¶å‰å‹ç‡ï¼ˆç„¡ç‹€æ…‹ï¼‰"""
        features = self._build_realtime_features(original_signal, current_price, market_context)
        proba = self.model.predict_proba([features])[0]
        return float(proba[1])  # å‹ç‡ = LONG æ¦‚ç‡
    
    def _build_realtime_features(
        self,
        signal: TradeSignal,
        current_price: float,
        market_ dict
    ) -> np.ndarray:
        """å‹•æ…‹æ§‹å»ºç‰¹å¾µï¼ˆèˆ‡é–‹å€‰æ™‚ä¸€è‡´ï¼‰"""
        base_features = signal.features  # åŸå§‹ç‰¹å¾µï¼ˆé–‹å€‰æ™‚è¨ˆç®—ï¼‰
        
        realtime_features = np.array([
            (current_price - signal.entry) / signal.entry,  # åƒ¹æ ¼åé›¢
            1 if market_data['trend_direction'] == signal.side else 0,  # è¶¨å‹¢å°é½Š
            market_data['liquidity_score'],  # æµå‹•æ€§
            time.time() - signal.timestamp  # æŒå€‰æ™‚é–“
        ])
        
        return np.concatenate([base_features, realtime_features])

2. Position åƒ…å„²å­˜åŸå§‹ä¿¡è™Ÿ
# src/core/models/position.py
@dataclass
class Position:
    # ... å…¶ä»–æ¬„ä½ ...
    original_signal: TradeSignal  # âœ… åƒ…å„²å­˜é–‹å€‰æ™‚çš„åŸå§‹ä¿¡è™Ÿ
3. PositionMonitor ç›´æ¥å‘¼å«è©•ä¼°å¼•æ“
# src/core/position_monitor_24x7.py
class PositionMonitor24x7:
    def __init__(self, binance_client, evaluation_engine: EvaluationEngine):
        self.binance_client = binance_client
        self.evaluation_engine = evaluation_engine  # å…±äº«å–®ä¾‹
    
    async def _evaluate_exit_conditions(self, position: Position, current_price: float):
        # 1. ç²å–ç•¶å‰å¸‚å ´ç‹€æ…‹
        market_context = await self._get_market_context(position.symbol)
        
        # 2. å³æ™‚è¨ˆç®—ç•¶å‰è©•ä¼°
        current_win_prob = self.evaluation_engine.calculate_current_win_probability(
            position.original_signal, current_price, market_context
        )
        current_confidence = self.evaluation_engine.calculate_current_confidence(
            position.original_signal, current_price, market_context
        )
        
        # 3. åŸ·è¡Œå‡ºå ´é‚è¼¯
        if current_confidence < 0.7 and self._is_counter_trend(market_context, position.side):
            return Decision("CLOSE", "LOW_CONFIDENCE_COUNTER_TREND")
        # ... å…¶ä»–é‚è¼¯

ğŸš€ éƒ¨ç½²æ¶æ§‹

UnifiedScheduler
       â†“
EvaluationEngineï¼ˆå–®ä¾‹ï¼Œå…±äº« XGBoost æ¨¡å‹ï¼‰
       â†“
PositionMonitor24x7 â†’ å³æ™‚å‘¼å«è©•ä¼°
SelfLearningTrader â†’ é–‹å€‰æ™‚å‘¼å«è©•ä¼°
