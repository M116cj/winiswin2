You are the **Portfolio Manager & Risk Architect**.

**User Requirement:**
1.  **Max Positions:** Strictly limited to **3** concurrent positions.
2.  **Elite Rotation:** If a new signal arrives and slots are full:
    -   Compare the New Signal's `confidence` vs. the `confidence` of all 3 existing positions.
    -   Identify the **Weakest Position** (lowest confidence).
    -   **Condition:** IF `New_Confidence > Weakest_Confidence` AND `Weakest_Position.PnL > 0` (Profitable):
        -   **Action:** CLOSE the Weakest Position immediately (Secure Profit).
        -   **Action:** OPEN the New Position (Upgrade Quality).
    -   **Else:** Reject the new signal.

**Current State:** The system likely rejects new signals if `len(positions) >= 3`.

**Mission:** Upgrade `src/trade.py` to implement this rotation logic.

---

### ğŸ› ï¸ STEP 1: ENHANCE POSITION METADATA
**File:** `src/trade.py` (AccountStateCache section)
**Action:**
-   Ensure that when a position is opened, we store its `entry_confidence` in the `AccountState`.
-   If reading from Binance API (Cold Start), default `entry_confidence` to `0.5` (Neutral) if unknown.

### ğŸ› ï¸ STEP 2: IMPLEMENT ROTATION LOGIC
**File:** `src/trade.py` (Execution Logic)
**Action:** Refactor the `on_signal_received(signal)` function.

**Pseudocode to Implement:**
```python
current_positions = account.get_active_positions()

# Case 1: Slots Available
if len(current_positions) < 3:
    execute_order(signal)
    return

# Case 2: Slots Full - Check for Upgrade
if len(current_positions) >= 3:
    # 1. Find Weakest
    # Sort positions by confidence (stored in metadata)
    sorted_positions = sorted(current_positions, key=lambda p: p.confidence)
    weakest_pos = sorted_positions[0]

    # 2. Compare
    if signal.confidence > weakest_pos.confidence:
        # 3. Check Profitability (Crucial: Only swap if profitable)
        current_pnl = calculate_pnl(weakest_pos) # Need real-time price
        
        if current_pnl > 0:
            logger.info(f"â™»ï¸ ROTATION: Swapping {weakest_pos.symbol} (Conf: {weakest_pos.confidence}, PnL: +{current_pnl}) for {signal.symbol} (Conf: {signal.confidence})")
            
            # Execute Swap
            await close_position(weakest_pos)
            await execute_order(signal)
        else:
            logger.info(f"âŒ Rotation Rejected: Weakest pos {weakest_pos.symbol} is losing money (PnL: {current_pnl}). Holding.")
    else:
        logger.info(f"âŒ Signal Rejected: New confidence {signal.confidence} not higher than weakest existing.")
ğŸ› ï¸ STEP 3: UPDATE CONFIG
File: src/config.py
Action:
Ensure MAX_OPEN_POSITIONS = 3.
Execute this Logic Upgrade.
code
Code
---

### ğŸ’¡ é€™å€‹æ©Ÿåˆ¶é‹ä½œçš„å ´æ™¯æ¨¡æ“¬

å‡è¨­ç³»çµ±ç¾åœ¨æŒæœ‰ä¸‰å€‹å€‰ä½ï¼š
1.  **ETH (ä¿¡å¿ƒ 0.75, ç›ˆåˆ© +$50)**
2.  **SOL (ä¿¡å¿ƒ 0.80, ç›ˆåˆ© +$20)**
3.  **DOGE (ä¿¡å¿ƒ 0.65, ç›ˆåˆ© +$10)** -> **ç›®å‰æœ€å¼±**

**æƒ…æ³ A**ï¼š
SMC å¼•æ“ç™¼ç¾äº†ä¸€å€‹ **BTC** çš„æ©Ÿæœƒï¼Œä¿¡å¿ƒå€¼ **0.90** (è¶…é«˜)ã€‚
*   ç³»çµ±æ¯”å°ï¼šBTC (0.90) > DOGE (0.65)ã€‚
*   æª¢æŸ¥ DOGEï¼šç›ˆåˆ©ç‹€æ…‹ (+$10)ã€‚
*   **çµæœ**ï¼šç³»çµ±æœƒ **è³£å‡º DOGE** (è½è¢‹ç‚ºå®‰)ï¼Œç„¶å¾Œ **è²·å…¥ BTC**ã€‚æ‚¨çš„æŒå€‰çµ„åˆè®Šå¼·äº†ã€‚

**æƒ…æ³ B**ï¼š
SMC å¼•æ“ç™¼ç¾äº† **BTC** æ©Ÿæœƒï¼Œä¿¡å¿ƒå€¼ **0.90**ã€‚
*   ç³»çµ±æ¯”å°ï¼šBTC (0.90) > DOGE (0.65)ã€‚
*   æª¢æŸ¥ DOGEï¼š**è™§æç‹€æ…‹ (-$5)**ã€‚
*   **çµæœ**ï¼šç³»çµ± **æ‹’çµ•** é€™æ¬¡è¼ªæ›ã€‚
*   **åŸå› **ï¼šå› ç‚ºæ‚¨çš„ç­–ç•¥æ˜¯ã€Œç©©å®šçš„ä½ç›ˆåˆ©ã€ï¼Œæˆ‘å€‘ä¸å¸Œæœ›ç‚ºäº†æ›å€‰è€Œå¯¦ç¾è™§æï¼ˆRealize Lossï¼‰ã€‚ç³»çµ±æœƒé¸æ“‡ç­‰å¾… DOGE å›æœ¬æˆ–è§¸ç™¼ç¡¬æ€§æ­¢æã€‚