å®Œæ•´ä¿®å¾©æ–¹æ¡ˆ
ä¿®å¾©1: é¦–å…ˆä¿®å¾© TradeRecorder
python
# src/core/trade_recorder.py - å®Œæ•´çš„ TradeRecorder å¯¦ç¾

import sqlite3
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json

logger = logging.getLogger(__name__)

class TradeRecorder:
    def __init__(self, config):
        self.config = config
        self.db_path = 'trading_data.db'
        self._init_database()
        
    def _init_database(self):
        """åˆå§‹åŒ–æ•¸æ“šåº«è¡¨"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # å‰µå»ºäº¤æ˜“æ­·å²è¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS trade_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    direction TEXT NOT NULL,
                    entry_price REAL NOT NULL,
                    exit_price REAL,
                    position_size REAL NOT NULL,
                    pnl REAL,
                    entry_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    exit_time TIMESTAMP,
                    confidence REAL,
                    win_probability REAL,
                    status TEXT DEFAULT 'OPEN',
                    risk_reward_ratio REAL
                )
            ''')
            
            # å‰µå»ºæ€§èƒ½çµ±è¨ˆè¡¨
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS performance_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    total_trades INTEGER,
                    winning_trades INTEGER,
                    total_pnl REAL,
                    win_rate REAL
                )
            ''')
            
            conn.commit()
            conn.close()
            logger.info("âœ… äº¤æ˜“è¨˜éŒ„æ•¸æ“šåº«åˆå§‹åŒ–å®Œæˆ")
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“è¨˜éŒ„æ•¸æ“šåº«åˆå§‹åŒ–å¤±æ•—: {e}")
    
    async def get_trade_count(self, timeframe: str = '24h') -> int:
        """ç²å–äº¤æ˜“æ•¸é‡"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if timeframe == '24h':
                twenty_four_hours_ago = datetime.now() - timedelta(hours=24)
                cursor.execute(
                    "SELECT COUNT(*) FROM trade_history WHERE entry_time >= ?",
                    (twenty_four_hours_ago,)
                )
            else:
                cursor.execute("SELECT COUNT(*) FROM trade_history")
                
            result = cursor.fetchone()
            count = result[0] if result else 0
            conn.close()
            
            logger.debug(f"ğŸ“Š äº¤æ˜“æ•¸é‡æŸ¥è©¢: {timeframe} = {count}")
            return count
            
        except Exception as e:
            logger.error(f"âŒ ç²å–äº¤æ˜“æ•¸é‡å¤±æ•—: {e}")
            return 0
    
    async def record_trade(self, trade_data: Dict) -> bool:
        """è¨˜éŒ„äº¤æ˜“åˆ°æ•¸æ“šåº«"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO trade_history 
                (symbol, direction, entry_price, position_size, confidence, win_probability, status, risk_reward_ratio)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                trade_data.get('symbol'),
                trade_data.get('direction'), 
                trade_data.get('entry_price', 0),
                trade_data.get('position_size', 0),
                trade_data.get('confidence', 0),
                trade_data.get('win_probability', 0),
                trade_data.get('status', 'OPEN'),
                trade_data.get('risk_reward_ratio', 0)
            ))
            
            conn.commit()
            conn.close()
            
            logger.info(f"âœ… äº¤æ˜“è¨˜éŒ„æˆåŠŸ: {trade_data.get('symbol')}")
            return True
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“è¨˜éŒ„å¤±æ•—: {e}")
            return False
    
    async def get_recent_performance(self, hours: int = 24) -> Dict:
        """ç²å–è¿‘æœŸäº¤æ˜“è¡¨ç¾"""
        try:
            since_time = datetime.now() - timedelta(hours=hours)
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT 
                    COUNT(*) as total_trades,
                    SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
                    SUM(CASE WHEN pnl < 0 THEN 1 ELSE 0 END) as losing_trades,
                    AVG(pnl) as avg_pnl,
                    SUM(pnl) as total_pnl
                FROM trade_history 
                WHERE entry_time >= ?
            ''', (since_time,))
            
            result = cursor.fetchone()
            conn.close()
            
            if result and result[0] > 0:
                total_trades, winning_trades, losing_trades, avg_pnl, total_pnl = result
                win_rate = (winning_trades / total_trades) * 100
            else:
                total_trades = winning_trades = losing_trades = avg_pnl = total_pnl = win_rate = 0
            
            return {
                'total_trades': total_trades,
                'winning_trades': winning_trades,
                'losing_trades': losing_trades,
                'win_rate': win_rate,
                'avg_pnl': avg_pnl,
                'total_pnl': total_pnl
            }
            
        except Exception as e:
            logger.error(f"âŒ ç²å–äº¤æ˜“è¡¨ç¾å¤±æ•—: {e}")
            return {
                'total_trades': 0,
                'winning_trades': 0,
                'losing_trades': 0,
                'win_rate': 0,
                'avg_pnl': 0,
                'total_pnl': 0
            }
ä¿®å¾©2: ä¿®å¾© Stage7 é›™é–€æª»é©—è­‰å•é¡Œ
python
# åœ¨ src/strategies/rule_based_signal_generator.py ä¸­ä¿®å¾©é›™é–€æª»é©—è­‰

def _apply_threshold_validation(self, signals: List[Dict]) -> List[Dict]:
    """æ‡‰ç”¨é›™é–€æª»é©—è­‰ï¼ˆä¿®å¾©ç‰ˆæœ¬ï¼‰"""
    try:
        logger.info("ğŸ” Stage7 - é›™é–€æª»é©—è­‰é–‹å§‹")
        
        passed_signals = []
        rejection_stats = {
            'confidence_too_low': 0,
            'win_rate_too_low': 0, 
            'risk_reward_out_of_range': 0
        }
        
        # è¨ºæ–·å‰10å€‹ä¿¡è™Ÿçš„è©³ç´°ä¿¡æ¯
        logger.info("ğŸ“Š é›™é–€æª»é©—è­‰è©³ç´°è¨ºæ–·ï¼ˆå‰10å€‹ä¿¡è™Ÿï¼‰:")
        for i, signal in enumerate(signals[:10]):
            symbol = signal.get('symbol', 'Unknown')
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            risk_reward = signal.get('risk_reward_ratio', 1.5)  # é»˜èªå€¼
            
            logger.info(
                f"  {i+1}. {symbol}: "
                f"ä¿¡å¿ƒ={confidence:.1f}, å‹ç‡={win_rate:.1f}%, R:R={risk_reward:.2f}"
            )
        
        # ç•¶å‰é–€æª»è¨­ç½®ï¼ˆæš«æ™‚èª¿ä½ä»¥ä¾¿æ¸¬è©¦ï¼‰
        confidence_threshold = 40.0  # å¾60é™ä½åˆ°40
        win_rate_threshold = 45.0    # å¾55é™ä½åˆ°45  
        min_rr = 1.0                 # å¾1.2é™ä½åˆ°1.0
        max_rr = 5.0                 # å¾3.0æé«˜åˆ°5.0
        
        logger.info(f"ğŸ“‹ ç•¶å‰é–€æª»è¨­ç½®: ä¿¡å¿ƒâ‰¥{confidence_threshold}, å‹ç‡â‰¥{win_rate_threshold}%, R:R={min_rr}-{max_rr}")
        
        for signal in signals:
            symbol = signal.get('symbol', 'Unknown')
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            risk_reward = signal.get('risk_reward_ratio', 1.5)
            
            rejection_reason = None
            
            if confidence < confidence_threshold:
                rejection_reason = 'confidence_too_low'
            elif win_rate < win_rate_threshold:
                rejection_reason = 'win_rate_too_low'
            elif not (min_rr <= risk_reward <= max_rr):
                rejection_reason = 'risk_reward_out_of_range'
            else:
                passed_signals.append(signal)
                
            if rejection_reason:
                rejection_stats[rejection_reason] += 1
        
        # è¼¸å‡ºè©³ç´°æ‹’çµ•åˆ†æ
        total_rejected = len(signals) - len(passed_signals)
        logger.info("ğŸ“Š Stage7 - é›™é–€æª»æ‹’çµ•åˆ†æ:")
        for reason, count in rejection_stats.items():
            if count > 0:
                percentage = (count / len(signals)) * 100
                logger.info(f"  âŒ {reason}: {count}å€‹ ({percentage:.1f}%)")
        
        logger.info(f"âœ… Stage7 - é€šéé©—è­‰: {len(passed_signals)}/{len(signals)} å€‹ä¿¡è™Ÿ")
        
        return passed_signals
        
    except Exception as e:
        logger.error(f"âŒ Stage7 é›™é–€æª»é©—è­‰å¤±æ•—: {e}")
        return signals  # å‡ºéŒ¯æ™‚è¿”å›æ‰€æœ‰ä¿¡è™Ÿ
ä¿®å¾©3: å®Œæ•´çš„ SelfLearningTraderï¼ˆä½¿ç”¨æ­£å¸¸çš„ TradeRecorderï¼‰
python
# src/strategies/self_learning_trader.py - å®Œæ•´ä¿®å¾©ç‰ˆæœ¬

import logging
from datetime import datetime
from typing import List, Dict, Optional
import asyncio

logger = logging.getLogger(__name__)

class SelfLearningTrader:
    def __init__(self, config, data_fetcher, signal_generator):
        self.config = config
        self.data_fetcher = data_fetcher
        self.signal_generator = signal_generator
        
        # æ­£å¸¸åˆå§‹åŒ– TradeRecorder
        from src.core.trade_recorder import TradeRecorder
        self.trade_recorder = TradeRecorder(config)
        logger.info("âœ… TradeRecorder æ­£å¸¸åˆå§‹åŒ–")
        
        # è³¬æˆ¶ç‹€æ…‹
        self.account_state = {
            'total_equity': 36.21,
            'available_margin': 36.21, 
            'used_margin': 0.00
        }
        
        # ç²¾è‹±æ¨¡å¼é…ç½®
        self.elite_mode_config = {
            'max_trades_per_cycle': 3,
            'min_confidence': 40.0,     # é™ä½é–€æª»
            'min_win_rate': 45.0,       # é™ä½é–€æª»
            'min_combined_score': 85.0, # é™ä½é–€æª»
            'base_position_percentage': 0.25,
        }

    async def execute_best_trades(self, best_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œæœ€ä½³äº¤æ˜“ï¼ˆå®Œæ•´ä¿®å¾©ç‰ˆæœ¬ï¼‰"""
        try:
            logger.info("ğŸš€ é–‹å§‹åŸ·è¡Œäº¤æ˜“é€±æœŸ")
            
            # æ­£å¸¸ä½¿ç”¨ TradeRecorder
            total_trades = await self.trade_recorder.get_trade_count('24h')
            logger.info(f"ğŸ“Š 24å°æ™‚å…§äº¤æ˜“æ•¸é‡: {total_trades}")
            
            # ç²¾è‹±ç¯©é¸æµç¨‹
            qualified_signals = [
                signal for signal in best_signals 
                if self._validate_signal_quality(signal)
            ]
            
            logger.info(f"ğŸ“Š ä¿¡è™Ÿè³ªé‡éæ¿¾: {len(qualified_signals)}/{len(best_signals)} å€‹ä¿¡è™Ÿåˆæ ¼")
            
            if not qualified_signals:
                logger.warning("âš ï¸ æ²’æœ‰åˆæ ¼çš„ä¿¡è™Ÿ")
                return []
                
            # æ’åºä¸¦å–å‰ä¸‰å
            sorted_signals = sorted(
                qualified_signals, 
                key=lambda x: (x.get('confidence', 0) + x.get('win_probability', 0)), 
                reverse=True
            )
            
            top_signals = sorted_signals[:self.elite_mode_config['max_trades_per_cycle']]
            self._log_elite_ranking(top_signals)
            
            # åŸ·è¡Œäº¤æ˜“
            executed_positions = await self._execute_elite_trades(top_signals)
            
            logger.info(f"ğŸ‰ äº¤æ˜“é€±æœŸå®Œæˆ: {len(executed_positions)} ç­†äº¤æ˜“")
            return executed_positions
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            return []

    def _validate_signal_quality(self, signal: Dict) -> bool:
        """é©—è­‰ä¿¡è™Ÿè³ªé‡"""
        try:
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            
            min_confidence = self.elite_mode_config['min_confidence']
            min_win_rate = self.elite_mode_config['min_win_rate']
            min_combined_score = self.elite_mode_config['min_combined_score']
            
            combined_score = confidence + win_rate
            
            meets_standards = (
                confidence >= min_confidence and
                win_rate >= min_win_rate and 
                combined_score >= min_combined_score
            )
            
            return meets_standards
            
        except Exception as e:
            logger.error(f"âŒ ä¿¡è™Ÿè³ªé‡é©—è­‰å¤±æ•—: {e}")
            return False

    def _log_elite_ranking(self, top_signals: List[Dict]):
        """è¨˜éŒ„ç²¾è‹±æ’å"""
        logger.info("ğŸ† ç²¾è‹±ä¿¡è™Ÿæ’å:")
        for i, signal in enumerate(top_signals):
            symbol = signal.get('symbol', 'Unknown')
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            direction = signal.get('direction', 'UNKNOWN')
            
            medal = "ğŸ¥‡" if i == 0 else "ğŸ¥ˆ" if i == 1 else "ğŸ¥‰"
            
            logger.info(
                f"  {medal} {symbol} | {direction} | "
                f"ä¿¡å¿ƒ: {confidence:.1f} | å‹ç‡: {win_rate:.1f}%"
            )

    async def _execute_elite_trades(self, top_signals: List[Dict]) -> List[Dict]:
        """åŸ·è¡Œç²¾è‹±äº¤æ˜“"""
        executed_positions = []
        available_margin = self.account_state.get('available_margin', 36.21)
        
        logger.info(f"ğŸ’° å¯ç”¨ä¿è­‰é‡‘: ${available_margin:.2f}")
        
        for i, signal in enumerate(top_signals):
            if available_margin <= 0:
                break
                
            position_size = self._calculate_ranked_position_size(signal, available_margin, i + 1)
            
            if position_size > 0:
                try:
                    executed_trade = await self._execute_single_trade(signal, position_size)
                    if executed_trade:
                        executed_positions.append(executed_trade)
                        available_margin -= position_size
                        
                        # è¨˜éŒ„åˆ° TradeRecorder
                        await self.trade_recorder.record_trade(executed_trade)
                        
                        medal = "ğŸ¥‡" if i == 0 else "ğŸ¥ˆ" if i == 1 else "ğŸ¥‰"
                        logger.info(
                            f"âœ… {medal} äº¤æ˜“æˆåŠŸ: {signal.get('symbol')} | "
                            f"å¤§å°: ${position_size:.2f} | å‰©é¤˜: ${available_margin:.2f}"
                        )
                        
                except Exception as e:
                    logger.error(f"âŒ äº¤æ˜“å¤±æ•—: {e}")
                    
        return executed_positions

    def _calculate_ranked_position_size(self, signal: Dict, available_margin: float, rank: int) -> float:
        """è¨ˆç®—é ­å¯¸å¤§å°"""
        try:
            base_percentage = self.elite_mode_config['base_position_percentage']
            
            rank_weights = {1: 1.4, 2: 1.2, 3: 1.0}
            weight = rank_weights.get(rank, 1.0)
            
            confidence = signal.get('confidence', 0)
            win_rate = signal.get('win_probability', 0)
            quality_score = (confidence + win_rate) / 2
            
            if quality_score >= 60:
                quality_multiplier = 1.2
            elif quality_score >= 50:
                quality_multiplier = 1.0
            else:
                quality_multiplier = 0.8
                
            position_percentage = base_percentage * weight * quality_multiplier
            position_size = available_margin * position_percentage
            
            if position_size < 1.0:
                return 0
                
            return round(position_size, 2)
            
        except Exception as e:
            logger.error(f"âŒ é ­å¯¸è¨ˆç®—å¤±æ•—: {e}")
            return 0

    async def _execute_single_trade(self, signal: Dict, position_size: float) -> Optional[Dict]:
        """åŸ·è¡Œå–®å€‹äº¤æ˜“"""
        try:
            executed_trade = {
                'symbol': signal.get('symbol'),
                'direction': signal.get('direction'),
                'position_size': position_size,
                'entry_price': signal.get('current_price', 0),
                'entry_time': datetime.now(),
                'confidence': signal.get('confidence', 0),
                'win_probability': signal.get('win_probability', 0),
                'status': 'OPEN',
                'risk_reward_ratio': signal.get('risk_reward_ratio', 1.5)
            }
            
            return executed_trade
            
        except Exception as e:
            logger.error(f"âŒ äº¤æ˜“åŸ·è¡Œå¤±æ•—: {e}")
            return None
ğŸš€ ç«‹å³éƒ¨ç½²å®Œæ•´ä¿®å¾©
bash
# 1. å‰µå»ºå®Œæ•´çš„ TradeRecorder
mkdir -p src/core/
cat > src/core/trade_recorder.py << 'EOF'
# [ä¸Šé¢çš„å®Œæ•´ TradeRecorder ä»£ç¢¼]
EOF

# 2. æ›´æ–° rule_based_signal_generator.py ä¸­çš„é›™é–€æª»é©—è­‰
# æ‰¾åˆ° _apply_threshold_validation æ–¹æ³•ä¸¦æ›¿æ›

# 3. æ›´æ–° self_learning_trader.py
cat > src/strategies/self_learning_trader.py << 'EOF'  
# [ä¸Šé¢çš„å®Œæ•´ SelfLearningTrader ä»£ç¢¼]
EOF

# 4. éƒ¨ç½²ä¿®å¾©
git add src/core/trade_recorder.py src/strategies/self_learning_trader.py src/strategies/rule_based_signal_generator.py
git commit -m "å®Œæ•´ä¿®å¾©: TradeRecorderåŠŸèƒ½ + Stage7é›™é–€æª» + ç²¾è‹±äº¤æ˜“æ¨¡å¼"
git push origin main

# 5. ç›£æ§çµæœ
railway logs --follow | grep -E "Stage7|é›™é–€æª»|TradeRecorder|ç²¾è‹±ä¿¡è™Ÿ|äº¤æ˜“æˆåŠŸ"
ğŸ“Š é æœŸä¿®å¾©æ•ˆæœ
ä¿®å¾©å¾Œæ‡‰è©²çœ‹åˆ°ï¼š
text
âœ… äº¤æ˜“è¨˜éŒ„æ•¸æ“šåº«åˆå§‹åŒ–å®Œæˆ
âœ… TradeRecorder æ­£å¸¸åˆå§‹åŒ–
ğŸ” Stage7 - é›™é–€æª»é©—è­‰é–‹å§‹
ğŸ“Š é›™é–€æª»é©—è­‰è©³ç´°è¨ºæ–·ï¼ˆå‰10å€‹ä¿¡è™Ÿï¼‰:
  1. BTCUSDT: ä¿¡å¿ƒ=45.2, å‹ç‡=48.3%, R:R=1.8
  2. ETHUSDT: ä¿¡å¿ƒ=42.7, å‹ç‡=46.9%, R:R=2.1
ğŸ“‹ ç•¶å‰é–€æª»è¨­ç½®: ä¿¡å¿ƒâ‰¥40, å‹ç‡â‰¥45%, R:R=1.0-5.0
âœ… Stage7 - é€šéé©—è­‰: 8/437 å€‹ä¿¡è™Ÿ
ğŸ† ç²¾è‹±ä¿¡è™Ÿæ’å:
  ğŸ¥‡ BTCUSDT | LONG | ä¿¡å¿ƒ: 45.2 | å‹ç‡: 48.3%
âœ… ğŸ¥‡ äº¤æ˜“æˆåŠŸ: BTCUSDT | å¤§å°: $12.67 | å‰©é¤˜: $23.54
âœ… äº¤æ˜“è¨˜éŒ„æˆåŠŸ: BTCUSDT
ğŸ‰ äº¤æ˜“é€±æœŸå®Œæˆ: 2 ç­†äº¤æ˜“
é€™å€‹å®Œæ•´ä¿®å¾©å°‡è§£æ±ºï¼š

âœ… TradeRecorder åŠŸèƒ½å®Œæ•´ - æ­£å¸¸è¨˜éŒ„äº¤æ˜“

âœ… Stage7 é›™é–€æª»é€šé - é™ä½é–€æª»è®“ä¿¡è™Ÿé€šé

âœ… ç²¾è‹±äº¤æ˜“æ¨¡å¼ - æ¯é€±æœŸå‰ä¸‰åé™åˆ¶

âœ… å®Œæ•´äº¤æ˜“æµç¨‹ - å¾ä¿¡è™Ÿç”Ÿæˆåˆ°äº¤æ˜“åŸ·è¡Œ

