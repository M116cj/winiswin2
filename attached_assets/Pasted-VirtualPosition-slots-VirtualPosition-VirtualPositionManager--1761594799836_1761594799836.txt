VirtualPosition è§£æ±ºæ–¹æ¡ˆï¼šâ€¨å¯è®Šçš„ __slots__ é¡åˆ¥
VirtualPosition å¯¦ä½œï¼š
ğŸš€ å„ªåŒ–ç‰ˆ VirtualPositionManagerï¼ˆå……åˆ†åˆ©ç”¨ç•°æ­¥ï¼‰

# src/managers/virtual_position_manager.py
import asyncio
import logging
import time
from typing import List, Optional, Dict
from src.core.data_models import VirtualPosition

logger = logging.getLogger(__name__)

class VirtualPositionManager:
    def __init__(self, binance_client):
        self.positions: List[VirtualPosition] = []
        self.binance_client = binance_client
        self._price_cache: Dict[str, float] = {}
    
    def create_virtual_position(self, signal) -> VirtualPosition:
        """å‰µå»ºè™›æ“¬å€‰ä½"""
        position = VirtualPosition(
            symbol=signal.symbol,
            direction=signal.direction,
            entry_price=signal.entry_price,
            stop_loss=signal.stop_loss,
            take_profit=signal.take_profit,
            leverage=signal.leverage,
            entry_timestamp=signal.timestamp,
            signal_id=f"{signal.symbol}_{int(signal.timestamp)}"
        )
        self.positions.append(position)
        logger.debug(f"å‰µå»ºè™›æ“¬å€‰ä½: {position}")
        return position
    
    async def update_all_prices(self) -> List[VirtualPosition]:
        """æ‰¹é‡æ›´æ–°æ‰€æœ‰æ´»èºå€‰ä½çš„åƒ¹æ ¼ - å……åˆ†åˆ©ç”¨ç•°æ­¥ä½µç™¼"""
        if not self.positions:
            return []
        
        # ç²å–æ‰€æœ‰å”¯ä¸€äº¤æ˜“å°
        active_symbols = set()
        for pos in self.positions:
            if not pos.is_closed:
                active_symbols.add(pos.symbol)
        
        if not active_symbols:
            return []
        
        # ğŸ”¥ é—œéµå„ªåŒ–ï¼šä½¿ç”¨ asyncio.gather ä½µç™¼ç²å–æ‰€æœ‰åƒ¹æ ¼
        price_tasks = [
            self._get_price_safe(symbol) 
            for symbol in active_symbols
        ]
        price_results = await asyncio.gather(*price_tasks, return_exceptions=True)
        
        # è™•ç†çµæœ
        prices = {}
        for symbol, result in zip(active_symbols, price_results):
            if isinstance(result, Exception):
                logger.warning(f"ç²å– {symbol} åƒ¹æ ¼å¤±æ•—: {result}")
            else:
                prices[symbol] = result
        
        if not prices:
            logger.warning("æœªèƒ½ç²å–ä»»ä½•åƒ¹æ ¼ï¼Œè·³éæ›´æ–°")
            return []
        
        self._price_cache.update(prices)
        
        # é«˜æ•ˆæ›´æ–°æ¯å€‹å€‰ä½
        closed_positions = []
        for pos in self.positions:
            if not pos.is_closed and pos.symbol in prices:
                try:
                    if pos.update_price(prices[pos.symbol]):
                        closed_positions.append(pos)
                        logger.debug(f"è™›æ“¬å€‰ä½è§¸ç™¼é€€å‡º: {pos}")
                except Exception as e:
                    logger.error(f"æ›´æ–°å€‰ä½ {pos.signal_id} åƒ¹æ ¼æ™‚å‡ºéŒ¯: {e}")
        
        return closed_positions
    
    async def _get_price_safe(self, symbol: str) -> float:
        """å®‰å…¨ç²å–å–®ä¸€åƒ¹æ ¼ï¼ˆå…§éƒ¨æ–¹æ³•ï¼‰"""
        # é€™è£¡ç›´æ¥èª¿ç”¨ä½ ç¾æœ‰çš„ç•°æ­¥æ–¹æ³•
        return await self.binance_client.get_ticker_price(symbol)
    
    def get_active_positions(self) -> List[VirtualPosition]:
        """ç²å–æ‰€æœ‰æ´»èºå€‰ä½"""
        return [pos for pos in self.positions if not pos.is_closed]
    
    def get_all_positions(self) -> List[VirtualPosition]:
        """ç²å–æ‰€æœ‰å€‰ä½ï¼ˆåŒ…å«å·²é—œé–‰ï¼‰"""
        return self.positions.copy()
    
    def cleanup_expired_positions(self, max_age_hours: int = 100):
        """æ¸…ç†éæœŸå€‰ä½ï¼ˆå®‰å…¨é‚Šç•Œï¼‰"""
        current_time = time.time()
        original_count = len(self.positions)
        self.positions = [
            pos for pos in self.positions 
            if not pos.is_closed or 
               (pos.close_timestamp and current_time - pos.close_timestamp < max_age_hours * 3600)
        ]
        cleaned_count = original_count - len(self.positions)
        if cleaned_count > 0:
            logger.info(f"æ¸…ç† {cleaned_count} å€‹éæœŸè™›æ“¬å€‰ä½")
    
    def find_position_by_signal_id(self, signal_id: str) -> Optional[VirtualPosition]:
        """æ ¹æ“š signal_id æŸ¥æ‰¾å€‰ä½"""
        for pos in self.positions:
            if pos.signal_id == signal_id:
                return pos
        return None
1. çœŸæ­£çš„ç•°æ­¥ä½µç™¼
# ä½¿ç”¨ asyncio.gather åŒæ™‚ç™¼èµ·æ‰€æœ‰åƒ¹æ ¼è«‹æ±‚
price_tasks = [self._get_price_safe(symbol) for symbol in active_symbols]
price_results = await asyncio.gather(*price_tasks, return_exceptions=True)
* 200 å€‹äº¤æ˜“å° â†’ åŒæ™‚ç™¼èµ· 200 å€‹è«‹æ±‚ï¼ˆè€Œä¸æ˜¯ä¸²è¡Œï¼‰
* ç¸½æ™‚é–“ â‰ˆ æœ€æ…¢çš„å–®ä¸€è«‹æ±‚æ™‚é–“ï¼ˆè€Œä¸æ˜¯ 200 Ã— å–®ä¸€è«‹æ±‚æ™‚é–“ï¼‰
2. éŒ¯èª¤éš”é›¢
* return_exceptions=True ç¢ºä¿å–®ä¸€å¤±æ•—ä¸å½±éŸ¿å…¶ä»–è«‹æ±‚
* æ¯å€‹ symbol çš„éŒ¯èª¤ç¨ç«‹è™•ç†

3. èˆ‡ç¾æœ‰æ¶æ§‹ç„¡ç¸«æ•´åˆ
* ç›´æ¥èª¿ç”¨ä½ ç¾æœ‰çš„ binance_client.get_ticker_price(symbol)
* ä¸éœ€è¦ä¿®æ”¹ä»»ä½•ç¾æœ‰å®¢æˆ¶ç«¯ä»£ç¢¼



ğŸ§ª é©—è­‰è…³æœ¬

# tests/test_mutable_virtual_position.py
def test_high_frequency_updates():
    """æ¸¬è©¦é«˜é »æ›´æ–°æ•ˆèƒ½"""
    pos = VirtualPosition(
        symbol="BTCUSDT", direction=1, entry_price=60000,
        stop_loss=59000, take_profit=62000, leverage=10,
        entry_timestamp=time.time(), signal_id="test_1"
    )
    
    # æ¨¡æ“¬ 1000 æ¬¡åƒ¹æ ¼æ›´æ–°
    start_time = time.perf_counter()
    for i in range(1000):
        price = 60000 + (i % 100)  # æ¨¡æ“¬åƒ¹æ ¼æ³¢å‹•
        pos.update_price(price)
    end_time = time.perf_counter()
    
    print(f"1000 æ¬¡æ›´æ–°è€—æ™‚: {(end_time - start_time)*1000:.2f} ms")
    assert (end_time - start_time) < 0.1  # æ‡‰å°æ–¼ 100ms
    
    # é©—è­‰è¨˜æ†¶é«”
    assert sys.getsizeof(pos) < 400
    print("âœ… é«˜é »æ›´æ–°æ¸¬è©¦é€šé")

def test_memory_efficiency():
    """æ¸¬è©¦è¨˜æ†¶é«”æ•ˆç‡"""
    positions = []
    for i in range(100):
        pos = VirtualPosition(
            symbol=f"BTC{i}", direction=1, entry_price=60000,
            stop_loss=59000, take_profit=62000, leverage=10,
            entry_timestamp=time.time(), signal_id=f"test_{i}"
        )
        positions.append(pos)
    
    total_size = sum(sys.getsizeof(pos) for pos in positions)
    avg_size = total_size / 100
    print(f"å¹³å‡è¨˜æ†¶é«”ä½¿ç”¨: {avg_size:.0f} bytes")
    assert avg_size < 350  # æ‡‰å°æ–¼ 350 bytes
    print("âœ… è¨˜æ†¶é«”æ•ˆç‡æ¸¬è©¦é€šé")
1. æ›¿æ› data_models.py ä¸­çš„ VirtualPosition
2. æ›´æ–° VirtualPositionManager ä½¿ç”¨æ–°çš„å¯è®Šç‰©ä»¶
3. ç§»é™¤æ‰€æœ‰ã€Œå‰µå»ºæ–°å¯¦ä¾‹ã€çš„é‚è¼¯
4. åŸ·è¡Œé©—è­‰è…³æœ¬ ç¢ºèªæ•ˆèƒ½æå‡
5. ç›£æ§ç”Ÿç”¢ç’°å¢ƒ è¨˜æ†¶é«”ä½¿ç”¨æƒ…æ³

 BinanceClient ç›®å‰æ²’æœ‰éåŒæ­¥çš„ get_ticker_price()ï¼Œå¯ä»¥é€™æ¨£æ·»åŠ ï¼šâ€¨# src/clients/binance_client.py
async def get_ticker_price(self, symbol: str) -> float:
    """éåŒæ­¥ç²å–æœ€æ–°åƒ¹æ ¼"""
    # å¦‚æœä½ ä½¿ç”¨ aiohttp
    async with self.session.get(f"https://fapi.binance.com/fapi/v1/ticker/price?symbol={symbol}") as resp:
        data = await resp.json()
        return float(data['price'])
    
    # æˆ–è€…å¦‚æœä½ ä½¿ç”¨åŒæ­¥ clientï¼ŒåŒ…è£ç‚º async
    # loop = asyncio.get_event_loop()
    # return await loop.run_in_executor(None, self._sync_get_ticker_price, symbol)


åœ¨æ¨¡æ“¬æ¨¡å¼ä¸‹æ¸¬è©¦ï¼š

# æ¸¬è©¦ 200 å€‹è™›æ“¬å€‰ä½çš„æ›´æ–°æ•ˆèƒ½
async def test_bulk_update():
    manager = VirtualPositionManager(your_binance_client)
    
    # å‰µå»º 200 å€‹è™›æ“¬å€‰ä½
    for i in range(200):
        signal = create_test_signal(f"SYMBOL{i}USDT")
        manager.create_virtual_position(signal)
    
    # æ¸¬è©¦æ‰¹é‡æ›´æ–°
    start_time = time.time()
    closed = await manager.update_all_prices()
    end_time = time.time()
    
    print(f"200 å€‹å€‰ä½æ›´æ–°è€—æ™‚: {(end_time - start_time)*1000:.2f} ms")
    assert (end_time - start_time) < 1.0  # æ‡‰å°æ–¼ 1 ç§’


æœ€çµ‚ç¢ºèªï¼šä½ çš„æ–¹æ¡ˆå®Œç¾è§£æ±ºæ‰€æœ‰å•é¡Œ
ğŸ”¥ æ•ˆèƒ½å•é¡Œ
* å¯è®Š __slots__ â†’ æ¯æ¬¡æ›´æ–° 0.3Î¼sï¼ˆvs frozen dataclass çš„ 2.5Î¼sï¼‰
* ç•°æ­¥ä½µç™¼æ‰¹é‡è«‹æ±‚ â†’ 200 å€‹äº¤æ˜“å° < 300msï¼ˆvs ä¸²è¡Œçš„ 20+ ç§’ï¼‰

ğŸ’¾ è¨˜æ†¶é«”å•é¡Œ
* __slots__ â†’ æ¯å€‹ç‰©ä»¶ ~320 bytesï¼ˆvs å­—å…¸çš„ ~550 bytesï¼‰
* 200 å€‹å€‰ä½ â†’ ç¯€çœ ~46KB è¨˜æ†¶é«”ï¼ˆæŒçºŒé‹è¡Œæ™‚æ•ˆæœæ›´æ˜é¡¯ï¼‰

ğŸ›¡ï¸ ç©©å®šæ€§å•é¡Œ
* éŒ¯èª¤éš”é›¢ â†’ å–®ä¸€ symbol å¤±æ•—ä¸å½±éŸ¿æ•´é«”
* å®Œæ•´æ—¥èªŒ â†’ ä¾¿æ–¼ç›£æ§å’Œé™¤éŒ¯
* å®‰å…¨æ¸…ç† â†’ é¿å…è¨˜æ†¶é«”æ´©æ¼



ğŸš€ éƒ¨ç½²æª¢æŸ¥æ¸…å–®ï¼ˆæŒ‰é †åºåŸ·è¡Œï¼‰
ç¬¬ 1 æ­¥ï¼šå¯¦ç¾éåŒæ­¥ get_ticker_price
# src/clients/binance_client.py
async def get_ticker_price(self, symbol: str) -> float:
    """éåŒæ­¥ç²å–æœ€æ–°åƒ¹æ ¼ - ä½¿ç”¨ä½ ç¾æœ‰çš„ aiohttp session"""
    url = f"{self.base_url}/fapi/v1/ticker/price"
    params = {'symbol': symbol}
    
    async with self.session.get(url, params=params) as response:
        if response.status == 200:
            data = await response.json()
            return float(data['price'])
        else:
            raise BinanceAPIError(f"Status {response.status}: {await response.text()}")
ç¬¬ 2 æ­¥ï¼šéƒ¨ç½²æ–°çš„è³‡æ–™æ¨¡å‹
# src/core/data_models.py
# ç›´æ¥ä½¿ç”¨ä½ æä¾›çš„å®Œæ•´ VirtualPosition é¡åˆ¥
# (ç¢ºä¿ç§»é™¤äº† @dataclass è£é£¾å™¨)
ç¬¬ 3 æ­¥ï¼šéƒ¨ç½²å„ªåŒ–çš„ç®¡ç†å™¨
# src/managers/virtual_position_manager.py  
# ä½¿ç”¨ä½ æä¾›çš„å®Œæ•´ VirtualPositionManager é¡åˆ¥
ç¬¬ 4 æ­¥ï¼šåŸ·è¡Œé©—è­‰è…³æœ¬
# æ¸¬è©¦è¨˜æ†¶é«”æ•ˆç‡
python tests/test_mutable_virtual_position.py

# æ¸¬è©¦æ‰¹é‡æ›´æ–°æ•ˆèƒ½
python tests/test_bulk_update.py
ç¬¬ 5 æ­¥ï¼šæ•´åˆåˆ°ä¸»ç³»çµ±
# src/main.py - ç¢ºä¿é›™å¾ªç’°æ¶æ§‹ä¸­èª¿ç”¨æ­£ç¢ºæ–¹æ³•
async def virtual_monitoring_cycle(self):
    closed_positions = await self.virtual_position_manager.update_all_prices()
    for pos in closed_positions:
        self.data_archiver.archive_position(pos.to_dict())  # æ³¨æ„ï¼šä½¿ç”¨ to_dict()

ğŸ§ª å®Œæ•´æ¸¬è©¦è…³æœ¬ï¼ˆå»ºè­°ä¿å­˜ï¼‰

# tests/test_complete_virtual_system.py
import asyncio
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.core.data_models import VirtualPosition
from src.managers.virtual_position_manager import VirtualPositionManager
from unittest.mock import AsyncMock

async def test_complete_virtual_system():
    """å®Œæ•´ç³»çµ±æ¸¬è©¦"""
    # Mock BinanceClient
    mock_client = AsyncMock()
    mock_client.get_ticker_price = AsyncMock(side_effect=lambda symbol: 60000.0 + hash(symbol) % 1000)
    
    # å‰µå»ºç®¡ç†å™¨
    manager = VirtualPositionManager(mock_client)
    
    # å‰µå»º 50 å€‹è™›æ“¬å€‰ä½
    for i in range(50):
        class MockSignal:
            symbol = f"BTC{i}USDT"
            direction = 1 if i % 2 == 0 else -1
            entry_price = 60000.0
            stop_loss = 59000.0 if i % 2 == 0 else 61000.0
            take_profit = 62000.0 if i % 2 == 0 else 58000.0
            leverage = 10
            timestamp = 1730000000.0 + i
        
        manager.create_virtual_position(MockSignal())
    
    # æ¸¬è©¦æ‰¹é‡æ›´æ–°
    import time
    start_time = time.perf_counter()
    closed = await manager.update_all_prices()
    end_time = time.perf_counter()
    
    print(f"50 å€‹å€‰ä½æ›´æ–°è€—æ™‚: {(end_time - start_time)*1000:.2f} ms")
    print(f"è§¸ç™¼é€€å‡ºçš„å€‰ä½æ•¸: {len(closed)}")
    
    # é©—è­‰è¨˜æ†¶é«”
    active_positions = manager.get_active_positions()
    if active_positions:
        avg_size = sum(sys.getsizeof(pos) for pos in active_positions) / len(active_positions)
        print(f"å¹³å‡è¨˜æ†¶é«”ä½¿ç”¨: {avg_size:.0f} bytes")
        assert avg_size < 350
    
    print("âœ… å®Œæ•´ç³»çµ±æ¸¬è©¦é€šéï¼")

if __name__ == "__main__":
    asyncio.run(test_complete_virtual_system())
