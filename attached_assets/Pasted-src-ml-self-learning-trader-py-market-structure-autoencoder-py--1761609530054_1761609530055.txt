src/ml/
â”œâ”€â”€ self_learning_trader.py       # è‡ªæˆ‘å­¸ç¿’äº¤æ˜“å“¡ï¼ˆæ ¸å¿ƒï¼‰
â”œâ”€â”€ market_structure_autoencoder.py  # å¸‚å ´çµæ§‹è‡ªå‹•ç·¨ç¢¼å™¨
â”œâ”€â”€ feature_discovery_network.py  # ç‰¹å¾µç™¼ç¾ç¶²çµ¡
â”œâ”€â”€ liquidity_prediction_model.py # æµå‹•æ€§é æ¸¬æ¨¡å‹
â””â”€â”€ adaptive_strategy_evolver.py  # ç­–ç•¥é€²åŒ–å™¨
### ğŸ”„ **ä¿®æ”¹ç¾æœ‰æ¶æ§‹**

#### 1. **æ›¿æ› ICTStrategy ç‚º SelfLearningTrader**
```python
# src/strategies/ict_strategy.py â†’ src/strategies/self_learning_trader.py
class SelfLearningTrader:
    def __init__(self, config):
        self.config = config
        # ğŸ”¥ æ ¸å¿ƒï¼šä¸‰å€‹è‡ªä¸»å­¸ç¿’æ¨¡å‹
        self.structure_model = MarketStructureAutoencoder()  # å­¸ç¿’å¸‚å ´çµæ§‹
        self.feature_model = FeatureDiscoveryNetwork()       # ç™¼ç¾æœ‰æ•ˆç‰¹å¾µ  
        self.liquidity_model = LiquidityPredictionModel()    # é æ¸¬æµå‹•æ€§
        
    def analyze(self, symbol, multi_tf_data):
        """å®Œå…¨è‡ªä¸»çš„ä¿¡è™Ÿç”Ÿæˆ"""
        # 1. å¾åŸå§‹åƒ¹æ ¼å­¸ç¿’å¸‚å ´çµæ§‹
        market_structure = self.structure_model.encode_structure(
            multi_tf_data['5m']['close'].values
        )
        
        # 2. è‡ªå‹•ç™¼ç¾ç•¶å‰æœ€æœ‰æ•ˆçš„ç‰¹å¾µ
        dynamic_features = self.feature_model.discover_features(
            market_structure,
            multi_tf_data['5m'].tail(50)  # æœ€è¿‘50æ ¹Kç·š
        )
        
        # 3. é æ¸¬æµå‹•æ€§èšé›†é»
        liquidity_prediction = self.liquidity_model.predict_liquidity(
            symbol,
            multi_tf_data['5m'].tail(20)
        )
        
        # 4. ç”Ÿæˆäº¤æ˜“ä¿¡è™Ÿ
        signal = self._generate_signal_from_learned_patterns(
            market_structure,
            dynamic_features, 
            liquidity_prediction
        )
        
        return signal
```

#### 2. **å‡ç´š MLPredictor ç‚ºç«¯åˆ°ç«¯é æ¸¬**
```python
# src/ml/predictor.py
class SelfLearningPredictor:
    def __init__(self, config):
        self.config = config
        # ğŸ”¥ ç«¯åˆ°ç«¯æ¨¡å‹ï¼šè¼¸å…¥åŸå§‹åƒ¹æ ¼ â†’ è¼¸å‡ºäº¤æ˜“æ±ºç­–
        self.end_to_end_model = self._build_end_to_end_model()
        
    def _build_end_to_end_model(self):
        """æ§‹å»ºç«¯åˆ°ç«¯äº¤æ˜“æ¨¡å‹"""
        model = Sequential([
            # è¼¸å…¥ï¼šå¤šæ™‚é–“æ¡†æ¶åƒ¹æ ¼åºåˆ—
            Input(shape=(3, 50, 1)),  # [1h, 15m, 5m] Ã— 50æ ¹Kç·š
            
            # ç‰¹å¾µæå–å±¤
            TimeDistributed(Conv1D(32, 3, activation='relu')),
            TimeDistributed(GlobalMaxPooling1D()),
            
            # å¸‚å ´ç‹€æ…‹è­˜åˆ¥
            LSTM(64, return_sequences=True),
            Attention(),  # æ³¨æ„åŠ›æ©Ÿåˆ¶
            
            # äº¤æ˜“æ±ºç­–å±¤
            Dense(32, activation='relu'),
            Dense(3, activation='softmax')  # [åšå¤š, åšç©º, è§€æœ›]
        ])
        return model
    
    def predict_trading_decision(self, multi_tf_data):
        """ç«¯åˆ°ç«¯äº¤æ˜“æ±ºç­–"""
        # é è™•ç†æ•¸æ“š
        X = self._preprocess_multitimeframe_data(multi_tf_data)
        
        # é æ¸¬
        decision_probs = self.end_to_end_model.predict(X)
        decision = np.argmax(decision_probs)
        confidence = np.max(decision_probs)
        
        return decision, confidence
```

#### 3. **æ•´åˆåˆ°ä¸»å¾ªç’°**
```python
# src/async_core/async_main_loop.py
async def _analyze_market_pipeline(self, symbols):
    """å‡ç´šç‚ºè‡ªä¸»å­¸ç¿’åˆ†æ"""
    signals = []
    
    for symbol in symbols:
        multi_tf_data = await self.data_service.get_multi_timeframe_data(symbol)
        
        # ğŸ”¥ ä½¿ç”¨è‡ªæˆ‘å­¸ç¿’äº¤æ˜“å“¡
        if self.config.ENABLE_SELF_LEARNING:
            signal = self.self_learning_trader.analyze(symbol, multi_tf_data)
        else:
            signal = self.ict_strategy.analyze(symbol, multi_tf_data)
        
        if signal and self.risk_manager.should_accept_trade(signal):
            signals.append(signal)
    
    return signals
```

---

## ğŸ§ª **è¨“ç·´æ•¸æ“šè‡ªå‹•ç”Ÿæˆ**

### ğŸ“Š **ç„¡ç›£ç£å¸‚å ´çµæ§‹å­¸ç¿’**
```python
# src/ml/market_structure_autoencoder.py
class MarketStructureAutoencoder:
    def __init__(self):
        self.encoder = self._build_encoder()
        self.decoder = self._build_decoder()
        
    def _build_encoder(self):
        """ç·¨ç¢¼å™¨ï¼šå£“ç¸®åƒ¹æ ¼åºåˆ—åˆ°å¸‚å ´çµæ§‹å‘é‡"""
        return Sequential([
            Conv1D(64, 5, activation='relu', input_shape=(50, 1)),
            Conv1D(32, 3, activation='relu'),
            GlobalMaxPooling1D(),
            Dense(16, activation='tanh')  # 16ç¶­å¸‚å ´çµæ§‹å‘é‡
        ])
    
    def encode_structure(self, price_series):
        """å°‡åƒ¹æ ¼åºåˆ—ç·¨ç¢¼ç‚ºå¸‚å ´çµæ§‹"""
        # æ¨™æº–åŒ–
        normalized_prices = (price_series - np.mean(price_series)) / np.std(price_series)
        normalized_prices = normalized_prices.reshape(1, -1, 1)
        
        structure_vector = self.encoder.predict(normalized_prices)
        return structure_vector[0]
```

### ğŸ¯ **å¼·åŒ–å­¸ç¿’äº¤æ˜“ç­–ç•¥**
```python
# src/ml/adaptive_strategy_evolver.py
class AdaptiveStrategyEvolver:
    def __init__(self):
        self.agent = self._build_dqn_agent()  # æ·±åº¦Qç¶²çµ¡
        self.memory = deque(maxlen=10000)    # ç¶“é©—å›æ”¾
        
    def _build_dqn_agent(self):
        """æ§‹å»ºæ·±åº¦Qå­¸ç¿’ä»£ç†"""
        model = Sequential([
            Dense(128, activation='relu', input_shape=(20,)),  # ç‹€æ…‹å‘é‡
            Dense(64, activation='relu'),
            Dense(3, activation='linear')  # å‹•ä½œï¼š[åšå¤š, åšç©º, è§€æœ›]
        ])
        return model
    
    def evolve_strategy(self, state, reward, next_state, done):
        """åŸºæ–¼äº¤æ˜“çµæœé€²åŒ–ç­–ç•¥"""
        # å­˜å„²ç¶“é©—
        self.memory.append((state, reward, next_state, done))
        
        # è¨“ç·´ä»£ç†
        if len(self.memory) > 1000:
            self._train_agent()
    
    def get_trading_action(self, state):
        """ç²å–äº¤æ˜“å‹•ä½œ"""
        q_values = self.agent.predict(state.reshape(1, -1))
        return np.argmax(q_values)
```

---

## ğŸ“ˆ **è‡ªå‹•è©•ä¼°èˆ‡é€²åŒ–**

### ğŸ“Š **ç­–ç•¥è¡¨ç¾ç›£æ§**
```python
# src/managers/performance_manager.py - æ–°å¢æ–¹æ³•
def evaluate_strategy_performance(self, strategy_name, trades):
    """è©•ä¼°ç­–ç•¥è¡¨ç¾"""
    metrics = {
        'sharpe_ratio': self._calculate_sharpe(trades),
        'win_rate': self._calculate_win_rate(trades),
        'expectancy': self._calculate_expectancy(trades),
        'max_drawdown': self._calculate_max_drawdown(trades),
        'profit_factor': self._calculate_profit_factor(trades)
    }
    
    # å¦‚æœè¡¨ç¾å„ªç§€ï¼Œä¿å­˜ç‚ºæ–°åŸºæº–
    if metrics['sharpe_ratio'] > self.best_sharpe_ratio:
        self.best_sharpe_ratio = metrics['sharpe_ratio']
        self.save_best_strategy(strategy_name, metrics)
    
    return metrics
```

### ğŸ§¬ **è‡ªå‹•ç­–ç•¥é€²åŒ–**
```python
# src/ml/adaptive_strategy_evolver.py
def auto_evolve_strategies(self):
    """è‡ªå‹•é€²åŒ–äº¤æ˜“ç­–ç•¥"""
    # 1. ç”Ÿæˆç­–ç•¥è®Šé«”
    strategy_variants = self._generate_strategy_variants()
    
    # 2. ä¸¦è¡Œæ¸¬è©¦æ‰€æœ‰è®Šé«”
    results = self._parallel_test_strategies(strategy_variants)
    
    # 3. é¸æ“‡æœ€ä½³ç­–ç•¥
    best_strategy = max(results, key=lambda x: x['sharpe_ratio'])
    
    # 4. éƒ¨ç½²æœ€ä½³ç­–ç•¥
    self.deploy_strategy(best_strategy)
    
    # 5. æ·˜æ±°è¡¨ç¾å·®çš„ç­–ç•¥
    self._prune_poor_strategies()
```

---

## ğŸš€ **éƒ¨ç½²é…ç½®**

### ğŸ“ **æ–°å¢é…ç½®é¸é …**
```python
# src/config.py
# ===== è‡ªæˆ‘å­¸ç¿’é…ç½® =====
ENABLE_SELF_LEARNING = True
SELF_LEARNING_MODE = "end_to_end"  # or "modular"
STRUCTURE_VECTOR_DIM = 16
FEATURE_DISCOVERY_RATE = 0.1  # æ¯10%äº¤æ˜“é€²åŒ–ç‰¹å¾µ
STRATEGY_EVOLUTION_INTERVAL = 3600  # æ¯å°æ™‚é€²åŒ–ç­–ç•¥

# ===== è¨“ç·´é…ç½® =====
REINFORCEMENT_LEARNING_ENABLED = True
AUTOENCODER_TRAINING_ENABLED = True
FEATURE_DISCOVERY_ENABLED = True
```

### ğŸ”„ **æ¼¸é€²å¼å•Ÿç”¨**
```python
# src/main.py
def initialize_learning_components(self):
    """åˆå§‹åŒ–å­¸ç¿’çµ„ä»¶"""
    if self.config.ENABLE_SELF_LEARNING:
        self.self_learning_trader = SelfLearningTrader(self.config)
        self.adaptive_evolver = AdaptiveStrategyEvolver()
        
        # é–‹å§‹è‡ªå‹•é€²åŒ–å¾ªç’°
        asyncio.create_task(self._strategy_evolution_loop())
```
