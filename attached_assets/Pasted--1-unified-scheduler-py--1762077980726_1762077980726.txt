æ‚¨è¯´å¾—å¯¹ï¼æˆ‘ä»¬éœ€è¦æ‰¾åˆ°æ ¹æœ¬åŸå› ã€‚è®©æˆ‘ç”¨ä¸€ä¸ªç³»ç»Ÿæ€§çš„æ–¹æ³•æ¥æ‰¾å‡ºåˆ°åº•æ˜¯ä»€ä¹ˆå¯¼è‡´å¿«é€Ÿè·³è¿‡ã€‚

ğŸ” ç³»ç»Ÿæ€§æ ¹æœ¬åŸå› åˆ†æ

æ­¥éª¤1ï¼šæ·»åŠ å®Œæ•´çš„è°ƒç”¨é“¾è¿½è¸ª

åœ¨unified_scheduler.pyä¸­æ·»åŠ è°ƒç”¨é“¾è¿½è¸ªï¼š

```python
def scan_symbols(self):
    logger.info("ğŸ” ===== å¼€å§‹æ ¹æœ¬åŸå› åˆ†æ =====")
    
    # æµ‹è¯•ç¬¬ä¸€ä¸ªäº¤æ˜“å¯¹çš„å®Œæ•´æµç¨‹
    test_symbol = self.symbols[0]
    logger.info(f"ğŸ§ª æµ‹è¯•ç¬¦å·: {test_symbol}")
    
    # 1. æ£€æŸ¥æ•°æ®è·å–
    multi_tf_data = self.data_service.get_multi_timeframe_klines(test_symbol, self.timeframes)
    if not multi_tf_data:
        logger.error("âŒ æ ¹æœ¬åŸå› : æ•°æ®è·å–è¿”å›ç©º")
        return []
    
    # 2. ç›´æ¥è°ƒç”¨analyzeæ–¹æ³•å¹¶æ•è·å¼‚å¸¸
    try:
        logger.info("ğŸ“ è°ƒç”¨self_learning_trader.analyze...")
        signal, confidence, win_prob = self.self_learning_trader.analyze(test_symbol, multi_tf_data)
        logger.info(f"ğŸ“Š analyzeè¿”å›: signal={signal is not None}, confidence={confidence}, win_prob={win_prob}")
    except Exception as e:
        logger.error(f"âŒ analyzeæ–¹æ³•å¼‚å¸¸: {e}", exc_info=True)
        return []
    
    # 3. å¦‚æœè¿˜æ˜¯å¿«é€Ÿè¿”å›ï¼Œç›´æ¥æ·±å…¥ä¿¡å·ç”Ÿæˆå™¨
    if confidence == 0.0 and win_prob == 0.0:
        logger.info("ğŸš¨ æ£€æµ‹åˆ°å¿«é€Ÿè·³è¿‡ï¼Œæ·±å…¥è¯Šæ–­...")
        self._deep_diagnose_signal_generator(test_symbol, multi_tf_data)
    
    return []

def _deep_diagnose_signal_generator(self, symbol, multi_tf_data):
    """æ·±å…¥è¯Šæ–­ä¿¡å·ç”Ÿæˆå™¨"""
    logger.info("ğŸ”§ ===== æ·±å…¥ä¿¡å·ç”Ÿæˆå™¨è¯Šæ–­ =====")
    
    sg = self.self_learning_trader.signal_generator
    
    # æ£€æŸ¥ä¿¡å·ç”Ÿæˆå™¨çŠ¶æ€
    logger.info(f"ğŸ“¡ ä¿¡å·ç”Ÿæˆå™¨ç±»å‹: {type(sg).__name__}")
    logger.info(f"ğŸ”§ use_pure_ict: {getattr(sg, 'use_pure_ict', 'NOT_FOUND')}")
    logger.info(f"ğŸ”§ feature_engine: {getattr(sg, 'feature_engine', 'NOT_FOUND')}")
    
    # ç›´æ¥è°ƒç”¨generate_signalå¹¶æ•è·æ‰€æœ‰è¿”å›ç‚¹
    try:
        logger.info("ğŸ“ ç›´æ¥è°ƒç”¨generate_signal...")
        result = sg.generate_signal(symbol, multi_tf_data, "NEUTRAL")
        logger.info(f"ğŸ“Š generate_signalè¿”å›: {result}")
    except Exception as e:
        logger.error(f"âŒ generate_signalå¼‚å¸¸: {e}", exc_info=True)
```

æ­¥éª¤2ï¼šçŒ´å­è¡¥ä¸ - æ‹¦æˆªæ‰€æœ‰è¿”å›ç‚¹

åœ¨rule_based_signal_generator.pyçš„å¼€å¤´æ·»åŠ ï¼š

```python
# ä¸´æ—¶è¯Šæ–­ï¼šæ‹¦æˆªæ‰€æœ‰returnè¯­å¥
import inspect

def debug_return(return_value, caller_info):
    """è°ƒè¯•è¿”å›è¯­å¥"""
    logger.info(f"ğŸ” è¿”å›ç‚¹æ‹¦æˆª: {caller_info} -> {return_value}")
    return return_value

# çŒ´å­è¡¥ä¸generate_signalæ–¹æ³•
original_generate_signal = None

def debug_generate_signal(self, symbol, klines_data, market_structure="NEUTRAL"):
    logger.info(f"ğŸ¬ generate_signalå¼€å§‹: {symbol}")
    
    # æ•°æ®éªŒè¯æ£€æŸ¥ç‚¹1
    if not self._validate_klines_data(klines_data):
        logger.warning("âŒ å¿«é€Ÿè¿”å›ç‚¹1: _validate_klines_dataå¤±è´¥")
        return debug_return((None, 0.0, 0.0), "æ•°æ®éªŒè¯å¤±è´¥")
    
    # æå–æ•°æ®æ£€æŸ¥ç‚¹2  
    h1_data = klines_data.get('1h')
    m15_data = klines_data.get('15m')
    m5_data = klines_data.get('5m')
    if h1_data is None or m15_data is None or m5_data is None:
        logger.warning("âŒ å¿«é€Ÿè¿”å›ç‚¹2: å…³é”®æ—¶é—´æ¡†æ¶æ•°æ®ç¼ºå¤±")
        return debug_return((None, 0.0, 0.0), "æ—¶é—´æ¡†æ¶æ•°æ®ç¼ºå¤±")
    
    # æ–¹å‘åˆ¤æ–­æ£€æŸ¥ç‚¹3
    direction = self._determine_signal_direction(h1_data, m15_data, m5_data)
    if direction is None:
        logger.warning("âŒ å¿«é€Ÿè¿”å›ç‚¹3: æ— æ³•ç¡®å®šæ–¹å‘")
        return debug_return((None, 0.0, 0.0), "æ–¹å‘åˆ¤æ–­å¤±è´¥")
    
    logger.info(f"âœ… é€šè¿‡æ‰€æœ‰å¿«é€Ÿè¿”å›ç‚¹ï¼Œæ–¹å‘: {direction}")
    
    # ç»§ç»­åŸå§‹é€»è¾‘...
    return original_generate_signal(self, symbol, klines_data, market_structure)

# åº”ç”¨çŒ´å­è¡¥ä¸
import src.strategies.rule_based_signal_generator as rbsg
original_generate_signal = rbsg.RuleBasedSignalGenerator.generate_signal
rbsg.RuleBasedSignalGenerator.generate_signal = debug_generate_signal
```

æ­¥éª¤3ï¼šå…³é”®æ–¹æ³•è¯Šæ–­

åœ¨rule_based_signal_generator.pyä¸­æ·»åŠ å…³é”®æ–¹æ³•è¯Šæ–­ï¼š

```python
def _validate_klines_data(self, multi_tf_data):
    """å¸¦è¯¦ç»†è¯Šæ–­çš„æ•°æ®éªŒè¯"""
    logger.info("ğŸ” _validate_klines_dataå¼€å§‹")
    
    required_tfs = ['1h', '15m', '5m']
    for tf in required_tfs:
        if tf not in multi_tf_data:
            logger.error(f"âŒ éªŒè¯å¤±è´¥: ç¼ºå¤±æ—¶é—´æ¡†æ¶ {tf}")
            return False
        
        df = multi_tf_data[tf]
        if df is None:
            logger.error(f"âŒ éªŒè¯å¤±è´¥: {tf} æ•°æ®ä¸ºNone")
            return False
            
        if len(df) < 50:
            logger.error(f"âŒ éªŒè¯å¤±è´¥: {tf} åªæœ‰ {len(df)} è¡Œæ•°æ® (<50)")
            return False
            
        # æ£€æŸ¥å¿…è¦åˆ—
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            logger.error(f"âŒ éªŒè¯å¤±è´¥: {tf} ç¼ºå¤±åˆ— {missing_cols}")
            return False
    
    logger.info("âœ… _validate_klines_dataé€šè¿‡")
    return True

def _determine_signal_direction(self, h1_data, m15_data, m5_data):
    """å¸¦è¯¦ç»†è¯Šæ–­çš„æ–¹å‘åˆ¤æ–­"""
    logger.info("ğŸ” _determine_signal_directionå¼€å§‹")
    
    try:
        # è¿™é‡Œæ·»åŠ æ‚¨çš„æ–¹å‘åˆ¤æ–­é€»è¾‘
        # ä¸´æ—¶è¿”å›ä¸€ä¸ªå›ºå®šæ–¹å‘è¿›è¡Œæµ‹è¯•
        logger.info("ğŸ¯ æ–¹å‘åˆ¤æ–­: å¼ºåˆ¶è¿”å›LONGè¿›è¡Œæµ‹è¯•")
        return "LONG"
        
    except Exception as e:
        logger.error(f"âŒ æ–¹å‘åˆ¤æ–­å¼‚å¸¸: {e}")
        return None
```

æ­¥éª¤4ï¼šåˆ›å»ºæœ€å°åŒ–æµ‹è¯•

åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„æµ‹è¯•è„šæœ¬æ¥éš”ç¦»é—®é¢˜ï¼š

```python
# minimal_test.py
import logging
import sys
import os
sys.path.append(os.path.dirname(__file__))

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("MINIMAL_TEST")

def test_signal_generation():
    """æœ€å°åŒ–ä¿¡å·ç”Ÿæˆæµ‹è¯•"""
    logger.info("ğŸ§ª ===== æœ€å°åŒ–æµ‹è¯•å¼€å§‹ =====")
    
    try:
        from src.strategies.rule_based_signal_generator import RuleBasedSignalGenerator
        
        # åˆ›å»ºä¿¡å·ç”Ÿæˆå™¨å®ä¾‹
        logger.info("ğŸ“¦ åˆ›å»ºRuleBasedSignalGeneratorå®ä¾‹...")
        sg = RuleBasedSignalGenerator(use_pure_ict=True)
        
        logger.info(f"ğŸ”§ use_pure_ict: {sg.use_pure_ict}")
        logger.info(f"ğŸ”§ feature_engine: {sg.feature_engine is not None}")
        
        # åˆ›å»ºæ¨¡æ‹Ÿæ•°æ®
        import pandas as pd
        import numpy as np
        
        mock_data = {
            '1h': pd.DataFrame({
                'open': np.random.uniform(30000, 40000, 100),
                'high': np.random.uniform(30000, 40000, 100),
                'low': np.random.uniform(30000, 40000, 100),
                'close': np.random.uniform(30000, 40000, 100),
                'volume': np.random.uniform(1000, 5000, 100),
                'timestamp': pd.date_range('2024-01-01', periods=100, freq='1H')
            }),
            '15m': pd.DataFrame({
                'open': np.random.uniform(30000, 40000, 100),
                'high': np.random.uniform(30000, 40000, 100),
                'low': np.random.uniform(30000, 40000, 100),
                'close': np.random.uniform(30000, 40000, 100),
                'volume': np.random.uniform(1000, 5000, 100),
                'timestamp': pd.date_range('2024-01-01', periods=100, freq='15T')
            }),
            '5m': pd.DataFrame({
                'open': np.random.uniform(30000, 40000, 100),
                'high': np.random.uniform(30000, 40000, 100),
                'low': np.random.uniform(30000, 40000, 100),
                'close': np.random.uniform(30000, 40000, 100),
                'volume': np.random.uniform(1000, 5000, 100),
                'timestamp': pd.date_range('2024-01-01', periods=100, freq='5T')
            })
        }
        
        logger.info("ğŸ“Š æ¨¡æ‹Ÿæ•°æ®åˆ›å»ºå®Œæˆ")
        
        # æµ‹è¯•generate_signal
        logger.info("ğŸ¬ è°ƒç”¨generate_signal...")
        result = sg.generate_signal("BTCUSDT", mock_data, "NEUTRAL")
        
        logger.info(f"ğŸ“Š æµ‹è¯•ç»“æœ: {result}")
        
    except Exception as e:
        logger.error(f"âŒ æœ€å°åŒ–æµ‹è¯•å¤±è´¥: {e}", exc_info=True)

if __name__ == "__main__":
    test_signal_generation()
```

ğŸ¯ å®æ–½æ­¥éª¤

ç«‹å³æ‰§è¡Œè¿™ä¸ªè¯Šæ–­æ–¹æ¡ˆï¼š

1. é¦–å…ˆè¿è¡Œæœ€å°åŒ–æµ‹è¯•ï¼š
   ```bash
   python minimal_test.py
   ```
   è¿™ä¼šéš”ç¦»ç¯å¢ƒé—®é¢˜
2. å¦‚æœæœ€å°åŒ–æµ‹è¯•æ­£å¸¸ï¼š
   Â· é—®é¢˜åœ¨æ•°æ®æœåŠ¡æˆ–è°ƒåº¦å™¨
   Â· éƒ¨ç½²è°ƒç”¨é“¾è¿½è¸ª
3. å¦‚æœæœ€å°åŒ–æµ‹è¯•å¤±è´¥ï¼š
   Â· é—®é¢˜åœ¨ä¿¡å·ç”Ÿæˆå™¨æœ¬èº«
   Â· éƒ¨ç½²çŒ´å­è¡¥ä¸æ‹¦æˆª
4. æ ¹æ®æ‹¦æˆªç‚¹ä¿®å¤ï¼š
   Â· å¦‚æœ_validate_klines_dataå¤±è´¥ â†’ ä¿®å¤æ•°æ®éªŒè¯
   Â· å¦‚æœ_determine_signal_directionå¤±è´¥ â†’ ä¿®å¤æ–¹å‘åˆ¤æ–­
   Â· å¦‚æœFeatureEngineå¤±è´¥ â†’ ä¿®å¤ç‰¹å¾å¼•æ“

ğŸ“Š é¢„æœŸæ‰¾åˆ°çš„æ ¹æœ¬åŸå› 

é€šè¿‡è¿™ä¸ªç³»ç»Ÿæ€§è¯Šæ–­ï¼Œæˆ‘ä»¬å°†æ‰¾åˆ°ï¼š

Â· âœ… æ•°æ®éªŒè¯è¿‡äºä¸¥æ ¼ï¼ˆåˆ—åä¸åŒ¹é…ã€æ•°æ®é•¿åº¦è¦æ±‚ç­‰ï¼‰
Â· âœ… æ–¹å‘åˆ¤æ–­é€»è¾‘ç¼ºé™·ï¼ˆç«‹å³è¿”å›Noneï¼‰
Â· âœ… FeatureEngineåˆå§‹åŒ–é—®é¢˜ï¼ˆå¯¼å…¥å¤±è´¥ã€é…ç½®é”™è¯¯ï¼‰
Â· âœ… æ•°æ®æ ¼å¼ä¸å…¼å®¹ï¼ˆWebSocketæ•°æ®ä¸æœŸæœ›æ ¼å¼ä¸åŒ¹é…ï¼‰

è¯·ç«‹å³è¿è¡Œæœ€å°åŒ–æµ‹è¯•ï¼Œè¿™ä¼šç»™æˆ‘ä»¬åœ¨éš”ç¦»ç¯å¢ƒä¸­æ‰¾åˆ°æ ¹æœ¬åŸå› ï¼