åŸºæ–¼æ—¥èªŒåˆ†æï¼Œæˆ‘æä¾›ä¸€å€‹å®Œæ•´çš„ä¿®å¾©æ–¹æ¡ˆï¼š

ğŸš€ ç³»çµ±æ€§ä¿®å¾©æ–¹æ¡ˆ

éšæ®µä¸€ï¼šç«‹å³ä¿®å¾©ï¼ˆ0-24å°æ™‚ï¼‰

1. APIé€£æ¥ç©©å®šæ€§ä¿®å¾©

```python
# 1.1 å¢å¼·APIå®¢æˆ¶ç«¯é‡è©¦æ©Ÿåˆ¶
class EnhancedBinanceClient:
    def __init__(self):
        self.max_retries = 5
        self.base_delay = 1.0
        self.max_delay = 30.0
        
    async def _request_with_enhanced_retry(self, endpoint, params):
        for attempt in range(self.max_retries):
            try:
                return await self._do_request(endpoint, params)
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                if attempt == self.max_retries - 1:
                    raise
                delay = min(self.base_delay * (2 ** attempt), self.max_delay)
                await asyncio.sleep(delay + random.uniform(0, 0.1))

# 1.2 ä¿®å¾©WebSocketé€£æ¥ç®¡ç†
class RobustWebSocketManager:
    def __init__(self):
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.health_check_interval = 30
        
    async def maintain_connection(self):
        while True:
            try:
                if not self.is_connected():
                    await self.reconnect()
                await self.send_ping()
                await asyncio.sleep(self.health_check_interval)
            except Exception as e:
                logger.error(f"WebSocketç¶­è­·å¤±æ•—: {e}")
                await self.handle_connection_failure()
```

2. è¨‚å–®åŸ·è¡Œé‚è¼¯ä¿®å¾©

```python
# 2.1 ä¿®å¾©åç¾©åƒ¹å€¼è¨ˆç®—
class FixedOrderValidator:
    def __init__(self):
        self.MIN_NOTIONAL = 5.0
        self.SAFETY_MARGIN = 0.02  # 2%å®‰å…¨é‚Šéš›
        
    async def validate_and_adjust_order(self, symbol, quantity, price, side):
        # ç²å–äº¤æ˜“å°ç²¾åº¦ä¿¡æ¯
        symbol_info = await self.get_symbol_info(symbol)
        min_qty = symbol_info['min_qty']
        step_size = symbol_info['step_size']
        
        # è¨ˆç®—åç¾©åƒ¹å€¼
        notional = quantity * price
        
        if notional < self.MIN_NOTIONAL:
            # è¨ˆç®—éœ€è¦çš„æœ€å°æ•¸é‡ï¼ˆåŒ…å«å®‰å…¨é‚Šéš›ï¼‰
            required_qty = (self.MIN_NOTIONAL * (1 + self.SAFETY_MARGIN)) / price
            
            # æ ¹æ“šç²¾åº¦èª¿æ•´æ•¸é‡
            adjusted_qty = self.adjust_quantity_precision(required_qty, min_qty, step_size)
            
            # é‡æ–°è¨ˆç®—åç¾©åƒ¹å€¼
            new_notional = adjusted_qty * price
            
            if new_notional < self.MIN_NOTIONAL:
                # å¦‚æœä»ç„¶ä¸è¶³ï¼Œå†æ¬¡èª¿æ•´
                adjusted_qty += step_size
                new_notional = adjusted_qty * price
                
            logger.info(f"âœ… è¨‚å–®å·²èª¿æ•´: {quantity} â†’ {adjusted_qty} | åç¾©åƒ¹å€¼: {new_notional:.4f} USDT")
            return adjusted_qty, new_notional
        
        return quantity, notional
    
    def adjust_quantity_precision(self, quantity, min_qty, step_size):
        # ç¢ºä¿ä¸å°æ–¼æœ€å°æ•¸é‡
        quantity = max(quantity, min_qty)
        # æ ¹æ“šæ­¥é•·èª¿æ•´ç²¾åº¦
        precision = int(round(-math.log10(step_size)))
        return round(quantity - (quantity % step_size), precision)
```

3. æ•¸æ“šåº«ä¿®å¾©

```sql
-- 3.1 å‰µå»ºç¼ºå¤±çš„æ•¸æ“šè¡¨
CREATE TABLE IF NOT EXISTS position_entry_times (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,
    entry_time TIMESTAMP NOT NULL,
    position_side VARCHAR(10) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_position_entry_times_symbol ON position_entry_times(symbol);

-- 3.2 ä¿®å¾©äº¤æ˜“è¨˜éŒ„å‡½æ•¸
ALTER TABLE trade_records 
ADD COLUMN IF NOT EXISTS exit_price DECIMAL(20,8),
ADD COLUMN IF NOT EXISTS pnl DECIMAL(20,8),
ADD COLUMN IF NOT EXISTS pnl_pct DECIMAL(10,4);
```

éšæ®µäºŒï¼šæ ¸å¿ƒé‚è¼¯ä¿®å¾©ï¼ˆ24-48å°æ™‚ï¼‰

4. æŠ€è¡“æŒ‡æ¨™ç³»çµ±ä¿®å¾©

```python
# 4.1 ä¿®å¾©æŠ€è¡“æŒ‡æ¨™å¼•æ“
class FixedTechnicalEngine:
    def __init__(self):
        self.indicators_loaded = False
        
    async def initialize_indicators(self):
        try:
            # åŠ è¼‰æ‰€æœ‰å¿…è¦çš„æŠ€è¡“æŒ‡æ¨™
            await self._load_indicator_methods()
            self.indicators_loaded = True
        except Exception as e:
            logger.error(f"æŠ€è¡“æŒ‡æ¨™åˆå§‹åŒ–å¤±æ•—: {e}")
            raise
            
    def calculate_all_indicators(self, df):
        if not self.indicators_loaded:
            raise AttributeError("æŠ€è¡“æŒ‡æ¨™æœªåˆå§‹åŒ–ï¼Œè«‹å…ˆèª¿ç”¨initialize_indicators()")
            
        indicators = {}
        # SMA
        indicators['sma_20'] = ta.SMA(df['close'], 20)
        indicators['sma_50'] = ta.SMA(df['close'], 50)
        
        # RSI
        indicators['rsi_14'] = ta.RSI(df['close'], 14)
        
        # MACD
        macd = ta.MACD(df['close'])
        indicators['macd'] = macd['macd']
        indicators['macd_signal'] = macd['macdsignal']
        indicators['macd_hist'] = macd['macdhist']
        
        # Bollinger Bands
        bb = ta.BBANDS(df['close'])
        indicators['bb_upper'] = bb['upperband']
        indicators['bb_middle'] = bb['middleband']
        indicators['bb_lower'] = bb['lowerband']
        
        return indicators

# 4.2 ä¿®å¾©æ¨¡å‹åˆå§‹åŒ–
class FixedModelInitializer:
    async def calculate_new_samples(self):
        try:
            # æ·»åŠ JSONè§£æéŒ¯èª¤è™•ç†
            data = await self.fetch_training_data()
            if not data or data.strip() == '':
                logger.warning("è¨“ç·´æ•¸æ“šç‚ºç©º")
                return 0
                
            parsed_data = json.loads(data)
            return len(parsed_data.get('samples', []))
            
        except json.JSONDecodeError as e:
            logger.error(f"JSONè§£æå¤±æ•—: {e}, æ•¸æ“š: {data[:100] if data else 'None'}")
            return 0
        except Exception as e:
            logger.error(f"è¨ˆç®—æ–°æ¨£æœ¬æ•¸å¤±æ•—: {e}")
            return 0
```

5. æ­¢ææ­¢ç›ˆé‚è¼¯ä¿®å¾©

```python
# 5.1 å¢å¼·æ­¢ææ­¢ç›ˆè¨ˆç®—
class EnhancedRiskManager:
    def __init__(self):
        self.MIN_STOP_DISTANCE = 0.003  # 0.3%
        self.SAFE_STOP_MULTIPLIER = 1.5
        
    def calculate_stop_loss_take_profit(self, entry_price, direction, atr=None):
        if atr is None:
            # ä½¿ç”¨å›ºå®šç™¾åˆ†æ¯”ä½œç‚ºå‚™ç”¨
            stop_distance = max(self.MIN_STOP_DISTANCE, 
                               self.calculate_volatility_based_stop(entry_price))
        else:
            stop_distance = max(self.MIN_STOP_DISTANCE, atr * 1.5)
            
        if direction == 'LONG':
            stop_loss = entry_price * (1 - stop_distance)
            take_profit = entry_price * (1 + stop_distance * 2)  # 1:2é¢¨éšªå›å ±æ¯”
        else:
            stop_loss = entry_price * (1 + stop_distance)
            take_profit = entry_price * (1 - stop_distance * 2)
            
        # é©—è­‰æ­¢æè·é›¢
        if abs(stop_loss - entry_price) / entry_price < self.MIN_STOP_DISTANCE:
            stop_loss = self.apply_safe_stop_loss(entry_price, direction)
            logger.warning(f"âš ï¸ æ­¢æè·é›¢éå°ï¼Œä½¿ç”¨å®‰å…¨å€¼: {stop_loss}")
            
        return stop_loss, take_profit
    
    def apply_safe_stop_loss(self, entry_price, direction):
        safe_distance = self.MIN_STOP_DISTANCE * self.SAFE_STOP_MULTIPLIER
        if direction == 'LONG':
            return entry_price * (1 - safe_distance)
        else:
            return entry_price * (1 + safe_distance)
```

éšæ®µä¸‰ï¼šç³»çµ±å„ªåŒ–ï¼ˆ48-72å°æ™‚ï¼‰

6. ç†”æ–·å™¨å„ªåŒ–

```python
# 6.1 æ™ºèƒ½ç†”æ–·å™¨
class SmartCircuitBreaker:
    def __init__(self):
        self.failure_count = 0
        self.success_count = 0
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
        self.failure_threshold = 5
        self.success_threshold = 3
        self.timeout = 60
        
    async def call_async(self, func, *args, **kwargs):
        if self.state == 'OPEN':
            raise CircuitBreakerOpenError("ç†”æ–·å™¨é–‹å•Ÿ")
            
        try:
            result = await func(*args, **kwargs)
            self.record_success()
            return result
        except Exception as e:
            self.record_failure()
            
            # æ ¹æ“šéŒ¯èª¤é¡å‹èª¿æ•´ç­–ç•¥
            if isinstance(e, (aiohttp.ClientError, asyncio.TimeoutError)):
                self.adjust_for_network_issues()
            elif 'notional' in str(e):
                self.adjust_for_order_issues()
                
            raise
            
    def adjust_for_network_issues(self):
        # ç¶²çµ¡å•é¡Œæ™‚å¢åŠ è¶…æ™‚æ™‚é–“
        self.timeout = min(self.timeout * 1.5, 300)
        
    def adjust_for_order_issues(self):
        # è¨‚å–®å•é¡Œæ™‚é™ä½äº¤æ˜“é »ç‡
        self.failure_threshold = max(3, self.failure_threshold - 1)
```

7. ä¿¡è™Ÿç”Ÿæˆå„ªåŒ–

```python
# 7.1 ä¿¡å¿ƒåº¦è¨ˆç®—ä¿®å¾©
class ImprovedConfidenceCalculator:
    def calculate_confidence(self, technical_score, market_structure, order_blocks, liquidity):
        # æ­£è¦åŒ–æ‰€æœ‰è¼¸å…¥
        tech_norm = self.normalize(technical_score, 0, 100)
        structure_norm = self.normalize(market_structure, 0, 1)
        blocks_norm = self.normalize(order_blocks, 0, 10)
        liquidity_norm = self.normalize(liquidity, 0, 1)
        
        # åŠ æ¬Šè¨ˆç®—
        weights = {
            'technical': 0.4,
            'structure': 0.3,
            'order_blocks': 0.2,
            'liquidity': 0.1
        }
        
        confidence = (
            tech_norm * weights['technical'] +
            structure_norm * weights['structure'] +
            blocks_norm * weights['order_blocks'] +
            liquidity_norm * weights['liquidity']
        ) * 100
        
        # ç¢ºä¿ä¿¡å¿ƒåº¦åœ¨åˆç†ç¯„åœå…§
        return max(0, min(100, confidence))
    
    def normalize(self, value, min_val, max_val):
        if max_val == min_val:
            return 0
        return (value - min_val) / (max_val - min_val)
```

éšæ®µå››ï¼šç›£æ§å’Œæ¢å¾©ï¼ˆæŒçºŒé€²è¡Œï¼‰

8. å¢å¼·å¥åº·æª¢æŸ¥

```python
# 8.1 ç¶œåˆå¥åº·ç›£æ§
class ComprehensiveHealthMonitor:
    def __init__(self):
        self.checks = {
            'websocket': self.check_websocket_health,
            'api': self.check_api_health,
            'database': self.check_database_health,
            'memory': self.check_memory_usage,
            'orders': self.check_order_health
        }
        
    async def perform_health_check(self):
        results = {}
        for check_name, check_func in self.checks.items():
            try:
                results[check_name] = await check_func()
            except Exception as e:
                results[check_name] = {'status': 'ERROR', 'message': str(e)}
                
        critical_issues = [k for k, v in results.items() 
                          if v.get('status') == 'CRITICAL']
        
        if critical_issues:
            await self.alert_operations_team(critical_issues, results)
            
        return results
    
    async def check_websocket_health(self):
        connections = await self.get_websocket_connections()
        if len(connections) < self.expected_connections * 0.8:
            return {'status': 'CRITICAL', 'message': 'WebSocketé€£æ¥ä¸è¶³'}
        
        # æª¢æŸ¥é€£æ¥æ´»èºåº¦
        active_connections = [c for c in connections if c.is_active()]
        if len(active_connections) < len(connections) * 0.9:
            return {'status': 'WARNING', 'message': 'éƒ¨åˆ†WebSocketé€£æ¥ä¸æ´»èº'}
            
        return {'status': 'HEALTHY', 'message': 'WebSocketé€£æ¥æ­£å¸¸'}
```

9. éƒ¨ç½²å’Œé©—è­‰è…³æœ¬

```bash
#!/bin/bash
# complete_fix_deployment.sh

echo "é–‹å§‹éƒ¨ç½²å®Œæ•´ä¿®å¾©..."

# 1. å‚™ä»½ç•¶å‰ç³»çµ±
echo "å‚™ä»½ç•¶å‰ç³»çµ±..."
pg_dump trading_db > backup_$(date +%Y%m%d_%H%M%S).sql

# 2. æ‡‰ç”¨æ•¸æ“šåº«ä¿®å¾©
echo "æ‡‰ç”¨æ•¸æ“šåº«ä¿®å¾©..."
psql trading_db -f database_fixes.sql

# 3. éƒ¨ç½²ä¿®å¾©å¾Œçš„ä»£ç¢¼
echo "éƒ¨ç½²ä¿®å¾©ä»£ç¢¼..."
sudo systemctl stop trading_bot
git pull origin fix/branch
pip install -r requirements.txt

# 4. é‹è¡Œæ¸¬è©¦
echo "é‹è¡Œæ¸¬è©¦å¥—ä»¶..."
python -m pytest tests/ -v

# 5. å•Ÿå‹•æœå‹™
echo "å•Ÿå‹•æœå‹™..."
sudo systemctl start trading_bot
sudo systemctl status trading_bot

# 6. ç›£æ§æ—¥èªŒ
echo "é–‹å§‹ç›£æ§æ—¥èªŒ..."
tail -f /var/log/trading_bot.log | grep -E "(ERROR|WARNING|CRITICAL)"
```

éšæ®µäº”ï¼šé é˜²æªæ–½

10. é é˜²æ€§ç›£æ§

```python
# 10.1 é è­¦ç³»çµ±
class PreventiveAlertSystem:
    def __init__(self):
        self.metrics = {}
        self.thresholds = {
            'api_error_rate': 0.05,  # 5%
            'websocket_disconnects': 3,  # æ¯å°æ™‚
            'order_failure_rate': 0.1,  # 10%
            'memory_usage': 0.8  # 80%
        }
    
    async def monitor_and_prevent(self):
        while True:
            metrics = await self.collect_metrics()
            
            # æª¢æŸ¥è¶¨å‹¢
            for metric_name, value in metrics.items():
                if self.is_trending_badly(metric_name, value):
                    await self.take_preventive_action(metric_name)
                    
            await asyncio.sleep(300)  # æ¯5åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
            
    def is_trending_badly(self, metric_name, current_value):
        threshold = self.thresholds.get(metric_name)
        if not threshold:
            return False
            
        # æª¢æŸ¥æ˜¯å¦æ¥è¿‘é–¾å€¼
        if current_value > threshold * 0.8:  # é”åˆ°é–¾å€¼çš„80%
            return True
            
        # æª¢æŸ¥æƒ¡åŒ–è¶¨å‹¢
        historical = self.metrics.get(metric_name, [])
        if len(historical) >= 3:
            trend = self.calculate_trend(historical[-3:])
            if trend > 0.1:  # æ˜é¡¯ä¸Šå‡è¶¨å‹¢
                return True
                
        return False
```

é€™å€‹å®Œæ•´çš„ä¿®å¾©æ–¹æ¡ˆæ¶µè“‹äº†æ‰€æœ‰ç™¼ç¾çš„å•é¡Œï¼Œä¸¦æä¾›äº†å…·é«”çš„å¯¦ç¾ä»£ç¢¼ã€‚å»ºè­°æŒ‰éšæ®µé€æ­¥å¯¦æ–½ï¼Œæ¯å€‹éšæ®µå®Œæˆå¾Œé€²è¡Œå……åˆ†æ¸¬è©¦ï¼Œç¢ºä¿ç³»çµ±ç©©å®šæ€§ã€‚