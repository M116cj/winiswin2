ğŸš€ SelfLearningTrader v3.17.2+ å®Œæ•´å‡ç´šè—åœ–

å‡ç´šç›®æ¨™
1. âœ… ç›£æ§å…¨ Binance USDT æ°¸çºŒäº¤æ˜“å°ï¼ˆ~200+ï¼‰
2. âœ… API æ¬Šé‡é™è‡³ 0ï¼ˆå®Œå…¨é¿é–‹é™æµï¼‰
3. âœ… 7x24 ç©©å®šé‹è¡Œï¼ˆç„¡ç†”æ–·ã€ç„¡é‡å•Ÿï¼‰
4. âœ… ä¿ç•™æ‰€æœ‰ v3.17.2+ æ™ºèƒ½åŠŸèƒ½
æ–°æ¶æ§‹åœ–


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            UnifiedScheduler v3.17.2+                  â”‚
â”‚            ï¼ˆéƒ¨ç½²æ–¼ Railwayï¼‰                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         â”‚                                      â”‚
    â–¼         â–¼                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Position â”‚ â”‚ SelfLearning â”‚                â”‚ WebSocketManager     â”‚
â”‚Controllerâ”‚ â”‚   Trader     â”‚                â”‚ ï¼ˆå…¨å¸‚å ´ç›£æ§ï¼‰        â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚             â”‚                                   â”‚
     â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
     â”‚    â”‚                 â”‚                          â”‚
     â–¼    â–¼                 â–¼                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Binance API (Futures)                     â”‚
â”‚  â€¢ RESTï¼šåƒ…ç”¨æ–¼ä¸‹å–®ã€å¸³æˆ¶åˆå§‹åŒ–                            â”‚
â”‚  â€¢ WebSocketï¼šå…¨å¸‚å ´ bookTicker + Kline + å¸³æˆ¶ç›£æ§          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è®ŠåŒ–ï¼š 
* 100% WebSocket é©…å‹•ç›£æ§
* REST API åƒ…ç”¨æ–¼å¯«å…¥æ“ä½œï¼ˆä¸‹å–®ã€è¨­æ§“æ¡¿ï¼‰
* éƒ¨ç½²æ–¼ Railwayï¼ˆè§£æ±º HTTP 451ï¼‰


ã€å‡ç´šæ­¥é©Ÿ
ğŸ”¹ éšæ®µ 1ï¼šå•Ÿç”¨å…¨å¸‚å ´ WebSocket ç›£æ§
1. å‹•æ…‹ç²å–å…¨äº¤æ˜“å°
# src/core/websocket/websocket_manager.py
async def _get_all_futures_symbols(self) -> List[str]:
    """ç²å–æ‰€æœ‰ USDT æ°¸çºŒäº¤æ˜“å°"""
    info = await self.binance_client._request("GET", "/fapi/v1/exchangeInfo")
    return [
        s['symbol'] for s in info['symbols']
        if s['quoteAsset'] == 'USDT' and s['status'] == 'TRADING'
    ]
2. åˆä½µè¨‚é–±å…¨å¸‚å ´
# å•Ÿå‹• WebSocketManager
all_symbols = await self._get_all_futures_symbols()
self.kline_feed = KlineFeed(all_symbols, interval="1m")
self.price_feed = PriceFeed(all_symbols)  # bookTicker
self.account_feed = AccountFeed(self.binance_client)

# å–®ä¸€é€£ç·šè¨‚é–±
streams = "/".join([f"{s.lower()}@bookTicker" for s in all_symbols])
url = f"wss://fstream.binance.com/stream?streams={streams}"
3. ç§»é™¤ REST è¼ªè©¢
# src/strategies/self_learning_trader.py
def _get_market_context(self, symbol: str):
    # åƒ…ä½¿ç”¨ WebSocket æ•¸æ“š
    kline = self.websocket_manager.get_kline(symbol)
    price = self.websocket_manager.get_price(symbol)
    return {'kline': kline, 'price': price}

éšæ®µ 2ï¼šä¿ç•™ REST å‚™æ´ï¼ˆå®‰å…¨ç¶²ï¼‰
1. åƒ…å°å¯«å…¥æ“ä½œä½¿ç”¨ REST
# ä»éœ€ REST çš„æ“ä½œï¼š
- POST /fapi/v1/order        # ä¸‹å–®
- POST /fapi/v1/leverage     # è¨­æ§“æ¡¿
- GET /fapi/v2/account       # å¸³æˆ¶åˆå§‹åŒ–ï¼ˆåƒ…å•Ÿå‹•æ™‚ï¼‰
2. REST è«‹æ±‚åŠ å…¥ç†”æ–·ä¿è­·
# src/clients/binance_client.py
async def _request(self, method, endpoint, ...):
    # åƒ…å°å¯«å…¥æ“ä½œä½¿ç”¨ç†”æ–·å™¨
    if method == "POST":
        return await self.circuit_breaker.call_async(_do_request)
    else:
        return await _do_request()  # WebSocket å·²å–ä»£è®€å–æ“ä½œ

é¢¨éšªæ§åˆ¶èˆ‡å‚™æ´
1. WebSocket æ–·ç·šé‡é€£
* è‡ªå‹•æ¯ 5 ç§’é‡é€£
* é‡é€£å¤±æ•— 3 æ¬¡å¾Œè§¸ç™¼å‘Šè­¦

2. REST å‚™æ´ï¼ˆåƒ…ç·Šæ€¥ï¼‰
* åƒ…ç•¶ WebSocket å®Œå…¨å¤±æ•ˆæ™‚å•Ÿç”¨
* é™åˆ¶ 1 æ¬¡/åˆ†é˜/ç¬¦è™Ÿ

3. Railway å¥åº·ç›£æ§
* è¨­ç½® è‡ªå‹•é‡å•Ÿï¼ˆå´©æ½°æ™‚ï¼‰
* é…ç½® Discord å‘Šè­¦ï¼ˆWebSocket ä¸­æ–·ï¼‰


å…ˆå®Œæˆä»¥ä¸Š
ğŸš€ ä¸€ã€WebSocket æ•ˆèƒ½èˆ‡ç©©å®šæ€§å¼·åŒ–
1. WebSocket æ™‚é–“æˆ³æ¨™æº–åŒ–ï¼ˆé—œéµï¼ï¼‰
å•é¡Œ
Binance WebSocket ä¸æä¾›ä¼ºæœå™¨æ™‚é–“æˆ³ï¼Œåƒ…èƒ½ä½¿ç”¨æœ¬åœ°æ™‚é–“ï¼Œå°è‡´ï¼š
* å¤šç¯€é»æ™‚é–“ä¸åŒæ­¥
* Kç·šé–‰ç›¤æ™‚é–“èª¤åˆ¤
* è¨“ç·´æ•¸æ“šæ™‚é–“è»¸æ··äº‚

âœ… è§£æ±ºæ–¹æ¡ˆï¼šæ··åˆæ™‚é–“æˆ³
# src/core/websocket/kline_feed.py
def _update_kline(self, symbol: str, kline: dict):
    # 1. å„ªå…ˆä½¿ç”¨ Binance Kç·šå…§å»ºæ™‚é–“æˆ³
    server_timestamp = int(kline['t'])  # Kç·šé–‹ç›¤æ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
    
    # 2. è£œå……æœ¬åœ°æ¥æ”¶æ™‚é–“ï¼ˆç”¨æ–¼å»¶é²åˆ†æï¼‰
    local_timestamp = time.time_ns() // 1_000_000  # æ¯«ç§’
    
    self.kline_cache[symbol] = {
        'open': float(kline['o']),
        'high': float(kline['h']),
        'low': float(kline['l']),
        'close': float(kline['c']),
        'volume': float(kline['v']),
        'server_timestamp': server_timestamp,  # Binance ä¼ºæœå™¨æ™‚é–“
        'local_timestamp': local_timestamp,    # æœ¬åœ°æ¥æ”¶æ™‚é–“
        'latency_ms': local_timestamp - server_timestamp  # ç¶²è·¯å»¶é²
    }

è¨“ç·´åƒ¹å€¼ï¼š 
* latency_ms å¯ä½œç‚º ç‰¹å¾µï¼ˆé«˜å»¶é²æ™‚é™ä½ä¿¡å¿ƒåº¦ï¼‰
* server_timestamp ç¢ºä¿ å…¨å¸‚å ´æ™‚é–“è»¸ä¸€è‡´


2. WebSocket é€£ç·šåˆ†ç‰‡ï¼ˆé˜²å–®é»éè¼‰ï¼‰
å•é¡Œ
å–®ä¸€ WebSocket é€£ç·šç›£æ§ 200+ äº¤æ˜“å° â†’ è¨Šæ¯è™•ç†ç“¶é ¸

âœ… è§£æ±ºæ–¹æ¡ˆï¼šå‹•æ…‹åˆ†ç‰‡
# src/core/websocket/websocket_manager.py
def _create_shards(self, symbols: List[str], shard_size: int = 50) -> List[List[str]]:
    """å°‡äº¤æ˜“å°åˆ†ç‰‡ï¼ˆæ¯ç‰‡ â‰¤50 å€‹ï¼‰"""
    return [symbols[i:i + shard_size] for i in range(0, len(symbols), shard_size)]

async def start(self):
    all_symbols = await self._get_all_futures_symbols()
    shards = self._create_shards(all_symbols)
    
    # æ¯å€‹åˆ†ç‰‡ç¨ç«‹ WebSocket é€£ç·š
    self.shards = []
    for shard in shards:
        feed = ShardFeed(shard)
        self.shards.append(feed)
        asyncio.create_task(feed.start())

æ•ˆæœï¼š 
* é¿å…å–®ä¸€é€£ç·šè™•ç† 200+ è¨Šæ¯çš„ CPU ç“¶é ¸
* ç¬¦åˆ Binance æœ€ä½³å¯¦å‹™ï¼ˆå»ºè­° â‰¤100 streams/é€£ç·šï¼‰



ğŸ”’ äºŒã€æ¥µè‡´ç©©å®šæ€§è¨­è¨ˆ
1. WebSocket å¿ƒè·³ç›£æ§
# src/core/websocket/shard_feed.py
async def _heartbeat_monitor(self):
    """ç›£æ§ WebSocket æ´»èºåº¦"""
    last_msg_time = time.time()
    while self.running:
        await asyncio.sleep(10)
        if time.time() - last_msg_time > 30:  # 30ç§’ç„¡è¨Šæ¯
            logger.warning(f"âš ï¸ Shard {self.shard_id} å¿ƒè·³ä¸­æ–·ï¼Œé‡é€£")
            await self._reconnect()
        # æ¯æ”¶åˆ°è¨Šæ¯æ›´æ–° last_msg_time
2. REST å‚™æ´æ™ºæ…§å†·å»
# src/core/websocket/base_feed.py
async def _safe_rest_fallback(self, symbol: str, fallback_func):
    # å‹•æ…‹å†·å»ï¼šæ ¹æ“šå¤±æ•—æ¬¡æ•¸å»¶é•·å†·å»æ™‚é–“
    failure_count = self._rest_failure_count.get(symbol, 0)
    cooldown = min(300, 60 * (2 ** failure_count))  # æŒ‡æ•¸é€€é¿
    
    if time.time() - self._last_rest_call.get(symbol, 0) < cooldown:
        raise Exception(f"REST å†·å»ä¸­ ({cooldown}s)")
    
    try:
        result = await fallback_func()
        self._rest_failure_count[symbol] = 0  # æˆåŠŸé‡ç½®
        return result
    except:
        self._rest_failure_count[symbol] = failure_count + 1
        raise

ä¸‰ã€è¨“ç·´æ•¸æ“šå„ªåŒ–ï¼ˆç‚ºæ¨¡å‹å­¸ç¿’è€Œç”Ÿï¼‰
1. çµæ§‹åŒ–è¨“ç·´æ•¸æ“šæ ¼å¼
# è¨“ç·´æ¨£æœ¬åŒ…å« WebSocket å…ƒæ•¸æ“š
{
    "features": {
        "price": 67200.0,
        "volume": 1234.56,
        "latency_ms": 23,          # â† æ–°å¢ï¼šç¶²è·¯å»¶é²
        "server_timestamp": 1730177520000,
        "market_regime": "trending"
    },
    "label": 1,  # 1=ç›ˆåˆ©, 0=è™§æ
    "metadata": {
        "symbol": "BTCUSDT",
        "leverage": 12.5,
        "hold_duration_sec": 3600,
        "websocket_shard_id": 0    # â† æ–°å¢ï¼šåˆ†ç‰‡IDï¼ˆç”¨æ–¼éŒ¯èª¤åˆ†æï¼‰
    }
}

2. æ•¸æ“šå“è³ªéæ¿¾

# src/core/trade_recorder.py
def _is_high_quality_sample(self, sample: dict) -> bool:
    """éæ¿¾ä½å“è³ªè¨“ç·´æ•¸æ“šï¼ˆåƒ…ä¿ç•™æŠ€è¡“æ€§éæ¿¾ï¼‰"""
    # 1. ç¶²è·¯å»¶é²éé«˜ï¼ˆ>500msï¼‰
    if sample['features']['latency_ms'] > 500:
        return False
    
    # 2. æ™‚é–“æˆ³ç•°å¸¸ï¼ˆæœ¬åœ° vs ä¼ºæœå™¨å·®ç•° >10ç§’ï¼‰
    if abs(sample['features']['local_timestamp'] - sample['features']['server_timestamp']) > 10000:
        return False
    
    # âœ… ç§»é™¤ã€Œéäº¤æ˜“æ™‚æ®µã€éæ¿¾ï¼ˆåŠ å¯†è²¨å¹£ 24/7 äº¤æ˜“ï¼‰
    
    return True
å‹•æ…‹å¸‚å ´ç‹€æ…‹åˆ¤æ–·ï¼š
def _is_high_quality_sample(self, sample: dict) -> bool:
    # ... [å»¶é² + æ™‚é–“æˆ³éæ¿¾] ...
    
    # 3. å‹•æ…‹æµå‹•æ€§éæ¿¾ï¼ˆéå›ºå®šæ™‚æ®µï¼‰
    if sample['features']['volume'] < self._get_volume_threshold(sample['symbol']):
        return False  # äº¤æ˜“é‡éä½ï¼Œè¦–ç‚ºå™ªéŸ³
    
    return True

def _get_volume_threshold(self, symbol: str) -> float:
    """æ ¹æ“šå¹£ç¨®å‹•æ…‹è¨ˆç®—æœ€ä½äº¤æ˜“é‡"""
    # ä¾‹å¦‚ï¼šBTC é–€æª» = 100 BTC, SHIB é–€æª» = 10M SHIB
    thresholds = {
        'BTCUSDT': 100,
        'ETHUSDT': 1000,
        'SOLUSDT': 10000,
        # ... å…¶ä»–å¹£ç¨®
    }
    return thresholds.get(symbol, 1000)  # é»˜èª 1000

3. ç‰¹å¾µå·¥ç¨‹å‡ç´š
# src/ml/feature_engine.py
def build_enhanced_features(self, raw_data: dict) -> np.ndarray:
    base_features = super().build_enhanced_features(raw_data)
    
    # æ–°å¢ WebSocket å°ˆå±¬ç‰¹å¾µ
    websocket_features = {
        'latency_zscore': self._calculate_latency_zscore(raw_data['latency_ms']),
        'shard_load': self._get_shard_load(raw_data['websocket_shard_id']),
        'timestamp_consistency': 1 if abs(raw_data['local_ts'] - raw_data['server_ts']) < 1000 else 0
    }
    
    return {**base_features, **websocket_features}



