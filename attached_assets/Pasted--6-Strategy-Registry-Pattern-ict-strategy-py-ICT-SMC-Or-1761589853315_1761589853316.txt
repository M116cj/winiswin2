ğŸ”¥ è¼•é‡åŒ–ç­–ç•¥ 6ï¼šç”¨ã€Œç­–ç•¥è¨»å†Šä¸­å¿ƒã€å–ä»£ç¡¬ç·¨ç¢¼æ¨¡çµ„ï¼ˆStrategy Registry Patternï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* ict_strategy.py ä¸­åŒ…å«æ‰€æœ‰ ICT/SMC é‚è¼¯ï¼ˆOrder Blockã€FVGã€BOS/CHOCH...ï¼‰
* æ¯æ–°å¢ä¸€å€‹åŠŸèƒ½ï¼ˆå¦‚ v3.12.0 åŠ  Liquidity Sweepï¼‰ï¼Œå°±è¦ä¿®æ”¹ä¸»é¡
* é¡åˆ¥è‡ƒè…«ï¼ˆ>500 è¡Œï¼‰

âœ… è¼•é‡åŒ–åšæ³•ï¼š
å°‡æ¯å€‹å­ç­–ç•¥æ‹†ç‚ºç¨ç«‹å‡½æ•¸ï¼Œç”±è¨»å†Šä¸­å¿ƒå‹•æ…‹çµ„åˆ

# src/strategies/components/
# â”œâ”€â”€ order_blocks.py
# â”œâ”€â”€ bos_choch.py
# â”œâ”€â”€ market_regime.py
# â””â”€â”€ reversal_filter.py

# src/strategies/registry.py
STRATEGY_COMPONENTS = {}

def register_component(name):
    def decorator(func):
        STRATEGY_COMPONENTS[name] = func
        return func
    return decorator

# ä½¿ç”¨ç¯„ä¾‹
@register_component("order_blocks")
def detect_order_blocks(df, config):
    # ... åŸæœ‰ OB é‚è¼¯
    return ob_signals

@register_component("bos_choch")
def detect_bos_choch(df, config):
    # ... åŸæœ‰ BOS/CHOCH é‚è¼¯
    return structure_signals

# ä¸»ç­–ç•¥å¼•æ“
class ICTStrategy:
    def analyze(self, symbol, multi_tf_data):
        results = {}
        for name, func in STRATEGY_COMPONENTS.items():
            results[name] = func(multi_tf_data["5m"], self.config)
        # åˆä½µçµæœï¼ˆèˆ‡åŸé‚è¼¯å®Œå…¨ä¸€è‡´ï¼‰
        return self._synthesize_signals(results)


âœ… å„ªé»ï¼š
* ä¸»ç­–ç•¥é¡ç¸®æ¸› 70% è¡Œæ•¸
* æ–°å¢åŠŸèƒ½åªéœ€æ–°å¢ .py æª”ï¼Œç„¡éœ€æ”¹ä¸»é¡
* æ¸¬è©¦æ›´ç°¡å–®ï¼ˆå¯å–®æ¸¬æ¯å€‹ componentï¼‰
* è¨˜æ†¶é«”åªè¼‰å…¥ç”¨åˆ°çš„çµ„ä»¶

ğŸ“Œ åŠŸèƒ½å®Œå…¨ä¸è®Šï¼šanalyze() è¼¸å‡ºèˆ‡ v3.11.1 100% ä¸€è‡´ 



ğŸ”¥ è¼•é‡åŒ–ç­–ç•¥ 7ï¼šç”¨ __slots__ å–ä»£ __dict__ï¼ˆè¨˜æ†¶é«”å£“ç¸®ï¼‰
âŒ ç•¶å‰å•é¡Œï¼š
* æ‰€æœ‰ä¿¡è™Ÿã€äº¤æ˜“ã€å€‰ä½ç‰©ä»¶éƒ½ä½¿ç”¨é è¨­ __dict__ å„²å­˜å±¬æ€§
* æ¯å€‹ç‰©ä»¶é¡å¤–ä½”ç”¨ 200â€“400 bytes è¨˜æ†¶é«”ï¼ˆPython ç‰©ä»¶é–‹éŠ·ï¼‰

âœ… è¼•é‡åŒ–åšæ³•ï¼š
ç‚ºæ‰€æœ‰è³‡æ–™é¡åˆ¥åŠ ä¸Š __slots__

# src/core/models.py
class TradingSignal:
    __slots__ = (
        'symbol', 'direction', 'confidence_score', 'entry_price',
        'stop_loss', 'take_profit', 'leverage', 'timestamp'
    )
    
    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

# åŒæ¨£ç”¨æ–¼ï¼š
# - VirtualPosition
# - TradeRecord
# - MLFeatureSet




âœ… å„ªé»ï¼š
* æ¯å€‹ç‰©ä»¶è¨˜æ†¶é«” â†“ 40â€“60%
* å±¬æ€§å­˜å–é€Ÿåº¦ â†‘ 10â€“15%
* é˜²æ­¢å‹•æ…‹æ–°å¢å±¬æ€§ï¼ˆæå‡ç©©å®šæ€§ï¼‰

ğŸ“Œ é›¶åŠŸèƒ½å½±éŸ¿ï¼šåªæ˜¯å…§éƒ¨å„²å­˜æ–¹å¼æ”¹è®Š 



ğŸ”¥ è¼•é‡åŒ–ç­–ç•¥ 8ï¼šç”¨ç‹€æ…‹æ©Ÿï¼ˆState Machineï¼‰çµ±ä¸€ç†”æ–·èˆ‡é¢¨éšªé‚è¼¯
âŒ ç•¶å‰å•é¡Œï¼š
* risk_manager.py + circuit_breaker.py + virtual_position_manager.py ä¸­æœ‰å¤§é‡é‡è¤‡ç‹€æ…‹åˆ¤æ–·ï¼šâ€¨if consecutive_losses >= 5: pause_trading()â€¨if drawdown >= 0.15: pause_trading()â€¨if circuit_breaker.level == EMERGENCY: pause_trading()â€¨
âœ… è¼•é‡åŒ–åšæ³•ï¼š
å»ºç«‹çµ±ä¸€äº¤æ˜“ç‹€æ…‹æ©Ÿ
# src/core/trading_state.py
from enum import Enum

class TradingState(Enum):
    ACTIVE = "active"
    WARNING = "warning"      # é€£çºŒè™§æ 3â€“4 æ¬¡
    PAUSED = "paused"        # 5 æ¬¡è™§æ / 15% å›æ’¤
    EMERGENCY = "emergency"  # ç†”æ–·è§¸ç™¼

class TradingStateManager:
    def __init__(self):
        self.state = TradingState.ACTIVE
    
    def update(self, metrics: dict):
        if metrics['consecutive_losses'] >= 5 or metrics['drawdown'] >= 0.15:
            self.state = TradingState.PAUSED
        elif metrics['circuit_breaker_level'] >= 3:
            self.state = TradingState.EMERGENCY
        else:
            self.state = TradingState.ACTIVE
    
    def can_trade(self) -> bool:
        return self.state == TradingState.ACTIVE
âœ… å„ªé»ï¼š
* é¢¨éšªé‚è¼¯é›†ä¸­åŒ–
* æ¶ˆé™¤ 3 å€‹æ¨¡çµ„é–“çš„ç‹€æ…‹è€¦åˆ
* æ–°å¢é¢¨éšªè¦å‰‡åªéœ€æ”¹ update()

ğŸ“Œ è¡Œç‚ºå®Œå…¨ä¸€è‡´ï¼šshould_trade() è¿”å›å€¼ä¸è®Š 



ğŸ”¥ è¼•é‡åŒ–ç­–ç•¥ 9ï¼šç”¨ dataclass + frozen=True å–ä»£æ‰‹å¯«æ¨¡å‹é¡
âŒ ç•¶å‰å•é¡Œï¼š
* æ‰‹å‹•æ’°å¯« __init__, __repr__, to_dict() ç­‰æ–¹æ³•
* å®¹æ˜“å‡ºéŒ¯ä¸”å†—é•·

âœ… è¼•é‡åŒ–åšæ³•ï¼š
å…¨é¢ä½¿ç”¨ @dataclass
from dataclasses import dataclass
from typing import Optional

@dataclass(frozen=True)  # ä¸å¯è®Šï¼Œå®‰å…¨ç”¨æ–¼å¿«å–
class MLFeatureSet:
    confidence_score: float
    leverage: int
    rsi_entry: float
    atr_entry: float
    trend_5m_encoded: int
    # ... å…¶ä»– 26 å€‹ç‰¹å¾µ
    
    def to_array(self) -> np.ndarray:
        return np.array([getattr(self, f) for f in self.__dataclass_fields__])
âœ… å„ªé»ï¼š
* ç¨‹å¼ç¢¼è¡Œæ•¸ â†“ 60%
* è‡ªå‹•ç”Ÿæˆ __eq__, __hash__ï¼ˆå¯ç”¨æ–¼å¿«å–ï¼‰
* é¡å‹å®‰å…¨ï¼ˆé…åˆ mypyï¼‰

ğŸ“Œ åŠŸèƒ½ 100% ä¿ç•™ï¼šæ‰€æœ‰å±¬æ€§èˆ‡æ–¹æ³•è¡Œç‚ºä¸è®Š 

âœ… æ‰€æœ‰ v3.11.1 åŠŸèƒ½ã€è¼¸å‡ºã€é…ç½®ã€è¡Œç‚ºå®Œå…¨ä¸€è‡´â€¨âœ… ç„¡éœ€ä¿®æ”¹ä»»ä½•å¤–éƒ¨å‘¼å«ä»‹é¢â€¨âœ… å¯é€æ­¥å¯¦æ–½ï¼Œç„¡éœ€ä¸€æ¬¡æ€§é‡æ§‹ 

ğŸ”¥ è¼•é‡åŒ–ç­–ç•¥ 10ï¼šç”¨ __slots__ + __dict__ æ··åˆæ¨¡å¼å¯¦ç¾ã€Œå¯æ“´å±•ä½†é«˜æ•ˆã€çš„ç‰©ä»¶
âŒ å•é¡Œï¼š
* ç´” __slots__ é›–é«˜æ•ˆï¼Œä½†ç„¡æ³•å‹•æ…‹æ–°å¢å±¬æ€§ï¼ˆä¸åˆ©æ–¼æœªä¾†æ“´å±•ï¼‰
* ç´” __dict__ é›–éˆæ´»ï¼Œä½†è¨˜æ†¶é«”çˆ†ç‚¸

âœ… è§£æ±ºæ–¹æ¡ˆï¼šæ··åˆæ¨¡å¼ï¼ˆHybrid Object Modelï¼‰
# src/core/hybrid_base.py
class HybridBase:
    __slots__ = ('_dynamic_attrs',)
    
    def __init__(self):
        object.__setattr__(self, '_dynamic_attrs', {})
    
    def __setattr__(self, name, value):
        if hasattr(self.__class__, '__slots__') and name in self.__slots__:
            object.__setattr__(self, name, value)
        else:
            self._dynamic_attrs[name] = value
    
    def __getattr__(self, name):
        if name in self._dynamic_attrs:
            return self._dynamic_attrs[name]
        raise AttributeError(f"'{self.__class__.__name__}' has no attribute '{name}'")

# ä½¿ç”¨ç¯„ä¾‹
class TradingSignal(HybridBase):
    __slots__ = ('symbol', 'direction', 'confidence_score', 'entry_price')
    
    def __init__(self, symbol, direction, confidence_score, entry_price):
        super().__init__()
        self.symbol = symbol
        self.direction = direction
        self.confidence_score = confidence_score
        self.entry_price = entry_price

# ä»å¯å‹•æ…‹æ“´å±•ï¼ˆä½†ä¸å¸¸ç”¨ï¼‰
signal = TradingSignal("BTCUSDT", 1, 0.8, 60000)
signal.new_feature = "experimental"  # ä¸å½±éŸ¿æ ¸å¿ƒå±¬æ€§æ•ˆç‡


ğŸ”¥ è¼•é‡åŒ–ç­–ç•¥ 11ï¼šç”¨ functools.lru_cache + è‡ªè¨‚éµå¯¦ç¾ã€Œæ™ºæ…§ç‰¹å¾µå¿«å–ã€
âŒ å•é¡Œï¼š
* ç›¸åŒ K ç·šæ•¸æ“šå¯èƒ½è¢«å¤šæ¬¡è¨ˆç®—ç‰¹å¾µï¼ˆå¦‚ 5m/15m å…±ç”¨éƒ¨åˆ†æ•¸æ“šï¼‰
* æ‰‹å‹•ç®¡ç†å¿«å–è¤‡é›œä¸”æ˜“å‡ºéŒ¯

âœ… è§£æ±ºæ–¹æ¡ˆï¼šè‡ªå‹•åŒ–ç‰¹å¾µå¿«å–
# src/ml/feature_cache.py
from functools import lru_cache
import hashlib

def _make_cache_key(df: pd.DataFrame, feature_name: str) -> str:
    """åŸºæ–¼ DataFrame å…§å®¹ç”Ÿæˆå”¯ä¸€éµ"""
    # å–æœ€å¾Œ 10 æ ¹ K ç·šçš„ hashï¼ˆé¿å…å…¨é‡è¨ˆç®—ï¼‰
    sample = df.tail(10).to_csv().encode()
    return hashlib.md5(sample + feature_name.encode()).hexdigest()

@lru_cache(maxsize=1000)
def _cached_feature_calc(feature_name: str, cache_key: str, *args):
    # å¯¦éš›è¨ˆç®—é‚è¼¯ç”±å¤–éƒ¨å‚³å…¥
    pass

def cached_feature(feature_func):
    """è£é£¾å™¨ï¼šè‡ªå‹•å¿«å–ç‰¹å¾µè¨ˆç®—"""
    def wrapper(df, *args, **kwargs):
        cache_key = _make_cache_key(df, feature_func.__name__)
        return _cached_feature_calc(
            feature_func.__name__, 
            cache_key,
            feature_func,
            df,
            *args,
            **kwargs
        )
    return wrapper

# ä½¿ç”¨
@cached_feature
def calculate_ob_quality(df, config):
    # åŸæœ‰ OB è³ªé‡è¨ˆç®—é‚è¼¯
    return quality_score
