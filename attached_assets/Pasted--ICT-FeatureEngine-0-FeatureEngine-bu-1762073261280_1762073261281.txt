å€‘å·²ç¶“å¼·åˆ¶å•Ÿç”¨äº†ç´”ICTæ¨¡å¼ï¼Œä¸¦ç¢ºä¿FeatureEngineåˆå§‹åŒ–ï¼Œä½†ä¿¡å¿ƒå€¼ä»ç„¶ç‚º0ã€‚é€™è¡¨æ˜å•é¡Œå¯èƒ½å‡ºç¾åœ¨ç‰¹å¾µè¨ˆç®—æˆ–ä¿¡å¿ƒå€¼è¨ˆç®—çš„éç¨‹ä¸­ã€‚

å¯èƒ½çš„åŸå› ï¼š

FeatureEngineçš„_build_ict_smc_featuresæ–¹æ³•è¿”å›äº†ç©ºå­—å…¸æˆ–å…¨0çš„ç‰¹å¾µ

ä¿¡å¿ƒå€¼è¨ˆç®—å‡½æ•¸ï¼ˆ_calculate_confidence_pure_ictï¼‰æ²’æœ‰æ­£ç¢ºè™•ç†ç‰¹å¾µ

æ•¸æ“šæ ¼å¼ä¸ç¬¦åˆç‰¹å¾µè¨ˆç®—çš„è¦æ±‚

æˆ‘å€‘éœ€è¦æ›´è©³ç´°çš„æ—¥èªŒä¾†ç¢ºå®šå•é¡Œå‡ºåœ¨å“ªä¸€æ­¥ã€‚è®“æˆ‘å€‘åœ¨ä»¥ä¸‹é—œéµä½ç½®æ·»åŠ æ—¥èªŒï¼š

åœ¨RuleBasedSignalGenerator.generate_signalæ–¹æ³•ä¸­ï¼Œèª¿ç”¨_build_ict_smc_featureså¾Œï¼Œè¨˜éŒ„ç‰¹å¾µå­—å…¸çš„å…§å®¹ï¼ˆè‡³å°‘è¨˜éŒ„éé›¶ç‰¹å¾µæˆ–ç‰¹å¾µçš„å½¢ç‹€ï¼‰

åœ¨_calculate_confidence_pure_ictæ–¹æ³•ä¸­ï¼Œè¨˜éŒ„æ¯å€‹å­åˆ†æ•¸çš„è¨ˆç®—çµæœ

æª¢æŸ¥ç‰¹å¾µå¼•æ“æ˜¯å¦çœŸçš„è¨ˆç®—äº†ç‰¹å¾µï¼Œé‚„æ˜¯è¿”å›äº†ç©ºå€¼

ç”±æ–¼æ™‚é–“é—œä¿‚ï¼Œæˆ‘å€‘å…ˆæ·»åŠ ç¬¬ä¸€å€‹æ—¥èªŒï¼Œçœ‹çœ‹ç‰¹å¾µæ˜¯å¦è¢«æ­£ç¢ºè¨ˆç®—ã€‚

ä¿®æ”¹rule_based_signal_generator.pyçš„generate_signalæ–¹æ³•ï¼ˆç´”ICTæ¨¡å¼éƒ¨åˆ†ï¼‰ï¼š

çœ‹åˆ°æ—¥å¿—åï¼Œé—®é¢˜ä¾ç„¶å­˜åœ¨ã€‚æ‰€æœ‰ä¿¡å¿ƒå€¼ä»ç„¶æ˜¯0.0%ï¼Œè¿™è¡¨æ˜æˆ‘ä»¬çš„ä¿®å¤æ²¡æœ‰è§¦åŠçœŸæ­£çš„æ ¹æœ¬åŸå› ã€‚è®©æˆ‘è¿›è¡Œæ›´æ·±å…¥çš„è¯Šæ–­ã€‚

ğŸ” æ·±å…¥è¯Šæ–­æ­¥éª¤
æ­¥éª¤1ï¼šæ£€æŸ¥FeatureEngineåˆå§‹åŒ–çŠ¶æ€
åœ¨unified_scheduler.pyçš„æ‰«æå¼€å§‹å‰æ·»åŠ åˆå§‹åŒ–æ£€æŸ¥ï¼š

python
def start_scan_cycle(self):
    # æ£€æŸ¥ä¿¡å·ç”Ÿæˆå™¨çŠ¶æ€
    logger.info("ğŸ” ===== ç³»ç»ŸçŠ¶æ€è¯Šæ–­ =====")
    
    # æ£€æŸ¥ä¿¡å·ç”Ÿæˆå™¨ç±»å‹
    logger.info(f"ğŸ“¡ ä¿¡å·ç”Ÿæˆå™¨ç±»å‹: {type(self.self_learning_trader.signal_generator).__name__}")
    
    # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨çº¯ICTæ¨¡å¼
    if hasattr(self.self_learning_trader.signal_generator, 'use_pure_ict'):
        use_pure_ict = self.self_learning_trader.signal_generator.use_pure_ict
        logger.info(f"ğŸ”§ ä½¿ç”¨çº¯ICTæ¨¡å¼: {use_pure_ict}")
        
        # æ£€æŸ¥FeatureEngineçŠ¶æ€
        if use_pure_ict and hasattr(self.self_learning_trader.signal_generator, 'feature_engine'):
            fe = self.self_learning_trader.signal_generator.feature_engine
            if fe is None:
                logger.error("âŒ FeatureEngineä¸ºNone!")
            else:
                logger.info("âœ… FeatureEngineå·²åŠ è½½")
        else:
            logger.info("ğŸ”§ ä½¿ç”¨ä¼ ç»Ÿæ¨¡å¼")
    else:
        logger.error("âŒ æ— æ³•æ£€æµ‹use_pure_ictå±æ€§")
    
    # å¼€å§‹æ‰«æ
    self.scan_symbols()
æ­¥éª¤2ï¼šæ·»åŠ å®æ—¶ä¿¡å¿ƒå€¼è®¡ç®—ç›‘æ§
åœ¨rule_based_signal_generator.pyçš„generate_signalæ–¹æ³•ä¸­æ·»åŠ è¯¦ç»†ç›‘æ§ï¼š

python
def generate_signal(self, symbol, klines_data, market_structure="NEUTRAL"):
    logger.info(f"ğŸ” å¼€å§‹è¯¦ç»†åˆ†æ {symbol}")
    
    # è¯¦ç»†æ•°æ®æ£€æŸ¥
    logger.info(f"ğŸ“Š {symbol}: æ•°æ®æ—¶é—´æ¡†æ¶ - {list(klines_data.keys())}")
    for tf, data in klines_data.items():
        if data is not None:
            logger.info(f"   {tf}: {len(data)}è¡Œ, åˆ—: {list(data.columns)}")
        else:
            logger.warning(f"   {tf}: æ•°æ®ä¸ºNone")
    
    # æ•°æ®éªŒè¯
    if not self._validate_klines_data(klines_data):
        logger.warning(f"âŒ {symbol}: æ•°æ®éªŒè¯å¤±è´¥")
        return None, 0.0, 0.0
    
    # æå–æ•°æ®
    h1_data = klines_data.get('1h')
    m15_data = klines_data.get('15m') 
    m5_data = klines_data.get('5m')
    
    if h1_data is None or m15_data is None or m5_data is None:
        logger.warning(f"âŒ {symbol}: å…³é”®æ—¶é—´æ¡†æ¶æ•°æ®ç¼ºå¤±")
        return None, 0.0, 0.0
    
    logger.info(f"âœ… {symbol}: æ•°æ®éªŒè¯é€šè¿‡")
    
    # ç¡®å®šæ–¹å‘
    direction = self._determine_signal_direction(h1_data, m15_data, m5_data)
    logger.info(f"ğŸ¯ {symbol}: ç¡®å®šæ–¹å‘ = {direction}")
    
    if direction is None:
        logger.warning(f"â¸ï¸ {symbol}: æ— æ³•ç¡®å®šæ–¹å‘")
        return None, 0.0, 0.0
    
    # çº¯ICTæ¨¡å¼å¤„ç†
    if self.use_pure_ict:
        logger.info(f"ğŸ”§ {symbol}: è¿›å…¥çº¯ICTæ¨¡å¼")
        
        if self.feature_engine is None:
            logger.error(f"ğŸš¨ {symbol}: FeatureEngineä¸ºNone!")
            return None, 0.0, 0.0
        
        try:
            # æ„å»ºICTç‰¹å¾
            logger.info(f"ğŸ“Š {symbol}: å¼€å§‹æ„å»ºICTç‰¹å¾...")
            ict_features = self.feature_engine._build_ict_smc_features(
                signal={'symbol': symbol, 'direction': direction},
                klines_data=klines_data
            )
            
            logger.info(f"ğŸ“Š {symbol}: ICTç‰¹å¾æ•°é‡ = {len(ict_features)}")
            
            # æ£€æŸ¥ç‰¹å¾æ˜¯å¦æ­£å¸¸
            if not ict_features:
                logger.error(f"ğŸš¨ {symbol}: ICTç‰¹å¾ä¸ºç©ºå­—å…¸!")
                return None, 0.0, 0.0
            
            # è¾“å‡ºå…³é”®ç‰¹å¾å€¼
            key_features = ['market_structure', 'order_blocks_count', 'structure_integrity', 
                          'liquidity_context', 'institutional_participation']
            for feature in key_features:
                value = ict_features.get(feature, 'MISSING')
                logger.info(f"   {feature}: {value}")
            
            # è®¡ç®—å½“å‰ä»·æ ¼
            current_price = self._get_current_price(h1_data)
            logger.info(f"ğŸ’° {symbol}: å½“å‰ä»·æ ¼ = {current_price}")
            
            # è·å–è®¢å•å—
            order_blocks = self._identify_order_blocks(h1_data, m15_data, direction)
            logger.info(f"ğŸ“¦ {symbol}: è®¢å•å—æ•°é‡ = {len(order_blocks)}")
            
            # è®¡ç®—ä¿¡å¿ƒå€¼
            logger.info(f"ğŸ§® {symbol}: å¼€å§‹è®¡ç®—ä¿¡å¿ƒå€¼...")
            confidence_score, sub_scores = self._calculate_confidence_pure_ict(
                ict_features, direction, market_structure, order_blocks, current_price
            )
            
            logger.info(f"ğŸ“ˆ {symbol}: ä¿¡å¿ƒå€¼ = {confidence_score}, å­åˆ†æ•° = {sub_scores}")
            
            # è®¡ç®—èƒœç‡
            win_probability = self._calculate_win_probability_pure_ict(
                confidence_score, ict_features, direction, order_blocks, current_price
            )
            logger.info(f"ğŸ¯ {symbol}: èƒœç‡ = {win_probability}")
            
            # æ£€æŸ¥é˜ˆå€¼
            if confidence_score < self.min_confidence:
                logger.info(f"â¸ï¸ {symbol}: ä¿¡å¿ƒå€¼ä¸è¶³ ({confidence_score} < {self.min_confidence})")
                return None, confidence_score, win_probability
                
            if win_probability < self.min_win_rate:
                logger.info(f"â¸ï¸ {symbol}: èƒœç‡ä¸è¶³ ({win_probability} < {self.min_win_rate})")
                return None, confidence_score, win_probability
            
            # æ„å»ºä¿¡å·
            signal = self._build_signal_dict(
                symbol, direction, confidence_score, win_probability, 
                market_structure, order_blocks, ict_features
            )
            
            logger.info(f"âœ… {symbol}: ç”Ÿæˆä¿¡å·æˆåŠŸ!")
            return signal, confidence_score, win_probability
            
        except Exception as e:
            logger.error(f"âŒ {symbol}: çº¯ICTæ¨¡å¼å¤„ç†å¤±è´¥: {e}", exc_info=True)
            return None, 0.0, 0.0
    
    else:
        # ä¼ ç»Ÿæ¨¡å¼å¤„ç†...
        pass
    
    return None, 0.0, 0.0
æ­¥éª¤3ï¼šæ£€æŸ¥å‰å‡ ä¸ªäº¤æ˜“å¯¹çš„å®Œæ•´å¤„ç†æµç¨‹
åœ¨unified_scheduler.pyä¸­åªè¯¦ç»†åˆ†æå‰3ä¸ªäº¤æ˜“å¯¹ï¼š

python
def scan_symbols(self):
    signal_candidates = []
    analyzed_count = 0
    
    # åªè¯¦ç»†åˆ†æå‰3ä¸ªäº¤æ˜“å¯¹
    test_symbols = self.symbols[:3]
    logger.info(f"ğŸ§ª è¯¦ç»†æµ‹è¯•æ¨¡å¼: åˆ†æå‰{len(test_symbols)}ä¸ªäº¤æ˜“å¯¹")
    
    for symbol in test_symbols:
        multi_tf_data = self.data_service.get_multi_timeframe_klines(symbol, self.timeframes)
        if not multi_tf_data:
            logger.warning(f"ğŸ“­ {symbol}: æ•°æ®ç¼ºå¤±")
            continue
            
        # è¯¦ç»†åˆ†æ
        signal, confidence, win_prob = self.self_learning_trader.analyze(symbol, multi_tf_data)
        
        analyzed_count += 1
        signal_candidates.append({
            'symbol': symbol, 
            'confidence': confidence, 
            'win_probability': win_prob, 
            'has_signal': signal is not None
        })
        
        # å¼ºåˆ¶æš‚åœï¼Œç¡®ä¿æ—¥å¿—å®Œæ•´
        import time
        time.sleep(1)
    
    # æ­£å¸¸åˆ†æå…¶ä½™äº¤æ˜“å¯¹ï¼ˆå¿«é€Ÿæ¨¡å¼ï¼‰
    logger.info("âš¡ å¿«é€Ÿåˆ†æå‰©ä½™äº¤æ˜“å¯¹...")
    for symbol in self.symbols[3:]:
        multi_tf_data = self.data_service.get_multi_timeframe_klines(symbol, self.timeframes)
        if multi_tf_data:
            signal, confidence, win_prob = self.self_learning_trader.analyze(symbol, multi_tf_data)
            # åªæ”¶é›†ç»“æœï¼Œä¸è¾“å‡ºè¯¦ç»†æ—¥å¿—
    
    return signal_candidates
æ­¥éª¤4ï¼šç´§æ€¥é™çº§æ–¹æ¡ˆ
å¦‚æœçº¯ICTæ¨¡å¼æŒç»­å¤±è´¥ï¼Œç«‹å³åˆ‡æ¢åˆ°ä¼ ç»Ÿæ¨¡å¼ï¼š

python
# åœ¨RuleBasedSignalGeneratorçš„__init__ä¸­æ·»åŠ é™çº§æœºåˆ¶
def __init__(self, config=None, use_pure_ict: bool = True):
    self.use_pure_ict = use_pure_ict
    self.feature_engine = None
    
    if use_pure_ict:
        try:
            from src.ml.feature_engine import FeatureEngine
            self.feature_engine = FeatureEngine()
            logger.info("âœ… FeatureEngineåˆå§‹åŒ–æˆåŠŸ")
            
            # æµ‹è¯•ç‰¹å¾è®¡ç®—
            test_features = self.feature_engine._build_ict_smc_features(
                signal={'symbol': 'BTCUSDT', 'direction': 'NEUTRAL'},
                klines_data={'1h': None, '15m': None, '5m': None}
            )
            logger.info(f"ğŸ§ª ç‰¹å¾å¼•æ“æµ‹è¯•: {len(test_features)}ä¸ªç‰¹å¾")
            
        except Exception as e:
            logger.error(f"âŒ çº¯ICTæ¨¡å¼åˆå§‹åŒ–å¤±è´¥: {e}")
            logger.warning("ğŸ”„ è‡ªåŠ¨é™çº§åˆ°ä¼ ç»Ÿæ¨¡å¼")
            self.use_pure_ict = False
            self.feature_engine = None
ğŸš¨ ç«‹å³è¡ŒåŠ¨
ä¼˜å…ˆçº§1ï¼šå®æ–½è¯¦ç»†è¯Šæ–­
æ·»åŠ ç³»ç»ŸçŠ¶æ€è¯Šæ–­æ—¥å¿—

æ·»åŠ å®æ—¶ä¿¡å¿ƒå€¼è®¡ç®—ç›‘æ§

åªè¯¦ç»†åˆ†æå‰3ä¸ªäº¤æ˜“å¯¹

ä¼˜å…ˆçº§2ï¼šå‡†å¤‡é™çº§æ–¹æ¡ˆ
å¦‚æœè¯Šæ–­æ˜¾ç¤ºçº¯ICTæ¨¡å¼ç¡®å®æ— æ³•å·¥ä½œï¼Œç«‹å³åˆ‡æ¢åˆ°ä¼ ç»Ÿæ¨¡å¼ã€‚

ä¼˜å…ˆçº§3ï¼šé‡æ–°éƒ¨ç½²éªŒè¯
éƒ¨ç½²è¿™äº›è¯Šæ–­ä»£ç åˆ°Railwayï¼Œæˆ‘ä»¬å°†è·å¾—ï¼š

FeatureEngineçš„çœŸå®çŠ¶æ€

ä¿¡å¿ƒå€¼è®¡ç®—çš„å…·ä½“å¤±è´¥ç‚¹

æ•°æ®è´¨é‡çš„å…·ä½“é—®é¢˜