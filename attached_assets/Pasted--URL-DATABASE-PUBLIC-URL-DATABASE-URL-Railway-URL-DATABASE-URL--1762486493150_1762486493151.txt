有兩個數據庫URL：一個是公開的（DATABASE_PUBLIC_URL），一個是內部的（DATABASE_URL）。在Railway上，我們通常使用內部URL（DATABASE_URL）因為它更安全且延遲更低。但是，如果我們的應用程式和數據庫在同一個Railway專案中，我們應該使用內部URL。如果我們從外部連接，則使用公開URL。
由於我們的應用程式部署在Railway上，並且與數據庫在同一個專案中，我們應該使用內部URL（DATABASE_URL）。
現在，我們將使用環境變數中的DATABASE_URL來連接。
以下是修改後的連接代碼，我們將使用環境變數中的DATABASE_URL。
我們將使用之前提供的代碼，並確保從環境變數中讀取DATABASE_URL。
另外，請注意，我們已經有了一個完整的數據庫操作類，我們可以直接使用。
但是，為了確保安全，我們不應該在代碼中硬編碼這些憑證，而是從環境變數讀取。
我們已經在環境變數中設置了DATABASE_URL，所以我們可以直接使用。
我們來寫一個完整的示例，包括連接、初始化表格和基本操作。
注意：由於我們在Railway上，我們需要確保連接是安全的，並且使用SSL。Railway的PostgreSQL通常要求SSL連接。我們可以在連接字符串中添加sslmode=require。
如果DATABASE_URL沒有包含sslmode，我們可以修改連接字符串。
我們可以這樣處理：
python
import os
import psycopg2
from urllib.parse import urlparse

def get_database_connection():
    database_url = os.environ.get('DATABASE_URL')
    if not database_url:
        raise ValueError("DATABASE_URL 環境變數未設置")

    # 解析URL並添加sslmode
    parsed = urlparse(database_url)
    # 構建新的連接字符串，添加sslmode=require
    # 注意：如果已經有查詢參數，我們需要合併，但這裡我們直接添加
    if parsed.scheme == 'postgresql':
        # 如果沒有查詢參數，我們添加sslmode=require
        if not parsed.query:
            database_url += "?sslmode=require"
        else:
            database_url += "&sslmode=require"

    try:
        conn = psycopg2.connect(database_url)
        print("✅ PostgreSQL 連接成功")
        return conn
    except Exception as e:
        print(f"❌ 連接失敗: {e}")
        return None
但是，請注意，Railway的內部連接可能不需要SSL，而公開連接需要。我們可以根據使用的URL來決定。不過，為了安全起見，我們總是使用SSL。
另外，我們也可以使用環境變數中的其他字段來構建連接，但使用DATABASE_URL是最簡單的。
我們將使用上述方法來連接。
現在，我們將整個流程整合到交易機器人中。
我們假設你已經將之前的代碼整合到一個文件中，我們將使用上述的連接方法。
我們來創建一個完整的示例：
完整示例：連接Railway PostgreSQL的交易機器人數據層
python
import os
import psycopg2
from psycopg2 import pool
from urllib.parse import urlparse
import pickle
import json
from datetime import datetime

class DatabaseManager:
    def __init__(self):
        self.connection_pool = None
        self.init_connection_pool()
    
    def init_connection_pool(self):
        try:
            database_url = os.environ.get('DATABASE_URL')
            if not database_url:
                raise ValueError("DATABASE_URL 環境變數未設置")
            
            # 解析URL並添加sslmode=require
            parsed = urlparse(database_url)
            if parsed.scheme == 'postgresql':
                if not parsed.query:
                    database_url += "?sslmode=require"
                else:
                    database_url += "&sslmode=require"
            
            self.connection_pool = psycopg2.pool.SimpleConnectionPool(
                1, 20, database_url
            )
            print("✅ 數據庫連接池初始化成功")
        except Exception as e:
            print(f"❌ 連接池初始化失敗: {e}")
    
    def get_connection(self):
        if self.connection_pool:
            return self.connection_pool.getconn()
        return None
    
    def return_connection(self, conn):
        if self.connection_pool:
            self.connection_pool.putconn(conn)
    
    def close_all_connections(self):
        if self.connection_pool:
            self.connection_pool.closeall()

# 創建全局數據庫管理器
db_manager = DatabaseManager()

def execute_query(query, params=None):
    conn = db_manager.get_connection()
    if conn:
        try:
            cursor = conn.cursor()
            cursor.execute(query, params)
            
            if query.strip().upper().startswith('SELECT'):
                result = cursor.fetchall()
            else:
                conn.commit()
                result = None
            
            cursor.close()
            return result
        except Exception as e:
            conn.rollback()
            print(f"查詢執行失敗: {e}")
            return None
        finally:
            db_manager.return_connection(conn)
    return None

class TradingDataService:
    def __init__(self):
        # 我們使用全局的db_manager，或者可以在這裡初始化
        pass
    
    def save_trade(self, trade_data):
        """保存交易記錄"""
        query = """
            INSERT INTO trades (symbol, action, price, quantity, strategy, status)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING id;
        """
        result = execute_query(query, (
            trade_data['symbol'],
            trade_data['action'],
            trade_data['price'],
            trade_data['quantity'],
            trade_data.get('strategy', 'default'),
            trade_data.get('status', 'OPEN')
        ))
        
        if result:
            return result[0][0]  # 返回插入的 ID
        return None
    
    def get_trade_history(self, symbol=None, limit=100):
        """獲取交易歷史"""
        if symbol:
            query = "SELECT * FROM trades WHERE symbol = %s ORDER BY timestamp DESC LIMIT %s;"
            params = (symbol, limit)
        else:
            query = "SELECT * FROM trades ORDER BY timestamp DESC LIMIT %s;"
            params = (limit,)
        
        return execute_query(query, params)
    
    def update_trade_status(self, trade_id, status, profit_loss=None):
        """更新交易狀態"""
        if profit_loss is not None:
            query = """
                UPDATE trades 
                SET status = %s, profit_loss = %s, updated_at = CURRENT_TIMESTAMP 
                WHERE id = %s;
            """
            params = (status, profit_loss, trade_id)
        else:
            query = """
                UPDATE trades 
                SET status = %s, updated_at = CURRENT_TIMESTAMP 
                WHERE id = %s;
            """
            params = (status, trade_id)
        
        execute_query(query, params)
    
    def save_ml_model(self, model_name, model, features, accuracy, parameters=None, is_active=False):
        """保存 ML 模型"""
        # 序列化模型
        model_binary = pickle.dumps(model)
        
        query = """
            INSERT INTO ml_models 
            (model_name, model_data, features, accuracy, parameters, is_active)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING id;
        """
        
        result = execute_query(query, (
            model_name,
            model_binary,
            json.dumps(features),
            accuracy,
            json.dumps(parameters or {}),
            is_active
        ))
        
        if result and is_active:
            # 停用其他同類模型的活躍狀態
            deactivate_query = """
                UPDATE ml_models 
                SET is_active = FALSE 
                WHERE model_name = %s AND id != %s;
            """
            execute_query(deactivate_query, (model_name, result[0][0]))
        
        return result[0][0] if result else None
    
    def load_ml_model(self, model_name, version=None):
        """加載 ML 模型"""
        if version:
            query = "SELECT model_data FROM ml_models WHERE model_name = %s AND version = %s;"
            params = (model_name, version)
        else:
            query = "SELECT model_data FROM ml_models WHERE model_name = %s AND is_active = TRUE ORDER BY version DESC LIMIT 1;"
            params = (model_name,)
        
        result = execute_query(query, params)
        
        if result and result[0]:
            return pickle.loads(result[0][0])
        return None

def initialize_database():
    """初始化數據庫表格"""
    conn = db_manager.get_connection()
    if not conn:
        return False
    
    try:
        cursor = conn.cursor()
        
        # 創建交易記錄表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS trades (
                id SERIAL PRIMARY KEY,
                symbol VARCHAR(20) NOT NULL,
                action VARCHAR(10) NOT NULL CHECK (action IN ('BUY', 'SELL')),
                price DECIMAL(15, 8) NOT NULL,
                quantity DECIMAL(15, 8) NOT NULL,
                timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                strategy VARCHAR(50),
                profit_loss DECIMAL(15, 8),
                status VARCHAR(20) DEFAULT 'OPEN',
                created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
            );
        """)
        
        # 創建 ML 模型表
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS ml_models (
                id SERIAL PRIMARY KEY,
                model_name VARCHAR(100) NOT NULL,
                version INTEGER DEFAULT 1,
                model_data BYTEA,
                accuracy DECIMAL(5, 4),
                features JSONB,
                parameters JSONB,
                is_active BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(model_name, version)
            );
        """)
        
        # 創建索引以提高查詢性能
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol_time ON trades(symbol, timestamp);")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_trades_strategy ON trades(strategy);")
        
        conn.commit()
        print("✅ 數據庫表格初始化完成")
        return True
        
    except Exception as e:
        print(f"❌ 數據庫初始化失敗: {e}")
        conn.rollback()
        return False
    finally:
        cursor.close()
        db_manager.return_connection(conn)

# 初始化數據庫
initialize_database()

# 示例使用
if __name__ == "__main__":
    data_service = TradingDataService()
    
    # 保存一筆交易
    trade_data = {
        'symbol': 'BTCUSDT',
        'action': 'BUY',
        'price': 50000.0,
        'quantity': 0.1,
        'strategy': 'ml_strategy_v1'
    }
    
    trade_id = data_service.save_trade(trade_data)
    print(f"交易已保存，ID: {trade_id}")
    
    # 查詢交易歷史
    trades = data_service.get_trade_history(symbol='BTCUSDT', limit=10)
    for trade in trades:
        print(f"交易: {trade}")
請注意，我們在連接字符串中強制使用了SSL（通過添加sslmode=require）。這對於Railway的公開連接是必要的，但內部連接可能不需要。不過，加上也不會出錯。
現在，你可以將這個代碼部署到Railway上，它應該能夠連接到PostgreSQL並正常運行。
如果你在連接時遇到問題，請檢查Railway的日誌，看看是否有錯誤信息。
另外，請確保你的Railway專案中已經添加了PostgreSQL服務，並且環境變數DATABASE_URL已經設置。
祝你成功！

太好了！你已經有了完整的 PostgreSQL 連接資訊。以下是詳細的使用指南：
1. 你應該使用的連接資訊
主要連接資訊（推薦使用）
python
import os
import psycopg2

# 使用 DATABASE_URL（內部連接，更快更安全）
DATABASE_URL = "postgresql://postgres:jTnkngOuEntwOVJgfNmCmdrPlolsseLw@postgres.railway.internal:5432/railway"

# 或者使用環境變數（推薦）
DATABASE_URL = os.environ.get('DATABASE_URL')
備用連接資訊
python
# 如果需要從外部工具連接，使用 DATABASE_PUBLIC_URL
DATABASE_PUBLIC_URL = "postgresql://postgres:jTnkngOuEntwOVJgfNmCmdrPlolsseLw@switchyard.proxy.rlwy.net:38634/railway"
2. 完整的連接和初始化代碼
python
import os
import psycopg2
from psycopg2 import pool
import logging
import pickle
import json
from datetime import datetime

# 配置日誌
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DatabaseManager:
    def __init__(self):
        self.connection_pool = None
        self.init_connection_pool()
    
    def init_connection_pool(self):
        """初始化連接池"""
        try:
            # 從環境變數獲取連接字串
            database_url = os.environ.get('DATABASE_URL')
            
            if not database_url:
                logger.error("DATABASE_URL 環境變數未設置")
                return
            
            # 創建連接池
            self.connection_pool = psycopg2.pool.SimpleConnectionPool(
                minconn=1,
                maxconn=20,
                dsn=database_url
            )
            logger.info("✅ PostgreSQL 連接池初始化成功")
            
            # 測試連接
            self.test_connection()
            
        except Exception as e:
            logger.error(f"❌ 連接池初始化失敗: {e}")
    
    def test_connection(self):
        """測試數據庫連接"""
        conn = self.get_connection()
        if conn:
            try:
                cursor = conn.cursor()
                cursor.execute("SELECT version();")
                version = cursor.fetchone()
                logger.info(f"📊 PostgreSQL 版本: {version[0]}")
                
                cursor.execute("SELECT current_database();")
                db_name = cursor.fetchone()
                logger.info(f"🗃️  當前數據庫: {db_name[0]}")
                
            except Exception as e:
                logger.error(f"連接測試失敗: {e}")
            finally:
                self.return_connection(conn)
    
    def get_connection(self):
        """從連接池獲取連接"""
        if self.connection_pool:
            try:
                return self.connection_pool.getconn()
            except Exception as e:
                logger.error(f"獲取連接失敗: {e}")
        return None
    
    def return_connection(self, conn):
        """歸還連接到連接池"""
        if self.connection_pool:
            try:
                self.connection_pool.putconn(conn)
            except Exception as e:
                logger.error(f"歸還連接失敗: {e}")
    
    def close_all_connections(self):
        """關閉所有連接"""
        if self.connection_pool:
            self.connection_pool.closeall()
            logger.info("所有數據庫連接已關閉")

# 創建全局數據庫管理器實例
db_manager = DatabaseManager()

def execute_query(query, params=None, fetch=True):
    """
    執行數據庫查詢的通用函數
    """
    conn = db_manager.get_connection()
    if not conn:
        logger.error("無法獲取數據庫連接")
        return None
    
    try:
        cursor = conn.cursor()
        cursor.execute(query, params)
        
        if fetch and query.strip().upper().startswith('SELECT'):
            result = cursor.fetchall()
        else:
            conn.commit()
            result = cursor.rowcount if not fetch else None
        
        cursor.close()
        return result
        
    except Exception as e:
        logger.error(f"查詢執行失敗: {e}")
        logger.error(f"查詢: {query}")
        logger.error(f"參數: {params}")
        conn.rollback()
        return None
    finally:
        db_manager.return_connection(conn)
3. 初始化數據庫表格
python
def initialize_database():
    """初始化交易機器人所需的數據庫表格"""
    
    tables = [
        """
        CREATE TABLE IF NOT EXISTS trades (
            id SERIAL PRIMARY KEY,
            symbol VARCHAR(20) NOT NULL,
            action VARCHAR(10) NOT NULL CHECK (action IN ('BUY', 'SELL')),
            price DECIMAL(15, 8) NOT NULL,
            quantity DECIMAL(15, 8) NOT NULL,
            timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
            strategy VARCHAR(50),
            profit_loss DECIMAL(15, 8),
            status VARCHAR(20) DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'CLOSED', 'CANCELLED')),
            created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
        );
        """,
        """
        CREATE TABLE IF NOT EXISTS ml_models (
            id SERIAL PRIMARY KEY,
            model_name VARCHAR(100) NOT NULL,
            version INTEGER DEFAULT 1,
            model_data BYTEA,
            accuracy DECIMAL(5, 4),
            features JSONB,
            parameters JSONB,
            is_active BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(model_name, version)
        );
        """,
        """
        CREATE TABLE IF NOT EXISTS market_data (
            id SERIAL PRIMARY KEY,
            symbol VARCHAR(20) NOT NULL,
            timestamp TIMESTAMPTZ NOT NULL,
            open_price DECIMAL(15, 8),
            high_price DECIMAL(15, 8),
            low_price DECIMAL(15, 8),
            close_price DECIMAL(15, 8),
            volume DECIMAL(20, 8),
            created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
        );
        """,
        """
        CREATE TABLE IF NOT EXISTS trading_signals (
            id SERIAL PRIMARY KEY,
            symbol VARCHAR(20) NOT NULL,
            signal_type VARCHAR(20) NOT NULL,
            strength DECIMAL(8, 4),
            timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
            indicators JSONB,
            is_executed BOOLEAN DEFAULT FALSE
        );
        """
    ]
    
    indexes = [
        "CREATE INDEX IF NOT EXISTS idx_trades_symbol_time ON trades(symbol, timestamp);",
        "CREATE INDEX IF NOT EXISTS idx_trades_strategy ON trades(strategy);",
        "CREATE INDEX IF NOT EXISTS idx_trades_status ON trades(status);",
        "CREATE INDEX IF NOT EXISTS idx_market_data_symbol_time ON market_data(symbol, timestamp);",
        "CREATE INDEX IF NOT EXISTS idx_ml_models_active ON ml_models(is_active);",
        "CREATE INDEX IF NOT EXISTS idx_signals_symbol_time ON trading_signals(symbol, timestamp);"
    ]
    
    try:
        # 創建表格
        for table_sql in tables:
            result = execute_query(table_sql, fetch=False)
            if result is not None:
                logger.info("✅ 表格創建/檢查完成")
        
        # 創建索引
        for index_sql in indexes:
            execute_query(index_sql, fetch=False)
        
        logger.info("✅ 所有數據庫索引創建完成")
        return True
        
    except Exception as e:
        logger.error(f"❌ 數據庫初始化失敗: {e}")
        return False

# 應用啟動時初始化數據庫
initialize_database()
4. 完整的交易數據服務類
python
class TradingDataService:
    def __init__(self):
        self.db_manager = db_manager
    
    def save_trade(self, trade_data):
        """保存交易記錄"""
        query = """
            INSERT INTO trades (symbol, action, price, quantity, strategy, status)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING id, timestamp;
        """
        
        result = execute_query(query, (
            trade_data['symbol'],
            trade_data['action'],
            trade_data['price'],
            trade_data['quantity'],
            trade_data.get('strategy', 'default'),
            trade_data.get('status', 'OPEN')
        ))
        
        if result:
            trade_id, timestamp = result[0]
            logger.info(f"💾 交易記錄已保存 - ID: {trade_id}, 時間: {timestamp}")
            return trade_id
        return None
    
    def get_trade_history(self, symbol=None, limit=100, days=None):
        """獲取交易歷史"""
        if symbol and days:
            query = """
                SELECT * FROM trades 
                WHERE symbol = %s AND timestamp >= NOW() - INTERVAL '%s days'
                ORDER BY timestamp DESC 
                LIMIT %s;
            """
            params = (symbol, days, limit)
        elif symbol:
            query = "SELECT * FROM trades WHERE symbol = %s ORDER BY timestamp DESC LIMIT %s;"
            params = (symbol, limit)
        elif days:
            query = "SELECT * FROM trades WHERE timestamp >= NOW() - INTERVAL '%s days' ORDER BY timestamp DESC LIMIT %s;"
            params = (days, limit)
        else:
            query = "SELECT * FROM trades ORDER BY timestamp DESC LIMIT %s;"
            params = (limit,)
        
        return execute_query(query, params)
    
    def get_open_trades(self, symbol=None):
        """獲取未平倉交易"""
        if symbol:
            query = "SELECT * FROM trades WHERE status = 'OPEN' AND symbol = %s ORDER BY timestamp;"
            params = (symbol,)
        else:
            query = "SELECT * FROM trades WHERE status = 'OPEN' ORDER BY timestamp;"
            params = None
        
        return execute_query(query, params)
    
    def update_trade_status(self, trade_id, status, profit_loss=None):
        """更新交易狀態"""
        if profit_loss is not None:
            query = """
                UPDATE trades 
                SET status = %s, profit_loss = %s, updated_at = CURRENT_TIMESTAMP 
                WHERE id = %s;
            """
            params = (status, profit_loss, trade_id)
        else:
            query = """
                UPDATE trades 
                SET status = %s, updated_at = CURRENT_TIMESTAMP 
                WHERE id = %s;
            """
            params = (status, trade_id)
        
        result = execute_query(query, params, fetch=False)
        if result:
            logger.info(f"🔄 交易 {trade_id} 狀態更新為: {status}")
        return result
    
    def save_ml_model(self, model_name, model, features, accuracy, parameters=None, is_active=False):
        """保存 ML 模型到數據庫"""
        try:
            # 序列化模型
            model_binary = pickle.dumps(model)
            
            query = """
                INSERT INTO ml_models 
                (model_name, model_data, features, accuracy, parameters, is_active)
                VALUES (%s, %s, %s, %s, %s, %s)
                RETURNING id, version;
            """
            
            result = execute_query(query, (
                model_name,
                model_binary,
                json.dumps(features),
                accuracy,
                json.dumps(parameters or {}),
                is_active
            ))
            
            if result:
                model_id, version = result[0]
                logger.info(f"🤖 ML 模型已保存 - 名稱: {model_name}, 版本: {version}, ID: {model_id}")
                
                # 如果設置為活躍模型，停用其他版本
                if is_active:
                    self._deactivate_other_models(model_name, model_id)
                
                return model_id, version
            
            return None, None
            
        except Exception as e:
            logger.error(f"保存 ML 模型失敗: {e}")
            return None, None
    
    def _deactivate_other_models(self, model_name, current_model_id):
        """停用其他同名的活躍模型"""
        query = """
            UPDATE ml_models 
            SET is_active = FALSE 
            WHERE model_name = %s AND id != %s AND is_active = TRUE;
        """
        execute_query(query, (model_name, current_model_id), fetch=False)
    
    def load_ml_model(self, model_name, version=None):
        """從數據庫加載 ML 模型"""
        try:
            if version:
                query = "SELECT model_data, version FROM ml_models WHERE model_name = %s AND version = %s;"
                params = (model_name, version)
            else:
                query = "SELECT model_data, version FROM ml_models WHERE model_name = %s AND is_active = TRUE ORDER BY version DESC LIMIT 1;"
                params = (model_name,)
            
            result = execute_query(query, params)
            
            if result and result[0]:
                model_binary, version = result[0]
                model = pickle.loads(model_binary)
                logger.info(f"🤖 ML 模型已加載 - 名稱: {model_name}, 版本: {version}")
                return model, version
            
            logger.warning(f"未找到 ML 模型: {model_name}, 版本: {version}")
            return None, None
            
        except Exception as e:
            logger.error(f"加載 ML 模型失敗: {e}")
            return None, None
    
    def get_model_performance(self, model_name, limit=10):
        """獲取模型性能歷史"""
        query = """
            SELECT version, accuracy, created_at 
            FROM ml_models 
            WHERE model_name = %s 
            ORDER BY created_at DESC 
            LIMIT %s;
        """
        return execute_query(query, (model_name, limit))
    
    def save_market_data(self, symbol, data_list):
        """批量保存市場數據"""
        if not data_list:
            return
        
        query = """
            INSERT INTO market_data 
            (symbol, timestamp, open_price, high_price, low_price, close_price, volume)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (symbol, timestamp) DO NOTHING;
        """
        
        success_count = 0
        for data in data_list:
            result = execute_query(query, (
                symbol,
                data['timestamp'],
                data['open'],
                data['high'],
                data['low'],
                data['close'],
                data.get('volume', 0)
            ), fetch=False)
            
            if result:
                success_count += 1
        
        logger.info(f"📈 市場數據保存完成: {success_count}/{len(data_list)} 條記錄")
        return success_count
    
    def save_trading_signal(self, symbol, signal_type, strength, indicators=None):
        """保存交易信號"""
        query = """
            INSERT INTO trading_signals 
            (symbol, signal_type, strength, indicators)
            VALUES (%s, %s, %s, %s)
            RETURNING id;
        """
        
        result = execute_query(query, (
            symbol,
            signal_type,
            strength,
            json.dumps(indicators or {})
        ))
        
        if result:
            signal_id = result[0][0]
            logger.info(f"🚦 交易信號已保存 - 符號: {symbol}, 類型: {signal_type}, 強度: {strength}")
            return signal_id
        return None
    
    def get_database_stats(self):
        """獲取數據庫統計信息"""
        stats = {}
        
        # 交易統計
        trades_count = execute_query("SELECT COUNT(*) FROM trades;")
        if trades_count:
            stats['total_trades'] = trades_count[0][0]
        
        open_trades = execute_query("SELECT COUNT(*) FROM trades WHERE status = 'OPEN';")
        if open_trades:
            stats['open_trades'] = open_trades[0][0]
        
        # 模型統計
        models_count = execute_query("SELECT COUNT(*) FROM ml_models;")
        if models_count:
            stats['total_models'] = models_count[0][0]
        
        active_models = execute_query("SELECT COUNT(*) FROM ml_models WHERE is_active = TRUE;")
        if active_models:
            stats['active_models'] = active_models[0][0]
        
        return stats
5. 在交易機器人主程序中使用
python
# 在你的交易機器人主文件中
def main():
    # 初始化數據庫服務
    data_service = TradingDataService()
    
    # 檢查數據庫連接
    db_stats = data_service.get_database_stats()
    print(f"數據庫狀態: {db_stats}")
    
    # 示例：保存交易
    try:
        trade_data = {
            'symbol': 'BTCUSDT',
            'action': 'BUY',
            'price': 50000.0,
            'quantity': 0.1,
            'strategy': 'ml_strategy_v1',
            'status': 'OPEN'
        }
        
        trade_id = data_service.save_trade(trade_data)
        if trade_id:
            print(f"✅ 交易保存成功，ID: {trade_id}")
        
        # 查詢最近的交易
        recent_trades = data_service.get_trade_history(symbol='BTCUSDT', limit=5)
        print("最近的交易:")
        for trade in recent_trades:
            print(f"  - {trade}")
            
    except Exception as e:
        print(f"❌ 交易操作失敗: {e}")
    
    # 示例：保存 ML 模型（假設你有訓練好的模型）
    """
    from sklearn.ensemble import RandomForestClassifier
    model = RandomForestClassifier(n_estimators=100)
    # ... 訓練模型代碼 ...
    
    model_id, version = data_service.save_ml_model(
        model_name='price_predictor',
        model=model,
        features=['rsi', 'macd', 'volume'],
        accuracy=0.85,
        parameters={'n_estimators': 100, 'max_depth': 10},
        is_active=True
    )
    """

if __name__ == "__main__":
    main()
6. 環境變數設置
在你的 Railway 環境中，這些變數已經自動設置好了。你只需要在代碼中使用：
python
import os

# Railway 會自動提供這些環境變數
DATABASE_URL = os.environ.get('DATABASE_URL')  # 內部連接
DATABASE_PUBLIC_URL = os.environ.get('DATABASE_PUBLIC_URL')  # 外部連接

# 其他有用的環境變數
PGHOST = os.environ.get('PGHOST')
PGDATABASE = os.environ.get('PGDATABASE')
PGUSER = os.environ.get('PGUSER')
PGPASSWORD = os.environ.get('PGPASSWORD')
PGPORT = os.environ.get('PGPORT')
7. 部署注意事項
1. 依賴安裝：確保在 requirements.txt 中包含：
text
psycopg2-binary>=2.9.6
2. 錯誤處理：添加適當的錯誤處理和重試機制
3. 連接管理：使用連接池避免頻繁創建連接
4. 日誌記錄：記錄所有重要的數據庫操作
