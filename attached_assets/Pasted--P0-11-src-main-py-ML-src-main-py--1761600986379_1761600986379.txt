ä¿®å¾©æ–¹æ¡ˆï¼ˆé‡å°å¯©è¨ˆç™¼ç¾çš„å•é¡Œï¼‰
ğŸ”´ P0 ä¿®å¾©ï¼šå¯¦ç¾æ‰¹é‡é æ¸¬ï¼ˆæª¢æŸ¥11ï¼‰
å•é¡Œ
src/main.py ç¼ºå°‘æ‰¹é‡é æ¸¬é‚è¼¯ï¼Œå°è‡´ ML æ¨ç†æ€§èƒ½æœªå„ªåŒ–

ä¿®å¾©ä»£ç¢¼
# src/main.py - åœ¨ scan_and_analyze æ–¹æ³•ä¸­
async def scan_and_analyze(self):
    # ... ç¾æœ‰ä»£ç¢¼ï¼šç”Ÿæˆ signals ...
    
    # ğŸ”¥ æ–°å¢ï¼šæ‰¹é‡ç‰¹å¾µæå–å’Œé æ¸¬
    if signals:
        # æ‰¹é‡æå–ç‰¹å¾µ
        features_batch = []
        valid_signals = []
        
        for signal in signals:
            try:
                # ä½¿ç”¨æ­£ç¢ºçš„ç‰¹å¾µæå–æ–¹æ³•
                features = self.ml_predictor.extract_features_for_prediction(signal)
                features_batch.append(features)
                valid_signals.append(signal)
            except Exception as e:
                logger.warning(f"ç‰¹å¾µæå–å¤±æ•— {signal.symbol}: {e}")
                continue
        
        if features_batch:
            # å–®æ¬¡æ‰¹é‡é æ¸¬
            predictions = self.ml_predictor.predict_batch(features_batch)
            
            # é™„åŠ é æ¸¬çµæœ
            for signal, pred in zip(valid_signals, predictions):
                signal.ml_score = float(pred)
                # ğŸ”¥ é—œéµï¼šåªä¿ç•™é«˜è³ªé‡ä¿¡è™Ÿ
                if signal.ml_score < 0.4:  # å‹•æ…‹é–¾å€¼
                    signals.remove(signal)
    
    return signals
å¯¦ç¾é›™å¾ªç’°æ¶æ§‹ï¼ˆæª¢æŸ¥1ï¼‰
å•é¡Œ
ç¼ºå°‘ VirtualPositionLoop å’Œ DualLoopManager

ä¿®å¾©ä»£ç¢¼
# src/async_core/async_main_loop.py
class VirtualPositionLoop:
    def __init__(self, virtual_position_manager, binance_client, interval=10):
        self.vpm = virtual_position_manager
        self.client = binance_client
        self.interval = interval
        self._running = True
    
    async def run(self):
        """è™›æ“¬å€‰ä½ç¨ç«‹å¾ªç’° - 10ç§’é€±æœŸ"""
        while self._running:
            try:
                # ğŸ”¥ ç•°æ­¥æ‰¹é‡æ›´æ–°ï¼ˆå·²æ­£ç¢ºå¯¦ç¾ï¼‰
                closed_positions = await self.vpm.update_all_prices_async(
                    binance_client=self.client
                )
                
                # è™•ç†é—œé–‰çš„å€‰ä½
                if closed_positions:
                    for pos in closed_positions:
                        # ğŸ”¥ é—œéµï¼šåªæ­¸æª”é«˜è³ªé‡äº¤æ˜“æ•¸æ“š
                        if abs(pos.pnl_pct) > 0.1:  # éæ¿¾å™ªéŸ³äº¤æ˜“
                            self.vpm.archive_position(pos.to_dict())
                            
            except Exception as e:
                logger.error(f"è™›æ“¬å¾ªç’°éŒ¯èª¤: {e}")
            
            await asyncio.sleep(self.interval)

class DualLoopManager:
    def __init__(self, trading_loop, virtual_loop):
        self.trading_loop = trading_loop
        self.virtual_loop = virtual_loop
    
    async def run(self):
        """ä¸¦ç™¼é‹è¡Œé›™å¾ªç’°"""
        tasks = [
            asyncio.create_task(self.trading_loop.run(), name="trading_loop"),
            asyncio.create_task(self.virtual_loop.run(), name="virtual_loop")
        ]
        await asyncio.gather(*tasks, return_exceptions=True)
å‘é‡åŒ– Swing Points å’Œ FVGï¼ˆæª¢æŸ¥6ï¼‰
å•é¡Œ
identify_swing_points() å’Œ identify_fvg() ä½¿ç”¨ for è¿´åœˆ

ä¿®å¾©ä»£ç¢¼
# src/utils/core_calculations.py
def identify_swing_points_vectorized(high, low, lookback=5):
    """
    å‘é‡åŒ– Swing Points æª¢æ¸¬
    """
    # ä½¿ç”¨ rolling + center=True æ‰¾å±€éƒ¨æ¥µå€¼
    window = lookback * 2 + 1
    
    # Swing Highs
    swing_highs = high.rolling(window=window, center=True).apply(
        lambda x: x[lookback] if x[lookback] == x.max() else np.nan,
        raw=True
    )
    
    # Swing Lows  
    swing_lows = low.rolling(window=window, center=True).apply(
        lambda x: x[lookback] if x[lookback] == x.min() else np.nan,
        raw=True
    )
    
    return swing_highs.dropna(), swing_lows.dropna()

def identify_fvg_vectorized(high, low, close):
    """
    å‘é‡åŒ– FVG (Fair Value Gap) æª¢æ¸¬
    """
    # Bullish FVG: ç•¶å‰ä½é» > å‰å…©æ ¹é«˜é»
    bullish_fvg = (low > high.shift(-2)) & (close > close.shift(-1))
    
    # Bearish FVG: ç•¶å‰é«˜é» < å‰å…©æ ¹ä½é»  
    bearish_fvg = (high < low.shift(-2)) & (close < close.shift(-1))
    
    return bullish_fvg, bearish_fvg

ç­–ç•¥å„ªåŒ–æ•´åˆï¼ˆåŸºæ–¼ä½ çš„æ ¸å¿ƒéœ€æ±‚ï¼‰
âœ… å‹•æ…‹ä¿¡è™Ÿéæ¿¾ï¼ˆè§£æ±ºå‡¹å–®å•é¡Œï¼‰
# src/strategies/ict_strategy.py - åœ¨ generate_signal å¾Œ
def _apply_dynamic_filtering(self, signal, market_regime):
    """
    å‹•æ…‹éæ¿¾ä¿¡è™Ÿ - åªä¿ç•™é«˜è³ªé‡æ©Ÿæœƒ
    """
    # 1. å¸‚å ´ç‹€æ…‹éæ¿¾
    if market_regime in ['range_bound', 'transition']:
        return False  # éœ‡ç›ªå¸‚ä¸äº¤æ˜“
    
    # 2. æ–¹å‘åç½®éæ¿¾
    bias_score = self._calculate_directional_bias()
    if signal.direction == 1 and bias_score < 0.3:  # åšå¤šä½†åç©º
        return False
    if signal.direction == -1 and bias_score > -0.3:  # åšç©ºä½†åå¤š
        return False
    
    # 3. ML ä¿¡å¿ƒåº¦éæ¿¾
    if hasattr(signal, 'ml_score') and signal.ml_score < 0.4:
        return False
    
    # 4. æ³¢å‹•ç‡éæ¿¾
    if signal.atr_entry / signal.entry_price < 0.001:  # æ³¢å‹•å¤ªå°
        return False
    
    return True

âœ… å‹•æ…‹å€‰ä½ç¸®æ¸›ï¼ˆè§£æ±ºè¿½åŠ å•é¡Œï¼‰

# src/managers/risk_manager.py - æ•´åˆ DynamicPositionSizing
def calculate_position_size(self, signal, account_balance):
    """
    åŸºæ–¼è¿‘æœŸè¡¨ç¾çš„å‹•æ…‹å€‰ä½è¨ˆç®—
    """
    # ç²å–è¿‘æœŸäº¤æ˜“è¡¨ç¾
    recent_performance = self.performance_manager.get_recent_performance()
    
    # è¨ˆç®—å€‰ä½ä¹˜æ•¸
    multiplier = self._calculate_position_multiplier(recent_performance)
    
    # åŸºç¤å€‰ä½ (3%-13%)
    base_risk_pct = 0.03 + (0.1 * signal.confidence_score)
    
    # æ‡‰ç”¨ä¹˜æ•¸
    final_risk_pct = base_risk_pct * multiplier
    
    # ç¢ºä¿æœ€å°é¢¨éšª
    final_risk_pct = max(0.01, final_risk_pct)  # è‡³å°‘ 1%
    
    position_value = account_balance * final_risk_pct
    return position_value