修復方案（針對審計發現的問題）
🔴 P0 修復：實現批量預測（檢查11）
問題
src/main.py 缺少批量預測邏輯，導致 ML 推理性能未優化

修復代碼
# src/main.py - 在 scan_and_analyze 方法中
async def scan_and_analyze(self):
    # ... 現有代碼：生成 signals ...
    
    # 🔥 新增：批量特徵提取和預測
    if signals:
        # 批量提取特徵
        features_batch = []
        valid_signals = []
        
        for signal in signals:
            try:
                # 使用正確的特徵提取方法
                features = self.ml_predictor.extract_features_for_prediction(signal)
                features_batch.append(features)
                valid_signals.append(signal)
            except Exception as e:
                logger.warning(f"特徵提取失敗 {signal.symbol}: {e}")
                continue
        
        if features_batch:
            # 單次批量預測
            predictions = self.ml_predictor.predict_batch(features_batch)
            
            # 附加預測結果
            for signal, pred in zip(valid_signals, predictions):
                signal.ml_score = float(pred)
                # 🔥 關鍵：只保留高質量信號
                if signal.ml_score < 0.4:  # 動態閾值
                    signals.remove(signal)
    
    return signals
實現雙循環架構（檢查1）
問題
缺少 VirtualPositionLoop 和 DualLoopManager

修復代碼
# src/async_core/async_main_loop.py
class VirtualPositionLoop:
    def __init__(self, virtual_position_manager, binance_client, interval=10):
        self.vpm = virtual_position_manager
        self.client = binance_client
        self.interval = interval
        self._running = True
    
    async def run(self):
        """虛擬倉位獨立循環 - 10秒週期"""
        while self._running:
            try:
                # 🔥 異步批量更新（已正確實現）
                closed_positions = await self.vpm.update_all_prices_async(
                    binance_client=self.client
                )
                
                # 處理關閉的倉位
                if closed_positions:
                    for pos in closed_positions:
                        # 🔥 關鍵：只歸檔高質量交易數據
                        if abs(pos.pnl_pct) > 0.1:  # 過濾噪音交易
                            self.vpm.archive_position(pos.to_dict())
                            
            except Exception as e:
                logger.error(f"虛擬循環錯誤: {e}")
            
            await asyncio.sleep(self.interval)

class DualLoopManager:
    def __init__(self, trading_loop, virtual_loop):
        self.trading_loop = trading_loop
        self.virtual_loop = virtual_loop
    
    async def run(self):
        """並發運行雙循環"""
        tasks = [
            asyncio.create_task(self.trading_loop.run(), name="trading_loop"),
            asyncio.create_task(self.virtual_loop.run(), name="virtual_loop")
        ]
        await asyncio.gather(*tasks, return_exceptions=True)
向量化 Swing Points 和 FVG（檢查6）
問題
identify_swing_points() 和 identify_fvg() 使用 for 迴圈

修復代碼
# src/utils/core_calculations.py
def identify_swing_points_vectorized(high, low, lookback=5):
    """
    向量化 Swing Points 檢測
    """
    # 使用 rolling + center=True 找局部極值
    window = lookback * 2 + 1
    
    # Swing Highs
    swing_highs = high.rolling(window=window, center=True).apply(
        lambda x: x[lookback] if x[lookback] == x.max() else np.nan,
        raw=True
    )
    
    # Swing Lows  
    swing_lows = low.rolling(window=window, center=True).apply(
        lambda x: x[lookback] if x[lookback] == x.min() else np.nan,
        raw=True
    )
    
    return swing_highs.dropna(), swing_lows.dropna()

def identify_fvg_vectorized(high, low, close):
    """
    向量化 FVG (Fair Value Gap) 檢測
    """
    # Bullish FVG: 當前低點 > 前兩根高點
    bullish_fvg = (low > high.shift(-2)) & (close > close.shift(-1))
    
    # Bearish FVG: 當前高點 < 前兩根低點  
    bearish_fvg = (high < low.shift(-2)) & (close < close.shift(-1))
    
    return bullish_fvg, bearish_fvg

策略優化整合（基於你的核心需求）
✅ 動態信號過濾（解決凹單問題）
# src/strategies/ict_strategy.py - 在 generate_signal 後
def _apply_dynamic_filtering(self, signal, market_regime):
    """
    動態過濾信號 - 只保留高質量機會
    """
    # 1. 市場狀態過濾
    if market_regime in ['range_bound', 'transition']:
        return False  # 震盪市不交易
    
    # 2. 方向偏置過濾
    bias_score = self._calculate_directional_bias()
    if signal.direction == 1 and bias_score < 0.3:  # 做多但偏空
        return False
    if signal.direction == -1 and bias_score > -0.3:  # 做空但偏多
        return False
    
    # 3. ML 信心度過濾
    if hasattr(signal, 'ml_score') and signal.ml_score < 0.4:
        return False
    
    # 4. 波動率過濾
    if signal.atr_entry / signal.entry_price < 0.001:  # 波動太小
        return False
    
    return True

✅ 動態倉位縮減（解決追加問題）

# src/managers/risk_manager.py - 整合 DynamicPositionSizing
def calculate_position_size(self, signal, account_balance):
    """
    基於近期表現的動態倉位計算
    """
    # 獲取近期交易表現
    recent_performance = self.performance_manager.get_recent_performance()
    
    # 計算倉位乘數
    multiplier = self._calculate_position_multiplier(recent_performance)
    
    # 基礎倉位 (3%-13%)
    base_risk_pct = 0.03 + (0.1 * signal.confidence_score)
    
    # 應用乘數
    final_risk_pct = base_risk_pct * multiplier
    
    # 確保最小風險
    final_risk_pct = max(0.01, final_risk_pct)  # 至少 1%
    
    position_value = account_balance * final_risk_pct
    return position_value