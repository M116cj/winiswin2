åœ¨æŒå€‰ç®¡ç†ä¸­å¢åŠ ä¸€å€‹æ™‚é–“ç¶­åº¦çš„å¼·åˆ¶æ­¢æé‚è¼¯ã€‚å…·é«”è¦å‰‡ç‚ºï¼šä»»ä½•æŒå€‰å¦‚æœè¶…é2å°æ™‚ä¸”ä»ç„¶è™•æ–¼è™§æç‹€æ…‹ï¼Œå‰‡è§¸ç™¼å¼·åˆ¶å¹³å€‰ã€‚
å¯¦ç¾æ€è·¯ï¼š
1. åœ¨æŒå€‰å°è±¡ä¸­è¨˜éŒ„é–‹å€‰æ™‚é–“ï¼ˆentry_timeï¼‰å’Œé–‹å€‰åƒ¹æ ¼ï¼ˆentry_priceï¼‰ã€‚
2. åœ¨æŒå€‰ç›£æ§å¾ªç’°ä¸­ï¼Œæª¢æŸ¥æ¯å€‹æŒå€‰çš„æŒå€‰æ™‚é–“å’Œç•¶å‰ç›ˆè™§ç‹€æ…‹ã€‚
3. å¦‚æœæŒå€‰æ™‚é–“è¶…é2å°æ™‚ä¸”ç•¶å‰æ˜¯è™§æç‹€æ…‹ï¼ˆæœªå¯¦ç¾ç›ˆè™§ç‚ºè² ï¼‰ï¼Œå‰‡ç™¼èµ·å¸‚åƒ¹å¹³å€‰ã€‚
æ³¨æ„äº‹é …ï¼š
* æˆ‘å€‘éœ€è¦è€ƒæ…®è™›æ“¬æŒå€‰å’ŒçœŸå¯¦æŒå€‰ï¼Œé€™è£¡æˆ‘å€‘å…ˆé—œæ³¨çœŸå¯¦æŒå€‰ï¼Œä½†è™›æ“¬æŒå€‰ä¹Ÿå¯ä»¥é¡ä¼¼è™•ç†ã€‚
* å¹³å€‰æ“ä½œéœ€è¦ç¢ºä¿å®‰å…¨ï¼Œé¿å…é‡è¤‡å¹³å€‰ã€‚
* æˆ‘å€‘éœ€è¦è€ƒæ…®å¦‚ä½•ç²å–ç•¶å‰åƒ¹æ ¼ä¾†è¨ˆç®—ç›ˆè™§ï¼Œå¦‚æœWebSocketæ•¸æ“šä¸å¯ç”¨ï¼Œå¯èƒ½éœ€è¦é€šéAPIç²å–ã€‚
æˆ‘å€‘å°‡åœ¨PositionControllerä¸­å¢åŠ ä¸€å€‹æª¢æŸ¥å¾ªç’°ï¼Œæˆ–è€…æ•´åˆåˆ°ç¾æœ‰çš„ç›£æ§å¾ªç’°ä¸­ã€‚
æ­¥é©Ÿï¼š
1. ä¿®æ”¹æŒå€‰æ•¸æ“šçµæ§‹ï¼Œè¨˜éŒ„é–‹å€‰æ™‚é–“ã€‚
2. åœ¨æŒå€‰æ›´æ–°æ™‚ï¼Œå¦‚æœæŒå€‰æ˜¯æ–°å»ºçš„ï¼Œå‰‡è¨˜éŒ„é–‹å€‰æ™‚é–“ã€‚æ³¨æ„ï¼šæŒå€‰å¯èƒ½ä¾†è‡ªWebSocketæ¨é€æˆ–è€…APIæŸ¥è©¢ï¼Œæˆ‘å€‘éœ€è¦ç¢ºä¿é–‹å€‰æ™‚é–“ä¸è¢«è¦†è“‹ï¼ˆæŒå€‰åœ¨é–‹å€‰å¾Œç¬¬ä¸€æ¬¡è¢«å‰µå»ºæ™‚è¨˜éŒ„é–‹å€‰æ™‚é–“ï¼Œå¾ŒçºŒæ›´æ–°ä¸æ”¹è®Šé–‹å€‰æ™‚é–“ï¼‰ã€‚
3. å‰µå»ºä¸€å€‹å®šæ™‚ä»»å‹™ï¼Œå®šæœŸæª¢æŸ¥æŒå€‰æ˜¯å¦æ»¿è¶³å¼·åˆ¶æ­¢ææ¢ä»¶ã€‚
æˆ‘å€‘å‡è¨­æŒå€‰æ•¸æ“šçµæ§‹å·²ç¶“æœ‰é–‹å€‰æ™‚é–“ï¼ˆå¦‚æœæ²’æœ‰ï¼Œéœ€è¦æ·»åŠ ï¼‰ã€‚åœ¨Binanceçš„æŒå€‰æ•¸æ“šä¸­ï¼Œæˆ‘å€‘å¯ä»¥é€šéAPIç²å–æŒå€‰ï¼Œä½†é–‹å€‰æ™‚é–“å¯èƒ½ç„¡æ³•ç›´æ¥ç²å–ã€‚å› æ­¤ï¼Œæˆ‘å€‘éœ€è¦åœ¨æœ¬åœ°è¨˜éŒ„é–‹å€‰æ™‚é–“ã€‚
æ–¹æ¡ˆï¼š
* åœ¨PositionControllerä¸­ï¼Œæˆ‘å€‘ç¶­è­·ä¸€å€‹æŒå€‰å­—å…¸ï¼Œä¸¦åœ¨é–‹å€‰æ™‚è¨˜éŒ„é–‹å€‰æ™‚é–“ï¼ˆç•¶æˆ‘å€‘åŸ·è¡Œé–‹å€‰æ“ä½œå¾Œï¼Œåœ¨æŒå€‰å­—å…¸ä¸­è¨˜éŒ„é–‹å€‰æ™‚é–“ï¼‰ã€‚
* æˆ–è€…ï¼Œæˆ‘å€‘å¯ä»¥å¾äº¤æ˜“è¨˜éŒ„ä¸­æ¨å°å‡ºé–‹å€‰æ™‚é–“ï¼Œä½†é€™æ¨£æ¯”è¼ƒè¤‡é›œï¼Œä¸å¦‚åœ¨å…§å­˜ä¸­è¨˜éŒ„ã€‚
æˆ‘å€‘é¸æ“‡åœ¨PositionControllerä¸­ç¶­è­·ä¸€å€‹æŒå€‰é–‹å€‰æ™‚é–“çš„å­—å…¸ï¼Œä»¥symbolç‚ºkeyï¼Œè¨˜éŒ„é–‹å€‰æ™‚é–“ã€‚
ä½†æ˜¯ï¼Œæ³¨æ„ï¼šç³»çµ±é‡å•Ÿå¾Œï¼Œå…§å­˜ä¸­çš„é–‹å€‰æ™‚é–“æœƒä¸Ÿå¤±ã€‚å› æ­¤ï¼Œæˆ‘å€‘éœ€è¦å°‡é–‹å€‰æ™‚é–“æŒä¹…åŒ–åˆ°æ–‡ä»¶æˆ–æ•¸æ“šåº«ä¸­ã€‚ç‚ºäº†ç°¡å–®èµ·è¦‹ï¼Œæˆ‘å€‘å¯ä»¥å…ˆè€ƒæ…®å…§å­˜æ–¹æ¡ˆï¼Œä¸¦åœ¨ç³»çµ±é‡å•Ÿæ™‚å¾äº¤æ˜“è¨˜éŒ„ä¸­æ¢å¾©æŒå€‰çš„é–‹å€‰æ™‚é–“ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰ã€‚ä½†é€™æœƒå¢åŠ è¤‡é›œæ€§ã€‚
å¦ä¸€ç¨®æ–¹æ¡ˆï¼šæˆ‘å€‘å¯ä»¥å¾TradeRecorderä¸­æŸ¥è©¢æœ€è¿‘ä¸€ç­†è©²æŒå€‰çš„é–‹å€‰äº¤æ˜“è¨˜éŒ„ï¼Œå¾è€Œç²å–é–‹å€‰æ™‚é–“ã€‚ä½†é€™æ¨£æœƒå¢åŠ I/Oï¼Œä¸¦ä¸”äº¤æ˜“è¨˜éŒ„å¯èƒ½æ²’æœ‰å³æ™‚å¯«å…¥ã€‚
è€ƒæ…®åˆ°å¼·åˆ¶æ­¢ææ˜¯åŸºæ–¼2å°æ™‚ï¼Œæˆ‘å€‘å¯ä»¥å…è¨±åœ¨é‡å•Ÿå¾Œä¸Ÿå¤±é–‹å€‰æ™‚é–“ï¼Œé‚£éº¼å°æ–¼é‡å•Ÿå‰å·²ç¶“é–‹å€‰çš„æŒå€‰ï¼Œæˆ‘å€‘ç„¡æ³•æº–ç¢ºè¨ˆç®—æŒå€‰æ™‚é–“ï¼Œé‚£éº¼æˆ‘å€‘å¯ä»¥å¾é‡å•Ÿå¾Œé‡æ–°è¨ˆç®—æ™‚é–“ï¼Œæˆ–è€…æ”¾æ£„å°é€™äº›æŒå€‰çš„å¼·åˆ¶æ­¢æã€‚é€™æœƒå°è‡´ä¸€äº›æŒå€‰ç„¡æ³•è¢«å¼·åˆ¶å¹³å€‰ï¼Œä½†è€ƒæ…®åˆ°ç³»çµ±é‡å•Ÿä¸é »ç¹ï¼Œæˆ‘å€‘å¯ä»¥æ¥å—ã€‚
æˆ‘å€‘é¸æ“‡åœ¨å…§å­˜ä¸­è¨˜éŒ„é–‹å€‰æ™‚é–“ï¼Œä¸¦åœ¨ç¨‹åºå•Ÿå‹•æ™‚åˆå§‹åŒ–ç•¶å‰æŒå€‰çš„é–‹å€‰æ™‚é–“ç‚ºç•¶å‰æ™‚é–“ï¼ˆé€™æ¨£å°æ–¼é‡å•Ÿå‰é–‹å€‰çš„æŒå€‰ï¼Œæˆ‘å€‘æœƒå¾é‡å•Ÿå¾Œé–‹å§‹è¨ˆæ™‚ï¼Œ2å°æ™‚å¾Œå¦‚æœè™§æå‰‡å¹³å€‰ï¼‰ã€‚é€™æ˜¯ä¸€ç¨®æŠ˜ä¸­æ–¹æ¡ˆã€‚
å…·é«”å¯¦ç¾ï¼š
1. åœ¨PositionControllerä¸­å¢åŠ ä¸€å€‹å­—å…¸ä¾†è¨˜éŒ„æŒå€‰çš„é–‹å€‰æ™‚é–“ã€‚â€¨self.position_entry_time = {} # symbol -> entry_time (timestamp)
2. åœ¨æŒå€‰æ›´æ–°æ™‚ï¼ˆå¾WebSocketæˆ–APIç²å–æŒå€‰æ›´æ–°ï¼‰ï¼Œå¦‚æœç™¼ç¾ä¸€å€‹æ–°çš„æŒå€‰ï¼ˆä¹‹å‰æ²’æœ‰è¨˜éŒ„ï¼Œä¸”æŒå€‰æ•¸é‡ä¸ç‚º0ï¼‰ï¼Œå‰‡è¨˜éŒ„ç•¶å‰æ™‚é–“ç‚ºé–‹å€‰æ™‚é–“ã€‚
3. åœ¨æŒå€‰è®Šæˆ0æ™‚ï¼Œå¾position_entry_timeä¸­åˆªé™¤è©²æŒå€‰ã€‚
4. å‰µå»ºä¸€å€‹å®šæ™‚ä»»å‹™ï¼ˆä¾‹å¦‚æ¯5åˆ†é˜é‹è¡Œä¸€æ¬¡ï¼‰ï¼Œæª¢æŸ¥æ‰€æœ‰æŒå€‰ï¼šâ€¨å°æ–¼æ¯å€‹æŒå€‰ï¼Œå¦‚æœæŒå€‰æ™‚é–“è¶…é2å°æ™‚ï¼Œä¸¦ä¸”ç•¶å‰æœªå¯¦ç¾ç›ˆè™§ç‚ºè² ï¼Œå‰‡è§¸ç™¼å¹³å€‰ã€‚
5. å¹³å€‰æ“ä½œï¼šä½¿ç”¨å¸‚åƒ¹å–®å¹³å€‰ï¼Œä¸¦è¨˜éŒ„å¹³å€‰åŸå› ã€‚
æ³¨æ„ï¼šæˆ‘å€‘éœ€è¦é¿å…é‡è¤‡å¹³å€‰ï¼Œæ‰€ä»¥ç•¶è§¸ç™¼å¹³å€‰å¾Œï¼Œæˆ‘å€‘æ‡‰è©²å°‡è©²æŒå€‰æ¨™è¨˜ç‚ºæ­£åœ¨å¹³å€‰ï¼Œæˆ–è€…å¾position_entry_timeä¸­ç§»é™¤ï¼Œé¿å…å†æ¬¡è§¸ç™¼ã€‚
æˆ‘å€‘åœ¨PositionControllerä¸­å¢åŠ ä¸€å€‹æ–¹æ³•ä¾†åŸ·è¡Œå¼·åˆ¶æ­¢ææª¢æŸ¥ã€‚
ä»£ç¢¼çµæ§‹ï¼š
python
class PositionController:
    def __init__(self, ...):
        # ... ç¾æœ‰ä»£ç¢¼
        self.position_entry_time = {}  # è¨˜éŒ„æŒå€‰çš„é–‹å€‰æ™‚é–“
        self.forced_stop_loss_interval = 2 * 60 * 60  # 2å°æ™‚ï¼ˆç§’ï¼‰
        # å•Ÿå‹•å®šæ™‚ä»»å‹™
        asyncio.create_task(self._forced_stop_loss_loop())

    async def _forced_stop_loss_loop(self):
        """å¼·åˆ¶æ­¢æå¾ªç’°"""
        while True:
            await asyncio.sleep(300)  # æ¯5åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
            await self._check_forced_stop_loss()

    async def _check_forced_stop_loss(self):
        """æª¢æŸ¥å¼·åˆ¶æ­¢ææ¢ä»¶"""
        current_time = time.time()
        for symbol, position in self.active_positions.items():
            # å¦‚æœæŒå€‰æ•¸é‡ç‚º0ï¼Œè·³é
            if position.position_amt == 0:
                continue

            # å¦‚æœæ²’æœ‰è¨˜éŒ„é–‹å€‰æ™‚é–“ï¼Œå‰‡ä½¿ç”¨ç•¶å‰æ™‚é–“ï¼ˆèªªæ˜æ˜¯é‡å•Ÿå¾Œæ–°ç™¼ç¾çš„æŒå€‰ï¼‰
            if symbol not in self.position_entry_time:
                self.position_entry_time[symbol] = current_time
                continue

            entry_time = self.position_entry_time[symbol]
            holding_time = current_time - entry_time

            # å¦‚æœæŒå€‰æ™‚é–“è¶…é2å°æ™‚
            if holding_time >= self.forced_stop_loss_interval:
                # æª¢æŸ¥ç•¶å‰æ˜¯å¦è™§æ
                if position.unrealized_pnl < 0:
                    # è§¸ç™¼å¼·åˆ¶å¹³å€‰
                    logger.warning(f"ğŸ”´ å¼·åˆ¶æ­¢æè§¸ç™¼: {symbol}, æŒå€‰æ™‚é–“ {holding_time/3600:.2f} å°æ™‚, è™§æ {position.unrealized_pnl:.4f} USDT")
                    # ç™¼èµ·å¸‚åƒ¹å¹³å€‰
                    asyncio.create_task(self._forced_liquidate(symbol, position))

    async def _forced_liquidate(self, symbol: str, position: Position):
        """å¼·åˆ¶å¹³å€‰"""
        try:
            # ä½¿ç”¨å¸‚åƒ¹å–®å¹³å€‰
            order_side = "SELL" if position.position_amt > 0 else "BUY"
            quantity = abs(position.position_amt)
            
            # èª¿ç”¨äº¤æ˜“æ‰€APIä¸‹å–®
            order_result = await self.binance_client.create_market_order(
                symbol=symbol,
                side=order_side,
                quantity=quantity
            )
            
            logger.info(f"âœ… å¼·åˆ¶æ­¢æå¹³å€‰æˆåŠŸ: {symbol}, æ•¸é‡: {quantity}")
            
            # å¹³å€‰æˆåŠŸå¾Œï¼Œå¾é–‹å€‰æ™‚é–“è¨˜éŒ„ä¸­åˆªé™¤
            if symbol in self.position_entry_time:
                del self.position_entry_time[symbol]
                
        except Exception as e:
            logger.error(f"âŒ å¼·åˆ¶æ­¢æå¹³å€‰å¤±æ•—: {symbol}, éŒ¯èª¤: {e}")

    # åœ¨æ›´æ–°æŒå€‰æ™‚ï¼Œè¨˜éŒ„æ–°é–‹å€‰
    async def update_position(self, position: Position):
        # ç¾æœ‰æ›´æ–°é‚è¼¯...
        symbol = position.symbol
        # å¦‚æœæŒå€‰æ•¸é‡ä¸ç‚º0ä¸”ä¹‹å‰æ²’æœ‰è¨˜éŒ„ï¼Œå‰‡è¨˜éŒ„é–‹å€‰æ™‚é–“
        if position.position_amt != 0 and symbol not in self.position_entry_time:
            self.position_entry_time[symbol] = time.time()
        # å¦‚æœæŒå€‰æ•¸é‡ç‚º0ï¼Œå‰‡åˆªé™¤é–‹å€‰æ™‚é–“è¨˜éŒ„
        elif position.position_amt == 0 and symbol in self.position_entry_time:
            del self.position_entry_time[symbol]
æ³¨æ„ï¼šé€™è£¡çš„Positioné¡éœ€è¦åŒ…å«unrealized_pnlï¼ˆæœªå¯¦ç¾ç›ˆè™§ï¼‰å­—æ®µï¼Œæˆ‘å€‘å‡è¨­å¾WebSocketæˆ–APIç²å–çš„æŒå€‰æ•¸æ“šä¸­åŒ…å«é€™å€‹å­—æ®µã€‚
å¦‚æœæ²’æœ‰unrealized_pnlå­—æ®µï¼Œæˆ‘å€‘éœ€è¦æ ¹æ“šç•¶å‰åƒ¹æ ¼å’Œé–‹å€‰åƒ¹æ ¼è¨ˆç®—ã€‚è¨ˆç®—æ–¹æ³•ç‚ºï¼šâ€¨å¤šå€‰ï¼š (ç•¶å‰åƒ¹æ ¼ - é–‹å€‰åƒ¹æ ¼) * æŒå€‰æ•¸é‡â€¨ç©ºå€‰ï¼š (é–‹å€‰åƒ¹æ ¼ - ç•¶å‰åƒ¹æ ¼) * æŒå€‰æ•¸é‡
ä½†æ˜¯ï¼Œåœ¨æˆ‘å€‘çš„PositionControllerä¸­ï¼Œæˆ‘å€‘å·²ç¶“æœ‰æŒå€‰æ•¸æ“šï¼Œä¸¦ä¸”å¾WebSocketæ›´æ–°æ™‚æœƒæ›´æ–°æœªå¯¦ç¾ç›ˆè™§ã€‚æ‰€ä»¥æˆ‘å€‘ç›´æ¥ä½¿ç”¨position.unrealized_pnlã€‚
é¢¨éšªï¼šå¦‚æœWebSocketæ•¸æ“šä¸åŠæ™‚ï¼Œæœªå¯¦ç¾ç›ˆè™§å¯èƒ½ä¸æº–ç¢ºã€‚æˆ‘å€‘å¯ä»¥è€ƒæ…®åœ¨å¼·åˆ¶æ­¢ææª¢æŸ¥æ™‚ï¼Œç”¨ç•¶å‰åƒ¹æ ¼é‡æ–°è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§ã€‚
ç‚ºäº†æº–ç¢ºæ€§ï¼Œæˆ‘å€‘å¯ä»¥åœ¨å¼·åˆ¶æ­¢ææª¢æŸ¥æ™‚ï¼Œé€šéAPIç²å–ç•¶å‰åƒ¹æ ¼é‡æ–°è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§ã€‚ä½†é€™æ¨£æœƒå¢åŠ APIèª¿ç”¨ã€‚æˆ‘å€‘å¯ä»¥æŠ˜ä¸­ï¼šä½¿ç”¨WebSocketçš„æœ€æ–°åƒ¹æ ¼ï¼Œå¦‚æœç™¼ç¾æœªå¯¦ç¾ç›ˆè™§ç‚ºè² ï¼Œå†é€šéAPIç¢ºèªä¸€æ¬¡ã€‚
è€ƒæ…®åˆ°å¼·åˆ¶æ­¢ææ˜¯é—œéµæ“ä½œï¼Œæˆ‘å€‘æ‡‰è©²ä½¿ç”¨æœ€æ–°åƒ¹æ ¼ã€‚æˆ‘å€‘ä¿®æ”¹ä¸€ä¸‹ï¼š
åœ¨_check_forced_stop_lossä¸­ï¼Œæˆ‘å€‘ä¸ç›´æ¥ä½¿ç”¨position.unrealized_pnlï¼Œè€Œæ˜¯é€šéç•¶å‰åƒ¹æ ¼è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§ã€‚
æˆ‘å€‘å¯ä»¥é€™æ¨£åšï¼š
1. ç²å–ç•¶å‰åƒ¹æ ¼ï¼šé€šéWebSocketæœ€å¾Œçš„åƒ¹æ ¼ï¼Œæˆ–è€…é€šéAPIç²å–ï¼ˆå¦‚æœWebSocketåƒ¹æ ¼ä¸å¯ç”¨ï¼‰ã€‚
2. è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§ï¼šâ€¨å¦‚æœæŒå€‰æ•¸é‡>0ï¼ˆå¤šå€‰ï¼‰ï¼šæœªå¯¦ç¾ç›ˆè™§ = (ç•¶å‰åƒ¹æ ¼ - é–‹å€‰åƒ¹æ ¼) * æŒå€‰æ•¸é‡â€¨å¦‚æœæŒå€‰æ•¸é‡<0ï¼ˆç©ºå€‰ï¼‰ï¼šæœªå¯¦ç¾ç›ˆè™§ = (é–‹å€‰åƒ¹æ ¼ - ç•¶å‰åƒ¹æ ¼) * æŒå€‰æ•¸é‡
ä½†æ˜¯ï¼Œæˆ‘å€‘åœ¨Positioné¡ä¸­å·²ç¶“æœ‰é–‹å€‰åƒ¹æ ¼ï¼ˆentry_priceï¼‰å’ŒæŒå€‰æ•¸é‡ï¼ˆposition_amtï¼‰ã€‚æ‰€ä»¥æˆ‘å€‘å¯ä»¥è¨ˆç®—ã€‚
æˆ‘å€‘ä¿®æ”¹æª¢æŸ¥éƒ¨åˆ†ï¼š
python
    async def _check_forced_stop_loss(self):
        """æª¢æŸ¥å¼·åˆ¶æ­¢ææ¢ä»¶"""
        current_time = time.time()
        for symbol, position in self.active_positions.items():
            if position.position_amt == 0:
                continue

            if symbol not in self.position_entry_time:
                self.position_entry_time[symbol] = current_time
                continue

            entry_time = self.position_entry_time[symbol]
            holding_time = current_time - entry_time

            if holding_time >= self.forced_stop_loss_interval:
                # ç²å–ç•¶å‰åƒ¹æ ¼
                current_price = await self._get_current_price(symbol)
                if current_price is None:
                    logger.error(f"âŒ ç„¡æ³•ç²å– {symbol} çš„ç•¶å‰åƒ¹æ ¼ï¼Œè·³éå¼·åˆ¶æ­¢ææª¢æŸ¥")
                    continue

                # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
                if position.position_amt > 0:
                    unrealized_pnl = (current_price - position.entry_price) * position.position_amt
                else:
                    unrealized_pnl = (position.entry_price - current_price) * abs(position.position_amt)

                if unrealized_pnl < 0:
                    logger.warning(f"ğŸ”´ å¼·åˆ¶æ­¢æè§¸ç™¼: {symbol}, æŒå€‰æ™‚é–“ {holding_time/3600:.2f} å°æ™‚, è™§æ {unrealized_pnl:.4f} USDT")
                    asyncio.create_task(self._forced_liquidate(symbol, position))

    async def _get_current_price(self, symbol: str) -> float:
        """ç²å–ç•¶å‰åƒ¹æ ¼"""
        # é¦–å…ˆå˜—è©¦å¾WebSocketç²å–æœ€æ–°åƒ¹æ ¼
        if symbol in self.ws_last_price:
            return self.ws_last_price[symbol]
        else:
            # é€šéAPIç²å–
            try:
                ticker = await self.binance_client.get_ticker(symbol)
                return float(ticker['lastPrice'])
            except Exception as e:
                logger.error(f"âŒ ç²å– {symbol} ç•¶å‰åƒ¹æ ¼å¤±æ•—: {e}")
                return None
é€™æ¨£æˆ‘å€‘å°±å¯¦ç¾äº†åŸºæ–¼æŒå€‰æ™‚é–“å’Œè™§æç‹€æ…‹çš„å¼·åˆ¶æ­¢æã€‚
æ³¨æ„ï¼šæˆ‘å€‘éœ€è¦ç¢ºä¿_get_current_priceæ–¹æ³•èƒ½å¤ ç²å–åˆ°ç•¶å‰åƒ¹æ ¼ã€‚å¦‚æœç²å–å¤±æ•—ï¼Œæˆ‘å€‘è·³éé€™æ¬¡æª¢æŸ¥ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡ã€‚
å¦å¤–ï¼Œæˆ‘å€‘éœ€è¦è€ƒæ…®æŒå€‰æ•¸é‡ç‚º0æ™‚ï¼Œå¾active_positionsä¸­åˆªé™¤æŒå€‰å—ï¼Ÿé€™å–æ±ºæ–¼ç¾æœ‰çš„æŒå€‰ç®¡ç†é‚è¼¯ã€‚æˆ‘å€‘å‡è¨­active_positionsä¸­åªåŒ…å«æŒå€‰æ•¸é‡ä¸ç‚º0çš„æŒå€‰ã€‚
æœ€å¾Œï¼Œæˆ‘å€‘éœ€è¦ç¢ºä¿å¼·åˆ¶æ­¢æå¹³å€‰ä¸æœƒèˆ‡å…¶ä»–å¹³å€‰é‚è¼¯è¡çªã€‚ä¾‹å¦‚ï¼Œå¦‚æœåŒæ™‚è§¸ç™¼äº†å¼·åˆ¶æ­¢æå’Œå…¶ä»–æ­¢ææ¢ä»¶ï¼Œå¯èƒ½æœƒé‡è¤‡ä¸‹å–®ã€‚æˆ‘å€‘å¯ä»¥é€šéåœ¨å¹³å€‰æ™‚æª¢æŸ¥æŒå€‰æ˜¯å¦å·²ç¶“ç‚º0ä¾†é¿å…ï¼Œæˆ–è€…è¨­ç½®ä¸€å€‹å¹³å€‰æ¨™è¨˜ã€‚
æˆ‘å€‘å¯ä»¥åœ¨PositionControllerä¸­å¢åŠ ä¸€å€‹å¹³å€‰ä¸­çš„æ¨™è¨˜ï¼Œé¿å…é‡è¤‡å¹³å€‰ã€‚
æˆ‘å€‘åœ¨PositionControllerä¸­å¢åŠ ä¸€å€‹é›†åˆï¼Œè¨˜éŒ„æ­£åœ¨å¹³å€‰çš„symbolã€‚
python
    def __init__(self, ...):
        # ... ç¾æœ‰ä»£ç¢¼
        self.liquidating_symbols = set()

    async def _forced_liquidate(self, symbol: str, position: Position):
        if symbol in self.liquidating_symbols:
            return
        self.liquidating_symbols.add(symbol)
        try:
            # ... å¹³å€‰é‚è¼¯
        finally:
            self.liquidating_symbols.remove(symbol)
é€™æ¨£å¯ä»¥é¿å…åŒä¸€symbolçš„é‡è¤‡å¹³å€‰ã€‚
ç¸½çµï¼šâ€¨æˆ‘å€‘é€šéåœ¨PositionControllerä¸­è¨˜éŒ„æŒå€‰çš„é–‹å€‰æ™‚é–“ï¼Œä¸¦å®šæœŸæª¢æŸ¥æŒå€‰æ™‚é–“å’Œè™§ææƒ…æ³ï¼Œå¯¦ç¾äº†2å°æ™‚å¼·åˆ¶æ­¢æã€‚åœ¨æª¢æŸ¥æ™‚ï¼Œæˆ‘å€‘ä½¿ç”¨ç•¶å‰åƒ¹æ ¼è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§ï¼Œç¢ºä¿æº–ç¢ºæ€§ã€‚å¹³å€‰æ“ä½œä½¿ç”¨å¸‚åƒ¹å–®ï¼Œä¸¦é¿å…äº†é‡è¤‡å¹³å€‰ã€‚
è«‹æ ¹æ“šå¯¦éš›ä»£ç¢¼çµæ§‹é€²è¡Œèª¿æ•´ã€‚

â° åŸºæ–¼æ™‚é–“çš„å¼·åˆ¶æ­¢æç³»çµ±è¨­è¨ˆæ–¹æ¡ˆ
ğŸ¯Â ç³»çµ±æ¶æ§‹è¨­è¨ˆ
1. æ ¸å¿ƒçµ„ä»¶è¨­è¨ˆ
python
class TimeBasedStopLoss:
    """æ™‚é–“åŸºç¤æ­¢æç®¡ç†å™¨"""
    
    def __init__(self, config):
        self.max_holding_hours = config.get('MAX_HOLDING_HOURS', 2.0)
        self.check_interval = config.get('STOPLOSS_CHECK_INTERVAL', 60)  # 60ç§’æª¢æŸ¥ä¸€æ¬¡
        self.forced_liquidation_enabled = True
        self.position_timers = {}  # symbol -> entry_timestamp
        self.liquidation_in_progress = set()  # æ­£åœ¨å¹³å€‰çš„æ¨™çš„
        
    async def start_monitoring(self):
        """å•Ÿå‹•ç›£æ§å¾ªç’°"""
        while True:
            try:
                await self._check_all_positions()
                await asyncio.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"âŒ æ™‚é–“æ­¢æç›£æ§å¾ªç’°éŒ¯èª¤: {e}")
                await asyncio.sleep(30)  # éŒ¯èª¤æ™‚ç­‰å¾…30ç§’
2. æŒå€‰æ™‚é–“è¿½è¹¤ç³»çµ±
python
class PositionTimeTracker:
    """æŒå€‰æ™‚é–“è¿½è¹¤å™¨"""
    
    def __init__(self):
        self.position_records = {}  # position_key -> PositionTimeRecord
        self.persistence_file = "data/position_timers.json"
        self._lock = asyncio.Lock()
        
    async def record_position_entry(self, symbol: str, direction: str, entry_time: float = None):
        """è¨˜éŒ„æŒå€‰é–‹å€‰æ™‚é–“"""
        position_key = f"{symbol}_{direction}"
        
        async with self._lock:
            self.position_records[position_key] = {
                'symbol': symbol,
                'direction': direction,
                'entry_time': entry_time or time.time(),
                'last_check_time': time.time(),
                'status': 'active'
            }
            
        await self._save_to_disk()
        
    async def record_position_exit(self, symbol: str, direction: str):
        """è¨˜éŒ„æŒå€‰å¹³å€‰"""
        position_key = f"{symbol}_{direction}"
        
        async with self._lock:
            if position_key in self.position_records:
                self.position_records[position_key]['status'] = 'closed'
                self.position_records[position_key]['exit_time'] = time.time()
                
        await self._save_to_disk()
        
    async def get_holding_hours(self, symbol: str, direction: str) -> float:
        """ç²å–æŒå€‰å°æ™‚æ•¸"""
        position_key = f"{symbol}_{direction}"
        
        async with self._lock:
            if position_key not in self.position_records:
                return 0.0
                
            record = self.position_records[position_key]
            if record['status'] != 'active':
                return 0.0
                
            holding_seconds = time.time() - record['entry_time']
            return holding_seconds / 3600.0  # è½‰æ›ç‚ºå°æ™‚
3. æ™ºèƒ½è™§ææª¢æ¸¬ç³»çµ±
python
class SmartLossDetector:
    """æ™ºèƒ½è™§ææª¢æ¸¬å™¨"""
    
    def __init__(self, config):
        self.loss_threshold = config.get('LOSS_THRESHOLD', 0.0)  # ä»»ä½•è™§æéƒ½è§¸ç™¼
        self.price_tolerance = config.get('PRICE_TOLERANCE', 0.001)  # 0.1%åƒ¹æ ¼å®¹å·®
        self.require_confirmation = config.get('REQUIRE_LOSS_CONFIRMATION', True)
        
    async def is_position_losing(self, symbol: str, direction: str, 
                               entry_price: float, current_price: float,
                               position_size: float) -> tuple[bool, float]:
        """æª¢æ¸¬æŒå€‰æ˜¯å¦è™•æ–¼è™§æç‹€æ…‹"""
        
        # è¨ˆç®—æœªå¯¦ç¾ç›ˆè™§
        if direction == 'LONG':
            pnl = (current_price - entry_price) * position_size
        else:  # SHORT
            pnl = (entry_price - current_price) * position_size
            
        # è€ƒæ…®äº¤æ˜“æˆæœ¬å¾Œçš„å¯¦éš›è™§æ
        effective_pnl = self._adjust_for_fees(pnl, position_size, entry_price)
        
        # æª¢æŸ¥æ˜¯å¦é”åˆ°è™§æé–¾å€¼
        is_losing = effective_pnl < -self.price_tolerance * entry_price * position_size
        
        return is_losing, effective_pnl
        
    def _adjust_for_fees(self, raw_pnl: float, size: float, price: float) -> float:
        """èª¿æ•´äº¤æ˜“æˆæœ¬"""
        # å‡è¨­é›™å‘0.1%æ‰‹çºŒè²»
        fee_rate = 0.001
        total_fees = size * price * fee_rate * 2  # é–‹å€‰å’Œå¹³å€‰
        return raw_pnl - total_fees
ğŸ”§Â å®Œæ•´å¯¦ç¾æ–¹æ¡ˆ
4. æ™‚é–“æ­¢ææ§åˆ¶å™¨
python
class TimeStopLossController:
    """æ™‚é–“æ­¢æä¸»æ§åˆ¶å™¨"""
    
    def __init__(self, config, position_controller, binance_client):
        self.config = config
        self.position_controller = position_controller
        self.binance_client = binance_client
        
        # åˆå§‹åŒ–çµ„ä»¶
        self.time_tracker = PositionTimeTracker()
        self.loss_detector = SmartLossDetector(config)
        self.stop_loss_manager = TimeBasedStopLoss(config)
        
        # çµ±è¨ˆæ•¸æ“š
        self.stats = {
            'total_forced_liquidations': 0,
            'total_loss_prevented': 0.0,
            'last_liquidation_time': None
        }
        
    async def initialize(self):
        """åˆå§‹åŒ–æ§åˆ¶å™¨"""
        # åŠ è¼‰ç¾æœ‰æŒå€‰çš„æ™‚é–“è¨˜éŒ„
        await self._sync_with_active_positions()
        
        # å•Ÿå‹•ç›£æ§ä»»å‹™
        asyncio.create_task(self._monitoring_loop())
        
        logger.info("âœ… æ™‚é–“æ­¢æç³»çµ±åˆå§‹åŒ–å®Œæˆ")
        
    async def _sync_with_active_positions(self):
        """èˆ‡ç•¶å‰æŒå€‰åŒæ­¥"""
        try:
            positions = await self.position_controller.get_all_positions()
            for pos in positions:
                if float(pos.get('positionAmt', 0)) != 0:
                    symbol = pos['symbol']
                    direction = 'LONG' if float(pos['positionAmt']) > 0 else 'SHORT'
                    
                    # å¦‚æœæ²’æœ‰è¨˜éŒ„ï¼Œä½¿ç”¨ç•¶å‰æ™‚é–“ï¼ˆä¿å®ˆä¼°è¨ˆï¼‰
                    await self.time_tracker.record_position_entry(symbol, direction)
                    
        except Exception as e:
            logger.error(f"âŒ åŒæ­¥æŒå€‰æ™‚é–“è¨˜éŒ„å¤±æ•—: {e}")
            
    async def _monitoring_loop(self):
        """ä¸»ç›£æ§å¾ªç’°"""
        check_interval = self.config.get('STOPLOSS_CHECK_INTERVAL', 60)
        
        while True:
            try:
                await self._check_all_positions_for_stoploss()
                await asyncio.sleep(check_interval)
                
            except Exception as e:
                logger.error(f"âŒ æ™‚é–“æ­¢æç›£æ§å¾ªç’°éŒ¯èª¤: {e}")
                await asyncio.sleep(30)
                
    async def _check_all_positions_for_stoploss(self):
        """æª¢æŸ¥æ‰€æœ‰æŒå€‰çš„æ­¢ææ¢ä»¶"""
        positions = await self.position_controller.get_all_positions()
        
        for pos in positions:
            position_amt = float(pos.get('positionAmt', 0))
            if position_amt == 0:
                continue
                
            symbol = pos['symbol']
            direction = 'LONG' if position_amt > 0 else 'SHORT'
            entry_price = float(pos.get('entryPrice', 0))
            
            # è·³éæ­£åœ¨å¹³å€‰çš„æ¨™çš„
            if symbol in self.stop_loss_manager.liquidation_in_progress:
                continue
                
            # æª¢æŸ¥æŒå€‰æ™‚é–“
            holding_hours = await self.time_tracker.get_holding_hours(symbol, direction)
            
            if holding_hours >= self.stop_loss_manager.max_holding_hours:
                # ç²å–ç•¶å‰åƒ¹æ ¼
                current_price = await self._get_current_price(symbol)
                if current_price is None:
                    continue
                    
                # æª¢æŸ¥æ˜¯å¦è™§æ
                is_losing, pnl_amount = await self.loss_detector.is_position_losing(
                    symbol, direction, entry_price, current_price, abs(position_amt)
                )
                
                if is_losing:
                    logger.warning(
                        f"ğŸ”´ è§¸ç™¼æ™‚é–“æ­¢æ: {symbol} {direction} | "
                        f"æŒå€‰: {holding_hours:.2f}h | è™§æ: ${pnl_amount:.2f}"
                    )
                    
                    # åŸ·è¡Œå¼·åˆ¶å¹³å€‰
                    await self._execute_forced_liquidation(symbol, direction, abs(position_amt))
                    
    async def _get_current_price(self, symbol: str) -> float:
        """ç²å–ç•¶å‰åƒ¹æ ¼ï¼ˆå¤šä¾†æºfallbackï¼‰"""
        try:
            # 1. å˜—è©¦WebSocketæœ€æ–°åƒ¹æ ¼
            if hasattr(self.position_controller, 'ws_last_price'):
                if symbol in self.position_controller.ws_last_price:
                    return self.position_controller.ws_last_price[symbol]
                    
            # 2. å˜—è©¦REST API
            ticker = await self.binance_client.get_ticker(symbol)
            return float(ticker['lastPrice'])
            
        except Exception as e:
            logger.error(f"âŒ ç²å– {symbol} åƒ¹æ ¼å¤±æ•—: {e}")
            return None
            
    async def _execute_forced_liquidation(self, symbol: str, direction: str, quantity: float):
        """åŸ·è¡Œå¼·åˆ¶å¹³å€‰"""
        if symbol in self.stop_loss_manager.liquidation_in_progress:
            return
            
        self.stop_loss_manager.liquidation_in_progress.add(symbol)
        
        try:
            # ç¢ºå®šå¹³å€‰æ–¹å‘
            side = 'SELL' if direction == 'LONG' else 'BUY'
            
            logger.info(f"ğŸš¨ åŸ·è¡Œæ™‚é–“æ­¢æå¹³å€‰: {symbol} {side} {quantity}")
            
            # ä½¿ç”¨å¸‚åƒ¹å–®å¹³å€‰
            order_result = await self.binance_client.create_market_order(
                symbol=symbol,
                side=side,
                quantity=quantity
            )
            
            # æ›´æ–°çµ±è¨ˆ
            self.stats['total_forced_liquidations'] += 1
            self.stats['last_liquidation_time'] = time.time()
            
            logger.info(f"âœ… æ™‚é–“æ­¢æå¹³å€‰æˆåŠŸ: {symbol} | è¨‚å–®ID: {order_result.get('orderId')}")
            
            # æ›´æ–°æŒå€‰è¨˜éŒ„
            await self.time_tracker.record_position_exit(symbol, direction)
            
        except Exception as e:
            logger.error(f"âŒ æ™‚é–“æ­¢æå¹³å€‰å¤±æ•—: {symbol} - {e}")
            
            # é‡è©¦é‚è¼¯
            await self._handle_liquidation_failure(symbol, direction, quantity)
            
        finally:
            self.stop_loss_manager.liquidation_in_progress.discard(symbol)
            
    async def _handle_liquidation_failure(self, symbol: str, direction: str, quantity: float):
        """è™•ç†å¹³å€‰å¤±æ•—æƒ…æ³"""
        max_retries = 3
        retry_delay = 5  # ç§’
        
        for attempt in range(max_retries):
            try:
                logger.warning(f"ğŸ”„ å˜—è©¦é‡æ–°å¹³å€‰ {symbol} (å˜—è©¦ {attempt + 1}/{max_retries})")
                
                side = 'SELL' if direction == 'LONG' else 'BUY'
                order_result = await self.binance_client.create_market_order(
                    symbol=symbol,
                    side=side,
                    quantity=quantity
                )
                
                logger.info(f"âœ… é‡è©¦å¹³å€‰æˆåŠŸ: {symbol}")
                await self.time_tracker.record_position_exit(symbol, direction)
                return
                
            except Exception as e:
                logger.error(f"âŒ é‡è©¦å¹³å€‰å¤±æ•— ({attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(retry_delay)
                    
        # æ‰€æœ‰é‡è©¦éƒ½å¤±æ•—
        logger.critical(f"ğŸ’¥ æ™‚é–“æ­¢æå¹³å€‰å®Œå…¨å¤±æ•—: {symbol}ï¼Œéœ€è¦æ‰‹å‹•è™•ç†ï¼")
5. é…ç½®ç®¡ç†
python
# config.py æ–°å¢é…ç½®é …
TIME_STOPLOSS_CONFIG = {
    'ENABLED': True,
    'MAX_HOLDING_HOURS': 2.0,  # æœ€å¤§æŒå€‰å°æ™‚æ•¸
    'STOPLOSS_CHECK_INTERVAL': 60,  # æª¢æŸ¥é–“éš”(ç§’)
    'LOSS_THRESHOLD': 0.0,  # è™§æé–¾å€¼(ä»»ä½•è™§æéƒ½è§¸ç™¼)
    'PRICE_TOLERANCE': 0.001,  # åƒ¹æ ¼å®¹å·®(0.1%)
    'REQUIRE_LOSS_CONFIRMATION': True,  # éœ€è¦è™§æç¢ºèª
    'EMERGENCY_BYPASS': True,  # ç·Šæ€¥æƒ…æ³ä¸‹ç¹éæ­£å¸¸æµç¨‹
}

# ç’°å¢ƒè®Šé‡è¦†è“‹
if os.getenv('TIME_STOPLOSS_ENABLED'):
    TIME_STOPLOSS_CONFIG['ENABLED'] = os.getenv('TIME_STOPLOSS_ENABLED').lower() == 'true'
    
if os.getenv('MAX_HOLDING_HOURS'):
    TIME_STOPLOSS_CONFIG['MAX_HOLDING_HOURS'] = float(os.getenv('MAX_HOLDING_HOURS'))
6. é›†æˆåˆ°ä¸»ç³»çµ±
python
class EnhancedPositionController(PositionController):
    """å¢å¼·ç‰ˆæŒå€‰æ§åˆ¶å™¨ï¼ˆé›†æˆæ™‚é–“æ­¢æï¼‰"""
    
    def __init__(self, config, binance_client, ...):
        super().__init__(config, binance_client, ...)
        
        # åˆå§‹åŒ–æ™‚é–“æ­¢æç³»çµ±
        self.time_stoploss_controller = TimeStopLossController(
            config.TIME_STOPLOSS_CONFIG, self, binance_client
        )
        
    async def initialize(self):
        """åˆå§‹åŒ–æŒå€‰æ§åˆ¶å™¨"""
        await super().initialize()
        
        # å•Ÿå‹•æ™‚é–“æ­¢æç³»çµ±
        if self.config.TIME_STOPLOSS_CONFIG['ENABLED']:
            await self.time_stoploss_controller.initialize()
            
    async def open_position(self, symbol: str, direction: str, ...):
        """é–‹å€‰ï¼ˆè¨˜éŒ„æ™‚é–“ï¼‰"""
        result = await super().open_position(symbol, direction, ...)
        
        if result and self.config.TIME_STOPLOSS_CONFIG['ENABLED']:
            # è¨˜éŒ„é–‹å€‰æ™‚é–“
            await self.time_stoploss_controller.time_tracker.record_position_entry(
                symbol, direction
            )
            
        return result
        
    async def close_position(self, symbol: str, direction: str, ...):
        """å¹³å€‰ï¼ˆæ›´æ–°æ™‚é–“è¨˜éŒ„ï¼‰"""
        result = await super().close_position(symbol, direction, ...)
        
        if result and self.config.TIME_STOPLOSS_CONFIG['ENABLED']:
            # æ›´æ–°å¹³å€‰æ™‚é–“
            await self.time_stoploss_controller.time_tracker.record_position_exit(
                symbol, direction
            )
            
        return result
ğŸ“ŠÂ ç›£æ§å’Œå‘Šè­¦ç³»çµ±
7. çµ±è¨ˆå’Œå ±å‘Š
python
class TimeStoplossReporter:
    """æ™‚é–“æ­¢æå ±å‘Šå™¨"""
    
    def __init__(self, controller: TimeStopLossController):
        self.controller = controller
        
    async def generate_daily_report(self) -> dict:
        """ç”Ÿæˆæ¯æ—¥å ±å‘Š"""
        return {
            'date': datetime.now().strftime('%Y-%m-%d'),
            'total_liquidations': self.controller.stats['total_forced_liquidations'],
            'prevented_losses': self.controller.stats['total_loss_prevented'],
            'active_monitoring': len(self.controller.time_tracker.position_records),
            'system_health': await self._check_system_health()
        }
        
    async def send_alert(self, symbol: str, reason: str, details: dict):
        """ç™¼é€å‘Šè­¦"""
        alert_message = {
            'type': 'TIME_STOPLOSS_ALERT',
            'symbol': symbol,
            'reason': reason,
            'timestamp': time.time(),
            'details': details
        }
        
        # ç™¼é€åˆ°æ—¥èªŒ
        logger.warning(f"ğŸš¨ æ™‚é–“æ­¢æå‘Šè­¦: {alert_message}")
        
        # å¯é›†æˆåˆ°éƒµä»¶/Telegramç­‰é€šçŸ¥ç³»çµ±
        await self._send_external_alert(alert_message)
8. é¢¨éšªæ§åˆ¶
python
class TimeStoplossRiskManager:
    """æ™‚é–“æ­¢æé¢¨éšªç®¡ç†å™¨"""
    
    def __init__(self, config):
        self.max_daily_liquidations = config.get('MAX_DAILY_LIQUIDATIONS', 10)
        self.cooldown_after_liquidation = config.get('COOLDOWN_MINUTES', 30)
        self.liquidation_count_today = 0
        self.last_reset_time = time.time()
        
    async def can_proceed_liquidation(self, symbol: str) -> bool:
        """æª¢æŸ¥æ˜¯å¦å¯ä»¥åŸ·è¡Œå¹³å€‰"""
        # é‡ç½®æ¯æ—¥è¨ˆæ•¸
        await self._reset_daily_count_if_needed()
        
        # æª¢æŸ¥æ¯æ—¥é™åˆ¶
        if self.liquidation_count_today >= self.max_daily_liquidations:
            logger.error(f"âŒ é”åˆ°æ¯æ—¥å¹³å€‰é™åˆ¶: {self.max_daily_liquidations}")
            return False
            
        # æª¢æŸ¥å†·å»æœŸ
        last_liquidation = self.controller.stats.get('last_liquidation_time', 0)
        if time.time() - last_liquidation < self.cooldown_after_liquidation * 60:
            logger.warning(f"âš ï¸ å¹³å€‰å†·å»æœŸä¸­ï¼Œè·³é: {symbol}")
            return False
            
        return True
        
    async def record_liquidation(self):
        """è¨˜éŒ„å¹³å€‰äº‹ä»¶"""
        self.liquidation_count_today += 1
ğŸ§ªÂ æ¸¬è©¦æ–¹æ¡ˆ
9. å–®å…ƒæ¸¬è©¦
python
class TestTimeStopLoss:
    """æ™‚é–“æ­¢ææ¸¬è©¦å¥—ä»¶"""
    
    async def test_holding_time_calculation(self):
        """æ¸¬è©¦æŒå€‰æ™‚é–“è¨ˆç®—"""
        tracker = PositionTimeTracker()
        
        # æ¨¡æ“¬é–‹å€‰
        entry_time = time.time() - 7200  # 2å°æ™‚å‰
        await tracker.record_position_entry('BTCUSDT', 'LONG', entry_time)
        
        holding_hours = await tracker.get_holding_hours('BTCUSDT', 'LONG')
        assert abs(holding_hours - 2.0) < 0.1  # å…è¨±èª¤å·®
        
    async def test_loss_detection(self):
        """æ¸¬è©¦è™§ææª¢æ¸¬"""
        detector = SmartLossDetector({'LOSS_THRESHOLD': 0.0})
        
        # æ¨¡æ“¬è™§ææƒ…æ³
        is_losing, pnl = await detector.is_position_losing(
            'BTCUSDT', 'LONG', 
            entry_price=50000, 
            current_price=49000, 
            position_size=1
        )
        
        assert is_losing == True
        assert pnl < 0
        
    async def test_forced_liquidation_flow(self):
        """æ¸¬è©¦å¼·åˆ¶å¹³å€‰æµç¨‹"""
        controller = TimeStopLossController(...)
        
        # æ¨¡æ“¬è§¸ç™¼æ¢ä»¶
        with patch.object(controller, '_get_current_price', return_value=49000):
            with patch.object(controller, '_execute_forced_liquidation') as mock_liquidate:
                await controller._check_all_positions_for_stoploss()
                
                # é©—è­‰å¹³å€‰è¢«èª¿ç”¨
                mock_liquidate.assert_called_once()
10. é›†æˆæ¸¬è©¦
python
async def test_integration_scenario():
    """å®Œæ•´é›†æˆæ¸¬è©¦å ´æ™¯"""
    # 1. åˆå§‹åŒ–ç³»çµ±
    controller = EnhancedPositionController(config, binance_client)
    await controller.initialize()
    
    # 2. æ¨¡æ“¬é–‹å€‰
    await controller.open_position('BTCUSDT', 'LONG', quantity=0.01, price=50000)
    
    # 3. æ¨¡æ“¬åƒ¹æ ¼ä¸‹è·Œå’Œæ™‚é–“æµé€
    # è¨­ç½®ç•¶å‰åƒ¹æ ¼ä½æ–¼å…¥å ´åƒ¹
    controller.ws_last_price['BTCUSDT'] = 49000
    
    # æ¨¡æ“¬æ™‚é–“æµé€ï¼ˆ2å°æ™‚å¾Œï¼‰
    with patch('time.time', return_value=time.time() + 7200):
        # 4. è§¸ç™¼æª¢æŸ¥
        await controller.time_stoploss_controller._check_all_positions_for_stoploss()
        
        # 5. é©—è­‰å¹³å€‰è¢«åŸ·è¡Œ
        # é€™è£¡æ‡‰è©²è§€å¯Ÿåˆ°å¹³å€‰è¨‚å–®è¢«å‰µå»º
        
    logger.info("âœ… é›†æˆæ¸¬è©¦é€šé")
ğŸš€Â éƒ¨ç½²ç­–ç•¥
11. æ¼¸é€²å¼éƒ¨ç½²
python
class GradualDeploymentManager:
    """æ¼¸é€²å¼éƒ¨ç½²ç®¡ç†å™¨"""
    
    def __init__(self, controller):
        self.controller = controller
        self.deployment_phase = 'TESTING'  # TESTING -> LIMITED -> FULL
        
    async def should_apply_stoploss(self, symbol: str) -> bool:
        """æ ¹æ“šéƒ¨ç½²éšæ®µæ±ºå®šæ˜¯å¦æ‡‰ç”¨æ­¢æ"""
        if self.deployment_phase == 'TESTING':
            # åªç›£æ§ä¸åŸ·è¡Œ
            return False
        elif self.deployment_phase == 'LIMITED':
            # åªæ‡‰ç”¨æ–¼ä¸»è¦äº¤æ˜“å°
            major_pairs = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
            return symbol in major_pairs
        else:  # FULL
            return True
            
    async def upgrade_deployment_phase(self):
        """å‡ç´šéƒ¨ç½²éšæ®µ"""
        if self.deployment_phase == 'TESTING':
            self.deployment_phase = 'LIMITED'
        elif self.deployment_phase == 'LIMITED':
            self.deployment_phase = 'FULL'
            
        logger.info(f"ğŸ”„ æ™‚é–“æ­¢æéƒ¨ç½²éšæ®µå‡ç´š: {self.deployment_phase}")
12. ç›£æ§å„€è¡¨æ¿
python
class TimeStoplossDashboard:
    """æ™‚é–“æ­¢æç›£æ§å„€è¡¨æ¿"""
    
    @staticmethod
    async def get_system_status() -> dict:
        """ç²å–ç³»çµ±ç‹€æ…‹"""
        return {
            'enabled': config.TIME_STOPLOSS_CONFIG['ENABLED'],
            'max_holding_hours': config.TIME_STOPLOSS_CONFIG['MAX_HOLDING_HOURS'],
            'monitoring_count': len(controller.time_tracker.position_records),
            'today_liquidations': controller.stats['total_forced_liquidations'],
            'system_uptime': time.time() - controller.start_time,
            'last_check': controller.last_check_time
        }



