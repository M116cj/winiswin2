ğŸŸ¡Â ç¬¬2éšæ®µï¼šç©©å®šæ€§åŠ å›º
2.1 ç•°å¸¸è™•ç†è¦ç¯„åŒ–
python
class ExceptionHandler:
    """çµ±ä¸€çš„ç•°å¸¸è™•ç†ç­–ç•¥"""
    
    @staticmethod
    def async_api_call(func):
        """APIèª¿ç”¨ç•°å¸¸è™•ç†è£é£¾å™¨"""
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except asyncio.TimeoutError:
                logger.error(f"â° APIèª¿ç”¨è¶…æ™‚: {func.__name__}")
                raise
            except aiohttp.ClientError as e:
                logger.error(f"ğŸŒ ç¶²çµ¡éŒ¯èª¤: {func.__name__} - {e}")
                raise
            except json.JSONDecodeError as e:
                logger.error(f"ğŸ“„ JSONè§£æéŒ¯èª¤: {func.__name__} - {e}")
                raise
            except Exception as e:
                logger.error(f"âŒ æœªé æœŸéŒ¯èª¤: {func.__name__} - {e}")
                raise
        return wrapper
    
    @staticmethod
    def critical_section(func):
        """é—œéµå€æ®µç•°å¸¸è™•ç†"""
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except (asyncio.CancelledError, KeyboardInterrupt):
                    raise  # ä¸æ•ç²ç³»çµ±ç´šç•°å¸¸
                except Exception as e:
                    if attempt == max_retries - 1:
                        logger.critical(f"ğŸ’¥ é—œéµæ“ä½œå¤±æ•—: {func.__name__} - {e}")
                        raise
                    await asyncio.sleep(2 ** attempt)  # æŒ‡æ•¸é€€é¿
        return wrapper

# æ‡‰ç”¨ç¤ºä¾‹
class BinanceClient:
    @ExceptionHandler.async_api_call
    async def get_ticker(self, symbol: str):
        response = await self.session.get(f"/api/v3/ticker/price?symbol={symbol}")
        return await response.json()
2.2 æ•¸æ“šä¸€è‡´æ€§ä¿éšœ
python
class DataConsistencyManager:
    """æ•¸æ“šä¸€è‡´æ€§ç®¡ç†å™¨"""
    
    def __init__(self):
        self.position_cache = {}
        self.cache_lock = asyncio.Lock()
        self.cache_ttl = 30  # 30ç§’ç·©å­˜
        
    async def get_position_with_fallback(self, symbol: str) -> dict:
        """ç²å–æŒå€‰æ•¸æ“šï¼Œå¸¶å¤šç´šfallback"""
        # 1. å˜—è©¦WebSocketå¯¦æ™‚æ•¸æ“š
        ws_position = await self._get_ws_position(symbol)
        if ws_position and self._validate_position_data(ws_position):
            await self._update_cache(symbol, ws_position)
            return ws_position
            
        # 2. å˜—è©¦ç·©å­˜æ•¸æ“š
        cached = await self._get_cached_position(symbol)
        if cached and self._validate_position_data(cached):
            logger.warning(f"âš ï¸ ä½¿ç”¨ç·©å­˜æ•¸æ“š: {symbol}")
            return cached
            
        # 3. å¼·åˆ¶REST APIæŸ¥è©¢
        try:
            rest_position = await self._fetch_rest_position(symbol)
            if rest_position:
                await self._update_cache(symbol, rest_position)
                return rest_position
        except Exception as e:
            logger.error(f"âŒ REST APIæŸ¥è©¢å¤±æ•—: {symbol} - {e}")
            
        # 4. æœ€çµ‚fallback
        logger.error(f"ğŸ’¥ ç„¡æ³•ç²å–æœ‰æ•ˆæŒå€‰æ•¸æ“š: {symbol}")
        return self._create_safe_default_position(symbol)
    
    def _validate_position_data(self, position: dict) -> bool:
        """é©—è­‰æŒå€‰æ•¸æ“šæœ‰æ•ˆæ€§"""
        required_fields = ['symbol', 'positionAmt', 'entryPrice']
        return all(field in position for field in required_fields)
2.3 ä½µç™¼è¨ªå•æ§åˆ¶
python
class ConcurrentDictManager:
    """ç·šç¨‹å®‰å…¨çš„å­—å…¸ç®¡ç†å™¨"""
    
    def __init__(self):
        self._data = {}
        self._lock = asyncio.Lock()
        self._version = 0  # ç”¨æ–¼æ¨‚è§€é–
        
    async def safe_update(self, key, value):
        """å®‰å…¨çš„å­—å…¸æ›´æ–°"""
        async with self._lock:
            old_version = self._version
            self._data[key] = value
            self._version += 1
            return old_version, self._version
            
    async def safe_iterate(self, callback):
        """å®‰å…¨çš„å­—å…¸éæ­·"""
        async with self._lock:
            # å‰µå»ºå¿«ç…§é¿å…è¿­ä»£æ™‚ä¿®æ”¹
            snapshot = self._data.copy()
            
        # åœ¨é–å¤–åŸ·è¡Œå›èª¿ï¼Œé¿å…æ­»é–
        results = []
        for key, value in snapshot.items():
            result = await callback(key, value)
            results.append(result)
            
        return results

# åœ¨VirtualPositionManagerä¸­æ‡‰ç”¨
class VirtualPositionManager:
    def __init__(self):
        self.positions_manager = ConcurrentDictManager()
        self.tasks_manager = ConcurrentDictManager()
        
    async def add_position(self, position: VirtualPosition):
        position_key = f"{position.symbol}_{position.direction}"
        await self.positions_manager.safe_update(position_key, position)
        
    async def remove_position(self, symbol: str, direction: str):
        position_key = f"{symbol}_{direction}"
        async with self.positions_manager._lock:
            if position_key in self.positions_manager._data:
                del self.positions_manager._data[position_key]
